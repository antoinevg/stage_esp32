/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 9;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 1;
pub const __clang_version__ : & 'static [ u8 ; 95usize ] = b"9.0.1 (https://github.com/espressif/llvm-project.git 96ef209fd7cb4ad374e111fcf02491c4e1de1845)\0" ;
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GNUC__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__ : & 'static [ u8 ; 101usize ] = b"Clang 9.0.1 (https://github.com/espressif/llvm-project.git 96ef209fd7cb4ad374e111fcf02491c4e1de1845)\0" ;
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _ILP32: u32 = 1;
pub const __ILP32__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u32 = 2147483647;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 255;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: u32 = 4294967295;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u32 = 2147483647;
pub const __INTPTR_MAX__: u32 = 2147483647;
pub const __UINTPTR_MAX__: u32 = 4294967295;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 4;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 8;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 4;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 4;
pub const __SIZEOF_SIZE_T__: u32 = 4;
pub const __SIZEOF_WCHAR_T__: u32 = 1;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __INTMAX_FMTd__: &'static [u8; 4usize] = b"lld\0";
pub const __INTMAX_FMTi__: &'static [u8; 4usize] = b"lli\0";
pub const __UINTMAX_FMTo__: &'static [u8; 4usize] = b"llo\0";
pub const __UINTMAX_FMTu__: &'static [u8; 4usize] = b"llu\0";
pub const __UINTMAX_FMTx__: &'static [u8; 4usize] = b"llx\0";
pub const __UINTMAX_FMTX__: &'static [u8; 4usize] = b"llX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __PTRDIFF_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __PTRDIFF_WIDTH__: u32 = 32;
pub const __INTPTR_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INTPTR_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INTPTR_WIDTH__: u32 = 32;
pub const __SIZE_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __SIZE_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __SIZE_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __SIZE_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __SIZE_WIDTH__: u32 = 32;
pub const __WCHAR_WIDTH__: u32 = 8;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINTPTR_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINTPTR_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINTPTR_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINTPTR_WIDTH__: u32 = 32;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 15;
pub const __LDBL_DECIMAL_DIG__: u32 = 17;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 53;
pub const __LDBL_MAX_10_EXP__: u32 = 308;
pub const __LDBL_MAX_EXP__: u32 = 1024;
pub const __LDBL_MIN_10_EXP__: i32 = -307;
pub const __LDBL_MIN_EXP__: i32 = -1021;
pub const __POINTER_WIDTH__: u32 = 32;
pub const __BIGGEST_ALIGNMENT__: u32 = 4;
pub const __WCHAR_UNSIGNED__: u32 = 1;
pub const __WINT_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &'static [u8; 4usize] = b"lld\0";
pub const __INT64_FMTi__: &'static [u8; 4usize] = b"lli\0";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 4usize] = b"llo\0";
pub const __UINT64_FMTu__: &'static [u8; 4usize] = b"llu\0";
pub const __UINT64_FMTx__: &'static [u8; 4usize] = b"llx\0";
pub const __UINT64_FMTX__: &'static [u8; 4usize] = b"llX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 4usize] = b"lld\0";
pub const __INT_LEAST64_FMTi__: &'static [u8; 4usize] = b"lli\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 4usize] = b"llo\0";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 4usize] = b"llu\0";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 4usize] = b"llx\0";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 4usize] = b"llX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 4usize] = b"lld\0";
pub const __INT_FAST64_FMTi__: &'static [u8; 4usize] = b"lli\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 4usize] = b"llo\0";
pub const __UINT_FAST64_FMTu__: &'static [u8; 4usize] = b"llu\0";
pub const __UINT_FAST64_FMTx__: &'static [u8; 4usize] = b"llx\0";
pub const __UINT_FAST64_FMTX__: &'static [u8; 4usize] = b"llX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 1;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 1;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 17;
pub const __Xtensa__: u32 = 1;
pub const __xtensa__: u32 = 1;
pub const __XTENSA__: u32 = 1;
pub const __XTENSA_WINDOWED_ABI__: u32 = 1;
pub const __XTENSA_EL__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201112;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const __error_t_defined: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"2.2.0\0";
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _NANO_FORMATTED_IO: u32 = 1;
pub const __NEWLIB__: u32 = 2;
pub const __NEWLIB_MINOR__: u32 = 1;
pub const _POSIX_THREADS: u32 = 1;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const XCHAL_HAVE_BE: u32 = 0;
pub const XCHAL_HAVE_WINDOWED: u32 = 1;
pub const XCHAL_NUM_AREGS: u32 = 64;
pub const XCHAL_NUM_AREGS_LOG2: u32 = 6;
pub const XCHAL_MAX_INSTRUCTION_SIZE: u32 = 3;
pub const XCHAL_HAVE_DEBUG: u32 = 1;
pub const XCHAL_HAVE_DENSITY: u32 = 1;
pub const XCHAL_HAVE_LOOPS: u32 = 1;
pub const XCHAL_LOOP_BUFFER_SIZE: u32 = 256;
pub const XCHAL_HAVE_NSA: u32 = 1;
pub const XCHAL_HAVE_MINMAX: u32 = 1;
pub const XCHAL_HAVE_SEXT: u32 = 1;
pub const XCHAL_HAVE_DEPBITS: u32 = 0;
pub const XCHAL_HAVE_CLAMPS: u32 = 1;
pub const XCHAL_HAVE_MUL16: u32 = 1;
pub const XCHAL_HAVE_MUL32: u32 = 1;
pub const XCHAL_HAVE_MUL32_HIGH: u32 = 1;
pub const XCHAL_HAVE_DIV32: u32 = 1;
pub const XCHAL_HAVE_L32R: u32 = 1;
pub const XCHAL_HAVE_ABSOLUTE_LITERALS: u32 = 0;
pub const XCHAL_HAVE_CONST16: u32 = 0;
pub const XCHAL_HAVE_ADDX: u32 = 1;
pub const XCHAL_HAVE_WIDE_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_PREDICTED_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_CALL4AND12: u32 = 1;
pub const XCHAL_HAVE_ABS: u32 = 1;
pub const XCHAL_HAVE_RELEASE_SYNC: u32 = 1;
pub const XCHAL_HAVE_S32C1I: u32 = 1;
pub const XCHAL_HAVE_SPECULATION: u32 = 0;
pub const XCHAL_HAVE_FULL_RESET: u32 = 1;
pub const XCHAL_NUM_CONTEXTS: u32 = 1;
pub const XCHAL_NUM_MISC_REGS: u32 = 4;
pub const XCHAL_HAVE_TAP_MASTER: u32 = 0;
pub const XCHAL_HAVE_PRID: u32 = 1;
pub const XCHAL_HAVE_EXTERN_REGS: u32 = 1;
pub const XCHAL_HAVE_MX: u32 = 0;
pub const XCHAL_HAVE_MP_INTERRUPTS: u32 = 0;
pub const XCHAL_HAVE_MP_RUNSTALL: u32 = 0;
pub const XCHAL_HAVE_PSO: u32 = 0;
pub const XCHAL_HAVE_PSO_CDM: u32 = 0;
pub const XCHAL_HAVE_PSO_FULL_RETENTION: u32 = 0;
pub const XCHAL_HAVE_THREADPTR: u32 = 1;
pub const XCHAL_HAVE_BOOLEANS: u32 = 1;
pub const XCHAL_HAVE_CP: u32 = 1;
pub const XCHAL_CP_MAXCFG: u32 = 8;
pub const XCHAL_HAVE_MAC16: u32 = 1;
pub const XCHAL_HAVE_FUSION: u32 = 0;
pub const XCHAL_HAVE_FUSION_FP: u32 = 0;
pub const XCHAL_HAVE_FUSION_LOW_POWER: u32 = 0;
pub const XCHAL_HAVE_FUSION_AES: u32 = 0;
pub const XCHAL_HAVE_FUSION_CONVENC: u32 = 0;
pub const XCHAL_HAVE_FUSION_LFSR_CRC: u32 = 0;
pub const XCHAL_HAVE_FUSION_BITOPS: u32 = 0;
pub const XCHAL_HAVE_FUSION_AVS: u32 = 0;
pub const XCHAL_HAVE_FUSION_16BIT_BASEBAND: u32 = 0;
pub const XCHAL_HAVE_FUSION_VITERBI: u32 = 0;
pub const XCHAL_HAVE_FUSION_SOFTDEMAP: u32 = 0;
pub const XCHAL_HAVE_HIFIPRO: u32 = 0;
pub const XCHAL_HAVE_HIFI4: u32 = 0;
pub const XCHAL_HAVE_HIFI4_VFPU: u32 = 0;
pub const XCHAL_HAVE_HIFI3: u32 = 0;
pub const XCHAL_HAVE_HIFI3_VFPU: u32 = 0;
pub const XCHAL_HAVE_HIFI2: u32 = 0;
pub const XCHAL_HAVE_HIFI2EP: u32 = 0;
pub const XCHAL_HAVE_HIFI_MINI: u32 = 0;
pub const XCHAL_HAVE_VECTORFPU2005: u32 = 0;
pub const XCHAL_HAVE_USER_DPFPU: u32 = 0;
pub const XCHAL_HAVE_USER_SPFPU: u32 = 0;
pub const XCHAL_HAVE_FP: u32 = 1;
pub const XCHAL_HAVE_FP_DIV: u32 = 1;
pub const XCHAL_HAVE_FP_RECIP: u32 = 1;
pub const XCHAL_HAVE_FP_SQRT: u32 = 1;
pub const XCHAL_HAVE_FP_RSQRT: u32 = 1;
pub const XCHAL_HAVE_DFP: u32 = 0;
pub const XCHAL_HAVE_DFP_DIV: u32 = 0;
pub const XCHAL_HAVE_DFP_RECIP: u32 = 0;
pub const XCHAL_HAVE_DFP_SQRT: u32 = 0;
pub const XCHAL_HAVE_DFP_RSQRT: u32 = 0;
pub const XCHAL_HAVE_DFP_ACCEL: u32 = 1;
pub const XCHAL_HAVE_DFP_accel: u32 = 1;
pub const XCHAL_HAVE_DFPU_SINGLE_ONLY: u32 = 1;
pub const XCHAL_HAVE_DFPU_SINGLE_DOUBLE: u32 = 0;
pub const XCHAL_HAVE_VECTRA1: u32 = 0;
pub const XCHAL_HAVE_VECTRALX: u32 = 0;
pub const XCHAL_HAVE_PDX4: u32 = 0;
pub const XCHAL_HAVE_CONNXD2: u32 = 0;
pub const XCHAL_HAVE_CONNXD2_DUALLSFLIX: u32 = 0;
pub const XCHAL_HAVE_BBE16: u32 = 0;
pub const XCHAL_HAVE_BBE16_RSQRT: u32 = 0;
pub const XCHAL_HAVE_BBE16_VECDIV: u32 = 0;
pub const XCHAL_HAVE_BBE16_DESPREAD: u32 = 0;
pub const XCHAL_HAVE_BBENEP: u32 = 0;
pub const XCHAL_HAVE_BSP3: u32 = 0;
pub const XCHAL_HAVE_BSP3_TRANSPOSE: u32 = 0;
pub const XCHAL_HAVE_SSP16: u32 = 0;
pub const XCHAL_HAVE_SSP16_VITERBI: u32 = 0;
pub const XCHAL_HAVE_TURBO16: u32 = 0;
pub const XCHAL_HAVE_BBP16: u32 = 0;
pub const XCHAL_HAVE_FLIX3: u32 = 0;
pub const XCHAL_HAVE_GRIVPEP: u32 = 0;
pub const XCHAL_HAVE_GRIVPEP_HISTOGRAM: u32 = 0;
pub const XCHAL_NUM_LOADSTORE_UNITS: u32 = 1;
pub const XCHAL_NUM_WRITEBUFFER_ENTRIES: u32 = 4;
pub const XCHAL_INST_FETCH_WIDTH: u32 = 4;
pub const XCHAL_DATA_WIDTH: u32 = 4;
pub const XCHAL_DATA_PIPE_DELAY: u32 = 2;
pub const XCHAL_CLOCK_GATING_GLOBAL: u32 = 1;
pub const XCHAL_CLOCK_GATING_FUNCUNIT: u32 = 1;
pub const XCHAL_UNALIGNED_LOAD_EXCEPTION: u32 = 0;
pub const XCHAL_UNALIGNED_STORE_EXCEPTION: u32 = 0;
pub const XCHAL_UNALIGNED_LOAD_HW: u32 = 1;
pub const XCHAL_UNALIGNED_STORE_HW: u32 = 1;
pub const XCHAL_SW_VERSION: u32 = 1100003;
pub const XCHAL_CORE_ID: &'static [u8; 17usize] = b"esp32_v3_49_prod\0";
pub const XCHAL_BUILD_UNIQUE_ID: u32 = 392854;
pub const XCHAL_HW_CONFIGID0: u32 = 3267166206;
pub const XCHAL_HW_CONFIGID1: u32 = 482737814;
pub const XCHAL_HW_VERSION_NAME: &'static [u8; 8usize] = b"LX6.0.3\0";
pub const XCHAL_HW_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_VERSION: u32 = 260003;
pub const XCHAL_HW_REL_LX6: u32 = 1;
pub const XCHAL_HW_REL_LX6_0: u32 = 1;
pub const XCHAL_HW_REL_LX6_0_3: u32 = 1;
pub const XCHAL_HW_CONFIGID_RELIABLE: u32 = 1;
pub const XCHAL_HW_MIN_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_MIN_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_MIN_VERSION: u32 = 260003;
pub const XCHAL_HW_MAX_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_MAX_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_MAX_VERSION: u32 = 260003;
pub const XCHAL_ICACHE_LINESIZE: u32 = 4;
pub const XCHAL_DCACHE_LINESIZE: u32 = 4;
pub const XCHAL_ICACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_DCACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_ICACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_IS_WRITEBACK: u32 = 0;
pub const XCHAL_DCACHE_IS_COHERENT: u32 = 0;
pub const XCHAL_HAVE_PREFETCH: u32 = 0;
pub const XCHAL_HAVE_PREFETCH_L1: u32 = 0;
pub const XCHAL_PREFETCH_CASTOUT_LINES: u32 = 0;
pub const XCHAL_PREFETCH_ENTRIES: u32 = 0;
pub const XCHAL_PREFETCH_BLOCK_ENTRIES: u32 = 0;
pub const XCHAL_HAVE_CACHE_BLOCKOPS: u32 = 0;
pub const XCHAL_HAVE_ICACHE_TEST: u32 = 0;
pub const XCHAL_HAVE_DCACHE_TEST: u32 = 0;
pub const XCHAL_HAVE_ICACHE_DYN_WAYS: u32 = 0;
pub const XCHAL_HAVE_DCACHE_DYN_WAYS: u32 = 0;
pub const XCHAL_HAVE_PIF: u32 = 1;
pub const XCHAL_HAVE_AXI: u32 = 0;
pub const XCHAL_HAVE_PIF_WR_RESP: u32 = 0;
pub const XCHAL_HAVE_PIF_REQ_ATTR: u32 = 0;
pub const XCHAL_ICACHE_SETWIDTH: u32 = 0;
pub const XCHAL_DCACHE_SETWIDTH: u32 = 0;
pub const XCHAL_ICACHE_WAYS: u32 = 1;
pub const XCHAL_DCACHE_WAYS: u32 = 1;
pub const XCHAL_ICACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_DCACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_ICACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_DCACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_ICACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_BANKS: u32 = 0;
pub const XCHAL_CA_BITS: u32 = 4;
pub const XCHAL_NUM_INSTROM: u32 = 1;
pub const XCHAL_NUM_INSTRAM: u32 = 2;
pub const XCHAL_NUM_DATAROM: u32 = 1;
pub const XCHAL_NUM_DATARAM: u32 = 2;
pub const XCHAL_NUM_URAM: u32 = 0;
pub const XCHAL_NUM_XLMI: u32 = 1;
pub const XCHAL_INSTROM0_VADDR: u32 = 1082130432;
pub const XCHAL_INSTROM0_PADDR: u32 = 1082130432;
pub const XCHAL_INSTROM0_SIZE: u32 = 4194304;
pub const XCHAL_INSTROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_SIZE: u32 = 4194304;
pub const XCHAL_INSTRAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM1_VADDR: u32 = 1077936128;
pub const XCHAL_INSTRAM1_PADDR: u32 = 1077936128;
pub const XCHAL_INSTRAM1_SIZE: u32 = 4194304;
pub const XCHAL_INSTRAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_VADDR: u32 = 1061158912;
pub const XCHAL_DATAROM0_PADDR: u32 = 1061158912;
pub const XCHAL_DATAROM0_SIZE: u32 = 4194304;
pub const XCHAL_DATAROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_BANKS: u32 = 1;
pub const XCHAL_DATARAM0_VADDR: u32 = 1073217536;
pub const XCHAL_DATARAM0_PADDR: u32 = 1073217536;
pub const XCHAL_DATARAM0_SIZE: u32 = 524288;
pub const XCHAL_DATARAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM0_BANKS: u32 = 1;
pub const XCHAL_DATARAM1_VADDR: u32 = 1065353216;
pub const XCHAL_DATARAM1_PADDR: u32 = 1065353216;
pub const XCHAL_DATARAM1_SIZE: u32 = 4194304;
pub const XCHAL_DATARAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM1_BANKS: u32 = 1;
pub const XCHAL_XLMI0_VADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_PADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_SIZE: u32 = 524288;
pub const XCHAL_XLMI0_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_IMEM_LOADSTORE: u32 = 1;
pub const XCHAL_HAVE_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_HIGHPRI_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_NMI: u32 = 1;
pub const XCHAL_HAVE_CCOUNT: u32 = 1;
pub const XCHAL_NUM_TIMERS: u32 = 3;
pub const XCHAL_NUM_INTERRUPTS: u32 = 32;
pub const XCHAL_NUM_INTERRUPTS_LOG2: u32 = 5;
pub const XCHAL_NUM_EXTINTERRUPTS: u32 = 26;
pub const XCHAL_NUM_INTLEVELS: u32 = 6;
pub const XCHAL_EXCM_LEVEL: u32 = 3;
pub const XCHAL_INTLEVEL1_MASK: u32 = 407551;
pub const XCHAL_INTLEVEL2_MASK: u32 = 3670016;
pub const XCHAL_INTLEVEL3_MASK: u32 = 683706368;
pub const XCHAL_INTLEVEL4_MASK: u32 = 1392508928;
pub const XCHAL_INTLEVEL5_MASK: u32 = 2214658048;
pub const XCHAL_INTLEVEL6_MASK: u32 = 0;
pub const XCHAL_INTLEVEL7_MASK: u32 = 16384;
pub const XCHAL_INTLEVEL1_ANDBELOW_MASK: u32 = 407551;
pub const XCHAL_INTLEVEL2_ANDBELOW_MASK: u32 = 4077567;
pub const XCHAL_INTLEVEL3_ANDBELOW_MASK: u32 = 687783935;
pub const XCHAL_INTLEVEL4_ANDBELOW_MASK: u32 = 2080292863;
pub const XCHAL_INTLEVEL5_ANDBELOW_MASK: u32 = 4294950911;
pub const XCHAL_INTLEVEL6_ANDBELOW_MASK: u32 = 4294950911;
pub const XCHAL_INTLEVEL7_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INT0_LEVEL: u32 = 1;
pub const XCHAL_INT1_LEVEL: u32 = 1;
pub const XCHAL_INT2_LEVEL: u32 = 1;
pub const XCHAL_INT3_LEVEL: u32 = 1;
pub const XCHAL_INT4_LEVEL: u32 = 1;
pub const XCHAL_INT5_LEVEL: u32 = 1;
pub const XCHAL_INT6_LEVEL: u32 = 1;
pub const XCHAL_INT7_LEVEL: u32 = 1;
pub const XCHAL_INT8_LEVEL: u32 = 1;
pub const XCHAL_INT9_LEVEL: u32 = 1;
pub const XCHAL_INT10_LEVEL: u32 = 1;
pub const XCHAL_INT11_LEVEL: u32 = 3;
pub const XCHAL_INT12_LEVEL: u32 = 1;
pub const XCHAL_INT13_LEVEL: u32 = 1;
pub const XCHAL_INT14_LEVEL: u32 = 7;
pub const XCHAL_INT15_LEVEL: u32 = 3;
pub const XCHAL_INT16_LEVEL: u32 = 5;
pub const XCHAL_INT17_LEVEL: u32 = 1;
pub const XCHAL_INT18_LEVEL: u32 = 1;
pub const XCHAL_INT19_LEVEL: u32 = 2;
pub const XCHAL_INT20_LEVEL: u32 = 2;
pub const XCHAL_INT21_LEVEL: u32 = 2;
pub const XCHAL_INT22_LEVEL: u32 = 3;
pub const XCHAL_INT23_LEVEL: u32 = 3;
pub const XCHAL_INT24_LEVEL: u32 = 4;
pub const XCHAL_INT25_LEVEL: u32 = 4;
pub const XCHAL_INT26_LEVEL: u32 = 5;
pub const XCHAL_INT27_LEVEL: u32 = 3;
pub const XCHAL_INT28_LEVEL: u32 = 4;
pub const XCHAL_INT29_LEVEL: u32 = 3;
pub const XCHAL_INT30_LEVEL: u32 = 4;
pub const XCHAL_INT31_LEVEL: u32 = 5;
pub const XCHAL_DEBUGLEVEL: u32 = 6;
pub const XCHAL_HAVE_DEBUG_EXTERN_INT: u32 = 1;
pub const XCHAL_NMILEVEL: u32 = 7;
pub const XCHAL_INTTYPE_MASK_UNCONFIGURED: u32 = 0;
pub const XCHAL_INTTYPE_MASK_SOFTWARE: u32 = 536871040;
pub const XCHAL_INTTYPE_MASK_EXTERN_EDGE: u32 = 1346372608;
pub const XCHAL_INTTYPE_MASK_EXTERN_LEVEL: u32 = 2411606847;
pub const XCHAL_INTTYPE_MASK_TIMER: u32 = 98368;
pub const XCHAL_INTTYPE_MASK_NMI: u32 = 16384;
pub const XCHAL_INTTYPE_MASK_WRITE_ERROR: u32 = 0;
pub const XCHAL_INTTYPE_MASK_PROFILING: u32 = 2048;
pub const XCHAL_TIMER0_INTERRUPT: u32 = 6;
pub const XCHAL_TIMER1_INTERRUPT: u32 = 15;
pub const XCHAL_TIMER2_INTERRUPT: u32 = 16;
pub const XCHAL_NMI_INTERRUPT: u32 = 14;
pub const XCHAL_PROFILING_INTERRUPT: u32 = 11;
pub const XCHAL_INTLEVEL7_NUM: u32 = 14;
pub const XCHAL_EXTINT0_NUM: u32 = 0;
pub const XCHAL_EXTINT1_NUM: u32 = 1;
pub const XCHAL_EXTINT2_NUM: u32 = 2;
pub const XCHAL_EXTINT3_NUM: u32 = 3;
pub const XCHAL_EXTINT4_NUM: u32 = 4;
pub const XCHAL_EXTINT5_NUM: u32 = 5;
pub const XCHAL_EXTINT6_NUM: u32 = 8;
pub const XCHAL_EXTINT7_NUM: u32 = 9;
pub const XCHAL_EXTINT8_NUM: u32 = 10;
pub const XCHAL_EXTINT9_NUM: u32 = 12;
pub const XCHAL_EXTINT10_NUM: u32 = 13;
pub const XCHAL_EXTINT11_NUM: u32 = 14;
pub const XCHAL_EXTINT12_NUM: u32 = 17;
pub const XCHAL_EXTINT13_NUM: u32 = 18;
pub const XCHAL_EXTINT14_NUM: u32 = 19;
pub const XCHAL_EXTINT15_NUM: u32 = 20;
pub const XCHAL_EXTINT16_NUM: u32 = 21;
pub const XCHAL_EXTINT17_NUM: u32 = 22;
pub const XCHAL_EXTINT18_NUM: u32 = 23;
pub const XCHAL_EXTINT19_NUM: u32 = 24;
pub const XCHAL_EXTINT20_NUM: u32 = 25;
pub const XCHAL_EXTINT21_NUM: u32 = 26;
pub const XCHAL_EXTINT22_NUM: u32 = 27;
pub const XCHAL_EXTINT23_NUM: u32 = 28;
pub const XCHAL_EXTINT24_NUM: u32 = 30;
pub const XCHAL_EXTINT25_NUM: u32 = 31;
pub const XCHAL_INT0_EXTNUM: u32 = 0;
pub const XCHAL_INT1_EXTNUM: u32 = 1;
pub const XCHAL_INT2_EXTNUM: u32 = 2;
pub const XCHAL_INT3_EXTNUM: u32 = 3;
pub const XCHAL_INT4_EXTNUM: u32 = 4;
pub const XCHAL_INT5_EXTNUM: u32 = 5;
pub const XCHAL_INT8_EXTNUM: u32 = 6;
pub const XCHAL_INT9_EXTNUM: u32 = 7;
pub const XCHAL_INT10_EXTNUM: u32 = 8;
pub const XCHAL_INT12_EXTNUM: u32 = 9;
pub const XCHAL_INT13_EXTNUM: u32 = 10;
pub const XCHAL_INT14_EXTNUM: u32 = 11;
pub const XCHAL_INT17_EXTNUM: u32 = 12;
pub const XCHAL_INT18_EXTNUM: u32 = 13;
pub const XCHAL_INT19_EXTNUM: u32 = 14;
pub const XCHAL_INT20_EXTNUM: u32 = 15;
pub const XCHAL_INT21_EXTNUM: u32 = 16;
pub const XCHAL_INT22_EXTNUM: u32 = 17;
pub const XCHAL_INT23_EXTNUM: u32 = 18;
pub const XCHAL_INT24_EXTNUM: u32 = 19;
pub const XCHAL_INT25_EXTNUM: u32 = 20;
pub const XCHAL_INT26_EXTNUM: u32 = 21;
pub const XCHAL_INT27_EXTNUM: u32 = 22;
pub const XCHAL_INT28_EXTNUM: u32 = 23;
pub const XCHAL_INT30_EXTNUM: u32 = 24;
pub const XCHAL_INT31_EXTNUM: u32 = 25;
pub const XCHAL_XEA_VERSION: u32 = 2;
pub const XCHAL_HAVE_XEA1: u32 = 0;
pub const XCHAL_HAVE_XEA2: u32 = 1;
pub const XCHAL_HAVE_XEAX: u32 = 0;
pub const XCHAL_HAVE_EXCEPTIONS: u32 = 1;
pub const XCHAL_HAVE_HALT: u32 = 0;
pub const XCHAL_HAVE_BOOTLOADER: u32 = 0;
pub const XCHAL_HAVE_MEM_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_VECTOR_SELECT: u32 = 1;
pub const XCHAL_HAVE_VECBASE: u32 = 1;
pub const XCHAL_VECBASE_RESET_VADDR: u32 = 1073741824;
pub const XCHAL_VECBASE_RESET_PADDR: u32 = 1073741824;
pub const XCHAL_RESET_VECBASE_OVERLAP: u32 = 0;
pub const XCHAL_RESET_VECTOR0_VADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR0_PADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR1_VADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR1_PADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR_VADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR_PADDR: u32 = 1073742848;
pub const XCHAL_USER_VECOFS: u32 = 832;
pub const XCHAL_USER_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_USER_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_KERNEL_VECOFS: u32 = 768;
pub const XCHAL_KERNEL_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_KERNEL_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_DOUBLEEXC_VECOFS: u32 = 960;
pub const XCHAL_DOUBLEEXC_VECTOR_VADDR: u32 = 1073742784;
pub const XCHAL_DOUBLEEXC_VECTOR_PADDR: u32 = 1073742784;
pub const XCHAL_WINDOW_OF4_VECOFS: u32 = 0;
pub const XCHAL_WINDOW_UF4_VECOFS: u32 = 64;
pub const XCHAL_WINDOW_OF8_VECOFS: u32 = 128;
pub const XCHAL_WINDOW_UF8_VECOFS: u32 = 192;
pub const XCHAL_WINDOW_OF12_VECOFS: u32 = 256;
pub const XCHAL_WINDOW_UF12_VECOFS: u32 = 320;
pub const XCHAL_WINDOW_VECTORS_VADDR: u32 = 1073741824;
pub const XCHAL_WINDOW_VECTORS_PADDR: u32 = 1073741824;
pub const XCHAL_INTLEVEL2_VECOFS: u32 = 384;
pub const XCHAL_INTLEVEL2_VECTOR_VADDR: u32 = 1073742208;
pub const XCHAL_INTLEVEL2_VECTOR_PADDR: u32 = 1073742208;
pub const XCHAL_INTLEVEL3_VECOFS: u32 = 448;
pub const XCHAL_INTLEVEL3_VECTOR_VADDR: u32 = 1073742272;
pub const XCHAL_INTLEVEL3_VECTOR_PADDR: u32 = 1073742272;
pub const XCHAL_INTLEVEL4_VECOFS: u32 = 512;
pub const XCHAL_INTLEVEL4_VECTOR_VADDR: u32 = 1073742336;
pub const XCHAL_INTLEVEL4_VECTOR_PADDR: u32 = 1073742336;
pub const XCHAL_INTLEVEL5_VECOFS: u32 = 576;
pub const XCHAL_INTLEVEL5_VECTOR_VADDR: u32 = 1073742400;
pub const XCHAL_INTLEVEL5_VECTOR_PADDR: u32 = 1073742400;
pub const XCHAL_INTLEVEL6_VECOFS: u32 = 640;
pub const XCHAL_INTLEVEL6_VECTOR_VADDR: u32 = 1073742464;
pub const XCHAL_INTLEVEL6_VECTOR_PADDR: u32 = 1073742464;
pub const XCHAL_DEBUG_VECOFS: u32 = 640;
pub const XCHAL_DEBUG_VECTOR_VADDR: u32 = 1073742464;
pub const XCHAL_DEBUG_VECTOR_PADDR: u32 = 1073742464;
pub const XCHAL_NMI_VECOFS: u32 = 704;
pub const XCHAL_NMI_VECTOR_VADDR: u32 = 1073742528;
pub const XCHAL_NMI_VECTOR_PADDR: u32 = 1073742528;
pub const XCHAL_INTLEVEL7_VECOFS: u32 = 704;
pub const XCHAL_INTLEVEL7_VECTOR_VADDR: u32 = 1073742528;
pub const XCHAL_INTLEVEL7_VECTOR_PADDR: u32 = 1073742528;
pub const XCHAL_HAVE_DEBUG_ERI: u32 = 1;
pub const XCHAL_HAVE_DEBUG_APB: u32 = 1;
pub const XCHAL_HAVE_DEBUG_JTAG: u32 = 1;
pub const XCHAL_HAVE_OCD: u32 = 1;
pub const XCHAL_NUM_IBREAK: u32 = 2;
pub const XCHAL_NUM_DBREAK: u32 = 2;
pub const XCHAL_HAVE_OCD_DIR_ARRAY: u32 = 0;
pub const XCHAL_HAVE_OCD_LS32DDR: u32 = 1;
pub const XCHAL_HAVE_TRAX: u32 = 1;
pub const XCHAL_TRAX_MEM_SIZE: u32 = 16384;
pub const XCHAL_TRAX_MEM_SHAREABLE: u32 = 1;
pub const XCHAL_TRAX_ATB_WIDTH: u32 = 32;
pub const XCHAL_TRAX_TIME_WIDTH: u32 = 0;
pub const XCHAL_NUM_PERF_COUNTERS: u32 = 2;
pub const XCHAL_HAVE_TLBS: u32 = 1;
pub const XCHAL_HAVE_SPANNING_WAY: u32 = 1;
pub const XCHAL_SPANNING_WAY: u32 = 0;
pub const XCHAL_HAVE_IDENTITY_MAP: u32 = 1;
pub const XCHAL_HAVE_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_MIMIC_CACHEATTR: u32 = 1;
pub const XCHAL_HAVE_XLT_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_PTP_MMU: u32 = 0;
pub const XCHAL_MMU_ASID_BITS: u32 = 0;
pub const XCHAL_MMU_RINGS: u32 = 1;
pub const XCHAL_MMU_RING_BITS: u32 = 0;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const ENOMSG: u32 = 35;
pub const EIDRM: u32 = 36;
pub const EDEADLK: u32 = 45;
pub const ENOLCK: u32 = 46;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENOLINK: u32 = 67;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 74;
pub const EBADMSG: u32 = 77;
pub const EFTYPE: u32 = 79;
pub const ENOSYS: u32 = 88;
pub const ENOTEMPTY: u32 = 90;
pub const ENAMETOOLONG: u32 = 91;
pub const ELOOP: u32 = 92;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EAFNOSUPPORT: u32 = 106;
pub const EPROTOTYPE: u32 = 107;
pub const ENOTSOCK: u32 = 108;
pub const ENOPROTOOPT: u32 = 109;
pub const ECONNREFUSED: u32 = 111;
pub const EADDRINUSE: u32 = 112;
pub const ECONNABORTED: u32 = 113;
pub const ENETUNREACH: u32 = 114;
pub const ENETDOWN: u32 = 115;
pub const ETIMEDOUT: u32 = 116;
pub const EHOSTDOWN: u32 = 117;
pub const EHOSTUNREACH: u32 = 118;
pub const EINPROGRESS: u32 = 119;
pub const EALREADY: u32 = 120;
pub const EDESTADDRREQ: u32 = 121;
pub const EMSGSIZE: u32 = 122;
pub const EPROTONOSUPPORT: u32 = 123;
pub const EADDRNOTAVAIL: u32 = 125;
pub const ENETRESET: u32 = 126;
pub const EISCONN: u32 = 127;
pub const ENOTCONN: u32 = 128;
pub const ETOOMANYREFS: u32 = 129;
pub const EDQUOT: u32 = 132;
pub const ESTALE: u32 = 133;
pub const ENOTSUP: u32 = 134;
pub const EILSEQ: u32 = 138;
pub const EOVERFLOW: u32 = 139;
pub const ECANCELED: u32 = 140;
pub const ENOTRECOVERABLE: u32 = 141;
pub const EOWNERDEAD: u32 = 142;
pub const EWOULDBLOCK: u32 = 11;
pub const __ELASTERROR: u32 = 2000;
pub const _M_LN2: f64 = 0.6931471805599453;
pub const FLT_EVAL_METHOD: u32 = 0;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_TWOPI: f64 = 6.283185307179586;
pub const M_SQRTPI: f64 = 1.772453850905516;
pub const M_SQRT3: f64 = 1.7320508075688772;
pub const M_IVLN10: f64 = 0.4342944819032518;
pub const M_LOG2_E: f64 = 0.6931471805599453;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __XSI_VISIBLE: u32 = 700;
pub const __BSD_VISIBLE: u32 = 1;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const _CLOCKS_PER_SEC_: u32 = 1000;
pub const CLOCKS_PER_SEC: u32 = 1000;
pub const CLK_TCK: u32 = 1000;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 3;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const F_OK: u32 = 0;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _SC_ARG_MAX: u32 = 0;
pub const _SC_CHILD_MAX: u32 = 1;
pub const _SC_CLK_TCK: u32 = 2;
pub const _SC_NGROUPS_MAX: u32 = 3;
pub const _SC_OPEN_MAX: u32 = 4;
pub const _SC_JOB_CONTROL: u32 = 5;
pub const _SC_SAVED_IDS: u32 = 6;
pub const _SC_VERSION: u32 = 7;
pub const _SC_PAGESIZE: u32 = 8;
pub const _SC_PAGE_SIZE: u32 = 8;
pub const _SC_NPROCESSORS_CONF: u32 = 9;
pub const _SC_NPROCESSORS_ONLN: u32 = 10;
pub const _SC_PHYS_PAGES: u32 = 11;
pub const _SC_AVPHYS_PAGES: u32 = 12;
pub const _SC_MQ_OPEN_MAX: u32 = 13;
pub const _SC_MQ_PRIO_MAX: u32 = 14;
pub const _SC_RTSIG_MAX: u32 = 15;
pub const _SC_SEM_NSEMS_MAX: u32 = 16;
pub const _SC_SEM_VALUE_MAX: u32 = 17;
pub const _SC_SIGQUEUE_MAX: u32 = 18;
pub const _SC_TIMER_MAX: u32 = 19;
pub const _SC_TZNAME_MAX: u32 = 20;
pub const _SC_ASYNCHRONOUS_IO: u32 = 21;
pub const _SC_FSYNC: u32 = 22;
pub const _SC_MAPPED_FILES: u32 = 23;
pub const _SC_MEMLOCK: u32 = 24;
pub const _SC_MEMLOCK_RANGE: u32 = 25;
pub const _SC_MEMORY_PROTECTION: u32 = 26;
pub const _SC_MESSAGE_PASSING: u32 = 27;
pub const _SC_PRIORITIZED_IO: u32 = 28;
pub const _SC_REALTIME_SIGNALS: u32 = 29;
pub const _SC_SEMAPHORES: u32 = 30;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 31;
pub const _SC_SYNCHRONIZED_IO: u32 = 32;
pub const _SC_TIMERS: u32 = 33;
pub const _SC_AIO_LISTIO_MAX: u32 = 34;
pub const _SC_AIO_MAX: u32 = 35;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 36;
pub const _SC_DELAYTIMER_MAX: u32 = 37;
pub const _SC_THREAD_KEYS_MAX: u32 = 38;
pub const _SC_THREAD_STACK_MIN: u32 = 39;
pub const _SC_THREAD_THREADS_MAX: u32 = 40;
pub const _SC_TTY_NAME_MAX: u32 = 41;
pub const _SC_THREADS: u32 = 42;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 43;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 44;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 45;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 46;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 47;
pub const _SC_THREAD_PRIO_CEILING: u32 = 47;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 48;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 49;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 50;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 51;
pub const _SC_LOGIN_NAME_MAX: u32 = 52;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 53;
pub const _SC_ADVISORY_INFO: u32 = 54;
pub const _SC_ATEXIT_MAX: u32 = 55;
pub const _SC_BARRIERS: u32 = 56;
pub const _SC_BC_BASE_MAX: u32 = 57;
pub const _SC_BC_DIM_MAX: u32 = 58;
pub const _SC_BC_SCALE_MAX: u32 = 59;
pub const _SC_BC_STRING_MAX: u32 = 60;
pub const _SC_CLOCK_SELECTION: u32 = 61;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 62;
pub const _SC_CPUTIME: u32 = 63;
pub const _SC_EXPR_NEST_MAX: u32 = 64;
pub const _SC_HOST_NAME_MAX: u32 = 65;
pub const _SC_IOV_MAX: u32 = 66;
pub const _SC_IPV6: u32 = 67;
pub const _SC_LINE_MAX: u32 = 68;
pub const _SC_MONOTONIC_CLOCK: u32 = 69;
pub const _SC_RAW_SOCKETS: u32 = 70;
pub const _SC_READER_WRITER_LOCKS: u32 = 71;
pub const _SC_REGEXP: u32 = 72;
pub const _SC_RE_DUP_MAX: u32 = 73;
pub const _SC_SHELL: u32 = 74;
pub const _SC_SPAWN: u32 = 75;
pub const _SC_SPIN_LOCKS: u32 = 76;
pub const _SC_SPORADIC_SERVER: u32 = 77;
pub const _SC_SS_REPL_MAX: u32 = 78;
pub const _SC_SYMLOOP_MAX: u32 = 79;
pub const _SC_THREAD_CPUTIME: u32 = 80;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 81;
pub const _SC_TIMEOUTS: u32 = 82;
pub const _SC_TRACE: u32 = 83;
pub const _SC_TRACE_EVENT_FILTER: u32 = 84;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 85;
pub const _SC_TRACE_INHERIT: u32 = 86;
pub const _SC_TRACE_LOG: u32 = 87;
pub const _SC_TRACE_NAME_MAX: u32 = 88;
pub const _SC_TRACE_SYS_MAX: u32 = 89;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 90;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 91;
pub const _SC_V7_ILP32_OFF32: u32 = 92;
pub const _SC_V6_ILP32_OFF32: u32 = 92;
pub const _SC_XBS5_ILP32_OFF32: u32 = 92;
pub const _SC_V7_ILP32_OFFBIG: u32 = 93;
pub const _SC_V6_ILP32_OFFBIG: u32 = 93;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 93;
pub const _SC_V7_LP64_OFF64: u32 = 94;
pub const _SC_V6_LP64_OFF64: u32 = 94;
pub const _SC_XBS5_LP64_OFF64: u32 = 94;
pub const _SC_V7_LPBIG_OFFBIG: u32 = 95;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XOPEN_CRYPT: u32 = 96;
pub const _SC_XOPEN_ENH_I18N: u32 = 97;
pub const _SC_XOPEN_LEGACY: u32 = 98;
pub const _SC_XOPEN_REALTIME: u32 = 99;
pub const _SC_STREAM_MAX: u32 = 100;
pub const _SC_PRIORITY_SCHEDULING: u32 = 101;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 102;
pub const _SC_XOPEN_SHM: u32 = 103;
pub const _SC_XOPEN_STREAMS: u32 = 104;
pub const _SC_XOPEN_UNIX: u32 = 105;
pub const _SC_XOPEN_VERSION: u32 = 106;
pub const _SC_2_CHAR_TERM: u32 = 107;
pub const _SC_2_C_BIND: u32 = 108;
pub const _SC_2_C_DEV: u32 = 109;
pub const _SC_2_FORT_DEV: u32 = 110;
pub const _SC_2_FORT_RUN: u32 = 111;
pub const _SC_2_LOCALEDEF: u32 = 112;
pub const _SC_2_PBS: u32 = 113;
pub const _SC_2_PBS_ACCOUNTING: u32 = 114;
pub const _SC_2_PBS_CHECKPOINT: u32 = 115;
pub const _SC_2_PBS_LOCATE: u32 = 116;
pub const _SC_2_PBS_MESSAGE: u32 = 117;
pub const _SC_2_PBS_TRACK: u32 = 118;
pub const _SC_2_SW_DEV: u32 = 119;
pub const _SC_2_UPE: u32 = 120;
pub const _SC_2_VERSION: u32 = 121;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: u32 = 122;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: u32 = 123;
pub const _SC_XOPEN_UUCP: u32 = 124;
pub const _PC_LINK_MAX: u32 = 0;
pub const _PC_MAX_CANON: u32 = 1;
pub const _PC_MAX_INPUT: u32 = 2;
pub const _PC_NAME_MAX: u32 = 3;
pub const _PC_PATH_MAX: u32 = 4;
pub const _PC_PIPE_BUF: u32 = 5;
pub const _PC_CHOWN_RESTRICTED: u32 = 6;
pub const _PC_NO_TRUNC: u32 = 7;
pub const _PC_VDISABLE: u32 = 8;
pub const _PC_ASYNC_IO: u32 = 9;
pub const _PC_PRIO_IO: u32 = 10;
pub const _PC_SYNC_IO: u32 = 11;
pub const _PC_FILESIZEBITS: u32 = 12;
pub const _PC_2_SYMLINKS: u32 = 13;
pub const _PC_SYMLINK_MAX: u32 = 14;
pub const _PC_ALLOC_SIZE_MIN: u32 = 15;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 16;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 17;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 18;
pub const _PC_REC_XFER_ALIGN: u32 = 19;
pub const _PC_TIMESTAMP_RESOLUTION: u32 = 20;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const _FOPEN: i32 = -1;
pub const _FREAD: u32 = 1;
pub const _FWRITE: u32 = 2;
pub const _FAPPEND: u32 = 8;
pub const _FMARK: u32 = 16;
pub const _FDEFER: u32 = 32;
pub const _FASYNC: u32 = 64;
pub const _FSHLOCK: u32 = 128;
pub const _FEXLOCK: u32 = 256;
pub const _FCREAT: u32 = 512;
pub const _FTRUNC: u32 = 1024;
pub const _FEXCL: u32 = 2048;
pub const _FNBIO: u32 = 4096;
pub const _FSYNC: u32 = 8192;
pub const _FNONBLOCK: u32 = 16384;
pub const _FNDELAY: u32 = 16384;
pub const _FNOCTTY: u32 = 32768;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_APPEND: u32 = 8;
pub const O_CREAT: u32 = 512;
pub const O_TRUNC: u32 = 1024;
pub const O_EXCL: u32 = 2048;
pub const O_SYNC: u32 = 8192;
pub const O_NONBLOCK: u32 = 16384;
pub const O_NOCTTY: u32 = 32768;
pub const FAPPEND: u32 = 8;
pub const FSYNC: u32 = 8192;
pub const FASYNC: u32 = 64;
pub const FNBIO: u32 = 4096;
pub const FNONBIO: u32 = 16384;
pub const FNDELAY: u32 = 16384;
pub const FREAD: u32 = 1;
pub const FWRITE: u32 = 2;
pub const FMARK: u32 = 16;
pub const FDEFER: u32 = 32;
pub const FSHLOCK: u32 = 128;
pub const FEXLOCK: u32 = 256;
pub const FOPEN: i32 = -1;
pub const FCREAT: u32 = 512;
pub const FTRUNC: u32 = 1024;
pub const FEXCL: u32 = 2048;
pub const FNOCTTY: u32 = 32768;
pub const FD_CLOEXEC: u32 = 1;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETOWN: u32 = 5;
pub const F_SETOWN: u32 = 6;
pub const F_GETLK: u32 = 7;
pub const F_SETLK: u32 = 8;
pub const F_SETLKW: u32 = 9;
pub const F_RGETLK: u32 = 10;
pub const F_RSETLK: u32 = 11;
pub const F_CNVT: u32 = 12;
pub const F_RSETLKW: u32 = 13;
pub const F_RDLCK: u32 = 1;
pub const F_WRLCK: u32 = 2;
pub const F_UNLCK: u32 = 3;
pub const F_UNLKSYS: u32 = 4;
pub const AT_FDCWD: i32 = -2;
pub const AT_EACCESS: u32 = 1;
pub const AT_SYMLINK_NOFOLLOW: u32 = 2;
pub const AT_SYMLINK_FOLLOW: u32 = 4;
pub const AT_REMOVEDIR: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const _IFMT: u32 = 61440;
pub const _IFDIR: u32 = 16384;
pub const _IFCHR: u32 = 8192;
pub const _IFBLK: u32 = 24576;
pub const _IFREG: u32 = 32768;
pub const _IFLNK: u32 = 40960;
pub const _IFSOCK: u32 = 49152;
pub const _IFIFO: u32 = 4096;
pub const S_BLKSIZE: u32 = 1024;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_ENFMT: u32 = 1024;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFIFO: u32 = 4096;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const DEFFILEMODE: u32 = 438;
pub const CONFIG_IDF_TARGET_ESP32: u32 = 1;
pub const CONFIG_IDF_CMAKE: u32 = 1;
pub const CONFIG_IDF_TARGET: &'static [u8; 6usize] = b"esp32\0";
pub const CONFIG_IDF_FIRMWARE_CHIP_ID: u32 = 0;
pub const CONFIG_SDK_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-esp32-elf-\0";
pub const CONFIG_APP_COMPILE_TIME_DATE: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL_INFO: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL: u32 = 3;
pub const CONFIG_BOOTLOADER_VDDSDIO_BOOST_1_9V: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_TIME_MS: u32 = 9000;
pub const CONFIG_ESPTOOLPY_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_ESPTOOLPY_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &'static [u8; 4usize] = b"dio\0";
pub const CONFIG_ESPTOOLPY_FLASHFREQ_40M: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &'static [u8; 4usize] = b"40m\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &'static [u8; 4usize] = b"2MB\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_DETECT: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &'static [u8; 14usize] = b"default_reset\0";
pub const CONFIG_ESPTOOLPY_AFTER_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER: &'static [u8; 11usize] = b"hard_reset\0";
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD_115200B: u32 = 1;
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &'static [u8; 15usize] = b"partitions.csv\0";
pub const CONFIG_PARTITION_TABLE_FILENAME: &'static [u8; 25usize] = b"partitions_singleapp.csv\0";
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_PARTITION_TABLE_MD5: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE: u32 = 1;
pub const CONFIG_COMPILER_STACK_CHECK_MODE_NONE: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_BTDM_CTRL_BR_EDR_SCO_DATA_PATH_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_BLE_MAX_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_BR_EDR_MAX_ACL_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_BR_EDR_MAX_SYNC_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_BTDM_BLE_SLEEP_CLOCK_ACCURACY_INDEX_EFF: u32 = 1;
pub const CONFIG_BT_RESERVE_DRAM: u32 = 0;
pub const CONFIG_ADC_DISABLE_DAC: u32 = 1;
pub const CONFIG_SPI_MASTER_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_SPI_SLAVE_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_EFUSE_CODE_SCHEME_COMPAT_3_4: u32 = 1;
pub const CONFIG_EFUSE_MAX_BLK_LEN: u32 = 192;
pub const CONFIG_ESP32_REV_MIN_0: u32 = 1;
pub const CONFIG_ESP32_REV_MIN: u32 = 0;
pub const CONFIG_ESP32_DPORT_WORKAROUND: u32 = 1;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_160: u32 = 1;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP32_TRACEMEM_RESERVE_DRAM: u32 = 0;
pub const CONFIG_ESP32_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP32_UNIVERSAL_MAC_ADDRESSES: u32 = 4;
pub const CONFIG_ESP32_ULP_COPROC_RESERVE_MEM: u32 = 0;
pub const CONFIG_ESP32_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP32_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP32_DEBUG_STUBS_ENABLE: u32 = 1;
pub const CONFIG_ESP32_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP32_BROWNOUT_DET_LVL_SEL_0: u32 = 1;
pub const CONFIG_ESP32_BROWNOUT_DET_LVL: u32 = 0;
pub const CONFIG_ESP32_REDUCE_PHY_TX_POWER: u32 = 1;
pub const CONFIG_ESP32_TIME_SYSCALL_USE_RTC_FRC1: u32 = 1;
pub const CONFIG_ESP32_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_ESP32_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_ESP32_DEEP_SLEEP_WAKEUP_DELAY: u32 = 2000;
pub const CONFIG_ESP32_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_ESP32_XTAL_FREQ: u32 = 40;
pub const CONFIG_ESP32_DPORT_DIS_INTERRUPT_LVL: u32 = 5;
pub const CONFIG_ADC_CAL_EFUSE_TP_ENABLE: u32 = 1;
pub const CONFIG_ADC_CAL_EFUSE_VREF_ENABLE: u32 = 1;
pub const CONFIG_ADC_CAL_LUT_ENABLE: u32 = 1;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_ESP_MAIN_TASK_STACK_SIZE: u32 = 16384;
pub const CONFIG_ESP_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_ESP_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_ESP_INT_WDT: u32 = 1;
pub const CONFIG_ESP_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_ESP_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_ESP_TASK_WDT: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1: u32 = 1;
pub const CONFIG_ETH_USE_ESP32_EMAC: u32 = 1;
pub const CONFIG_ETH_PHY_INTERFACE_RMII: u32 = 1;
pub const CONFIG_ETH_RMII_CLK_INPUT: u32 = 1;
pub const CONFIG_ETH_RMII_CLK_IN_GPIO: u32 = 0;
pub const CONFIG_ETH_DMA_BUFFER_SIZE: u32 = 512;
pub const CONFIG_ETH_DMA_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ETH_DMA_TX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ETH_USE_SPI_ETHERNET: u32 = 1;
pub const CONFIG_ETH_SPI_ETHERNET_DM9051: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_ISR: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 512;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_HTTPD_ERR_RESP_NO_DELAY: u32 = 1;
pub const CONFIG_HTTPD_PURGE_BUF_LEN: u32 = 32;
pub const CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP32_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_0: u32 = 1;
pub const CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP32_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE_437: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE: u32 = 437;
pub const CONFIG_FATFS_LFN_NONE: u32 = 1;
pub const CONFIG_FATFS_FS_LOCK: u32 = 0;
pub const CONFIG_FATFS_TIMEOUT_MS: u32 = 10000;
pub const CONFIG_FATFS_PER_FILE_CACHE: u32 = 1;
pub const CONFIG_FMB_MASTER_TIMEOUT_MS_RESPOND: u32 = 150;
pub const CONFIG_FMB_MASTER_DELAY_MS_CONVERT: u32 = 200;
pub const CONFIG_FMB_QUEUE_LENGTH: u32 = 20;
pub const CONFIG_FMB_SERIAL_TASK_STACK_SIZE: u32 = 2048;
pub const CONFIG_FMB_SERIAL_BUF_SIZE: u32 = 256;
pub const CONFIG_FMB_SERIAL_TASK_PRIO: u32 = 10;
pub const CONFIG_FMB_CONTROLLER_NOTIFY_TIMEOUT: u32 = 20;
pub const CONFIG_FMB_CONTROLLER_NOTIFY_QUEUE_SIZE: u32 = 20;
pub const CONFIG_FMB_CONTROLLER_STACK_SIZE: u32 = 4096;
pub const CONFIG_FMB_EVENT_QUEUE_TIMEOUT: u32 = 20;
pub const CONFIG_FMB_TIMER_PORT_ENABLED: u32 = 1;
pub const CONFIG_FMB_TIMER_GROUP: u32 = 0;
pub const CONFIG_FMB_TIMER_INDEX: u32 = 0;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_CORETIMER_0: u32 = 1;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_FREERTOS_ASSERT_ON_UNTESTED_FUNCTION: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY: u32 = 1;
pub const CONFIG_FREERTOS_INTERRUPT_BACKTRACE: u32 = 1;
pub const CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const CONFIG_FREERTOS_ASSERT_FAIL_ABORT: u32 = 1;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_MAX_TASK_NAME_LEN: u32 = 16;
pub const CONFIG_FREERTOS_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_FREERTOS_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE: u32 = 0;
pub const CONFIG_FREERTOS_TASK_FUNCTION_WRAPPER: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const CONFIG_HEAP_POISONING_DISABLED: u32 = 1;
pub const CONFIG_HEAP_TRACING_OFF: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_LOG_COLORS: u32 = 1;
pub const CONFIG_LWIP_LOCAL_HOSTNAME: &'static [u8; 10usize] = b"espressif\0";
pub const CONFIG_LWIP_TIMERS_ONDEMAND: u32 = 1;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_LWIP_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_LWIP_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_LWIP_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_LWIP_NETIF_LOOPBACK: u32 = 1;
pub const CONFIG_LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 16;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 16;
pub const CONFIG_LWIP_TCP_MAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_SYNMAXRTX: u32 = 6;
pub const CONFIG_LWIP_TCP_MSS: u32 = 1440;
pub const CONFIG_LWIP_TCP_MSL: u32 = 60000;
pub const CONFIG_LWIP_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_LWIP_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_LWIP_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_LWIP_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 16;
pub const CONFIG_LWIP_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 16;
pub const CONFIG_LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const CONFIG_LWIP_SNTP_UPDATE_DELAY: u32 = 3600000;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 4096;
pub const CONFIG_MBEDTLS_HARDWARE_AES: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_SHA: u32 = 1;
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_DHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_1: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_RC4_DISABLED: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_MDNS_MAX_SERVICES: u32 = 10;
pub const CONFIG_MQTT_PROTOCOL_311: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_SSL: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE: u32 = 1;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_NEWLIB_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_OPENSSL_ASSERT_EXIT: u32 = 1;
pub const CONFIG_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_PTHREAD_DEFAULT_CORE_NO_AFFINITY: u32 = 1;
pub const CONFIG_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_PTHREAD_TASK_NAME_DEFAULT: &'static [u8; 8usize] = b"pthread\0";
pub const CONFIG_SPI_FLASH_ROM_DRIVER_PATCH: u32 = 1;
pub const CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_GD_CHIP: u32 = 1;
pub const CONFIG_SPIFFS_MAX_PARTITIONS: u32 = 3;
pub const CONFIG_SPIFFS_CACHE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE_WR: u32 = 1;
pub const CONFIG_SPIFFS_PAGE_CHECK: u32 = 1;
pub const CONFIG_SPIFFS_GC_MAX_RUNS: u32 = 10;
pub const CONFIG_SPIFFS_PAGE_SIZE: u32 = 256;
pub const CONFIG_SPIFFS_OBJ_NAME_LEN: u32 = 32;
pub const CONFIG_SPIFFS_USE_MAGIC: u32 = 1;
pub const CONFIG_SPIFFS_USE_MAGIC_LENGTH: u32 = 1;
pub const CONFIG_SPIFFS_META_LENGTH: u32 = 4;
pub const CONFIG_SPIFFS_USE_MTIME: u32 = 1;
pub const CONFIG_NETIF_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_TCPIP_LWIP: u32 = 1;
pub const CONFIG_UNITY_ENABLE_FLOAT: u32 = 1;
pub const CONFIG_UNITY_ENABLE_DOUBLE: u32 = 1;
pub const CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER: u32 = 1;
pub const CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_VFS_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_SEMIHOSTFS_HOST_PATH_MAX_LEN: u32 = 128;
pub const CONFIG_WL_SECTOR_SIZE_4096: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE: u32 = 4096;
pub const CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES: u32 = 16;
pub const CONFIG_WPA_MBEDTLS_CRYPTO: u32 = 1;
pub const CONFIG_ADC2_DISABLE_DAC: u32 = 1;
pub const CONFIG_BROWNOUT_DET: u32 = 1;
pub const CONFIG_BROWNOUT_DET_LVL: u32 = 0;
pub const CONFIG_BROWNOUT_DET_LVL_SEL_0: u32 = 1;
pub const CONFIG_BTDM_CONTROLLER_BLE_MAX_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CONTROLLER_BR_EDR_MAX_ACL_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CONTROLLER_BR_EDR_MAX_SYNC_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CONTROLLER_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP32_DEFAULT_PTHREAD_CORE_NO_AFFINITY: u32 = 1;
pub const CONFIG_ESP32_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT: &'static [u8; 8usize] = b"pthread\0";
pub const CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_ESP32_RTC_CLOCK_SOURCE_INTERNAL_RC: u32 = 1;
pub const CONFIG_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_FOUR_UNIVERSAL_MAC_ADDRESS: u32 = 1;
pub const CONFIG_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_INT_WDT: u32 = 1;
pub const CONFIG_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 3;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 16384;
pub const CONFIG_MB_CONTROLLER_NOTIFY_QUEUE_SIZE: u32 = 20;
pub const CONFIG_MB_CONTROLLER_NOTIFY_TIMEOUT: u32 = 20;
pub const CONFIG_MB_CONTROLLER_STACK_SIZE: u32 = 4096;
pub const CONFIG_MB_EVENT_QUEUE_TIMEOUT: u32 = 20;
pub const CONFIG_MB_MASTER_DELAY_MS_CONVERT: u32 = 200;
pub const CONFIG_MB_MASTER_TIMEOUT_MS_RESPOND: u32 = 150;
pub const CONFIG_MB_QUEUE_LENGTH: u32 = 20;
pub const CONFIG_MB_SERIAL_BUF_SIZE: u32 = 256;
pub const CONFIG_MB_SERIAL_TASK_PRIO: u32 = 10;
pub const CONFIG_MB_SERIAL_TASK_STACK_SIZE: u32 = 2048;
pub const CONFIG_MB_TIMER_GROUP: u32 = 0;
pub const CONFIG_MB_TIMER_INDEX: u32 = 0;
pub const CONFIG_MB_TIMER_PORT_ENABLED: u32 = 1;
pub const CONFIG_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_MONITOR_BAUD_115200B: u32 = 1;
pub const CONFIG_MONITOR_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_NUMBER_OF_UNIVERSAL_MAC_ADDRESS: u32 = 4;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED: u32 = 1;
pub const CONFIG_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_ISR: u32 = 1;
pub const CONFIG_REDUCE_PHY_TX_POWER: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU1: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_TCP_MSL: u32 = 60000;
pub const CONFIG_TCP_MSS: u32 = 1440;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 6;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-esp32-elf-\0";
pub const CONFIG_TRACEMEM_RESERVE_DRAM: u32 = 0;
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_ULP_COPROC_RESERVE_MEM: u32 = 0;
pub const portNUM_PROCESSORS: u32 = 2;
pub const XT_USE_THREAD_SAFE_CLIB: u32 = 0;
pub const configASSERT_2: u32 = 0;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const configUSE_MUTEX: u32 = 1;
pub const XT_TIMER_INDEX: u32 = 0;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS: u32 = 1;
pub const XTHAL_RELEASE_MAJOR: u32 = 11000;
pub const XTHAL_RELEASE_MINOR: u32 = 3;
pub const XTHAL_RELEASE_NAME: &'static [u8; 7usize] = b"11.0.3\0";
pub const XTHAL_REL_11: u32 = 1;
pub const XTHAL_REL_11_0: u32 = 1;
pub const XTHAL_REL_11_0_3: u32 = 1;
pub const XTHAL_MAJOR_REV: u32 = 11000;
pub const XTHAL_MINOR_REV: u32 = 3;
pub const XTHAL_MAYBE: i32 = -1;
pub const XTHAL_MAX_CPS: u32 = 8;
pub const XTHAL_LITTLEENDIAN: u32 = 0;
pub const XTHAL_BIGENDIAN: u32 = 1;
pub const XTHAL_PREFETCH_ENABLE: i32 = -1;
pub const XTHAL_PREFETCH_DISABLE: u32 = 4294901760;
pub const XTHAL_DCACHE_PREFETCH_L1_OFF: u32 = 2415919104;
pub const XTHAL_DCACHE_PREFETCH_L1: u32 = 2415923200;
pub const XTHAL_ICACHE_PREFETCH_L1_OFF: u32 = 2684354560;
pub const XTHAL_ICACHE_PREFETCH_L1: u32 = 2684362752;
pub const XTHAL_DISASM_BUFSIZE: u32 = 80;
pub const XTHAL_DISASM_OPT_ADDR: u32 = 1;
pub const XTHAL_DISASM_OPT_OPHEX: u32 = 2;
pub const XTHAL_DISASM_OPT_OPCODE: u32 = 4;
pub const XTHAL_DISASM_OPT_PARMS: u32 = 8;
pub const XTHAL_DISASM_OPT_ALL: u32 = 4095;
pub const XTHAL_MAX_INTERRUPTS: u32 = 32;
pub const XTHAL_MAX_INTLEVELS: u32 = 16;
pub const XTHAL_MAX_TIMERS: u32 = 4;
pub const XTHAL_INTTYPE_UNCONFIGURED: u32 = 0;
pub const XTHAL_INTTYPE_SOFTWARE: u32 = 1;
pub const XTHAL_INTTYPE_EXTERN_EDGE: u32 = 2;
pub const XTHAL_INTTYPE_EXTERN_LEVEL: u32 = 3;
pub const XTHAL_INTTYPE_TIMER: u32 = 4;
pub const XTHAL_INTTYPE_NMI: u32 = 5;
pub const XTHAL_INTTYPE_WRITE_ERROR: u32 = 6;
pub const XTHAL_INTTYPE_PROFILING: u32 = 7;
pub const XTHAL_MAX_INTTYPES: u32 = 8;
pub const XTHAL_TIMER_UNCONFIGURED: i32 = -1;
pub const XTHAL_TIMER_UNASSIGNED: i32 = -1;
pub const XTHAL_MEMEP_PARITY: u32 = 1;
pub const XTHAL_MEMEP_ECC: u32 = 2;
pub const XTHAL_MEMEP_F_LOCAL: u32 = 0;
pub const XTHAL_MEMEP_F_DCACHE_DATA: u32 = 4;
pub const XTHAL_MEMEP_F_DCACHE_TAG: u32 = 5;
pub const XTHAL_MEMEP_F_ICACHE_DATA: u32 = 6;
pub const XTHAL_MEMEP_F_ICACHE_TAG: u32 = 7;
pub const XTHAL_MEMEP_F_CORRECTABLE: u32 = 16;
pub const XTHAL_AMB_EXCEPTION: u32 = 0;
pub const XTHAL_AMB_HITCACHE: u32 = 1;
pub const XTHAL_AMB_ALLOCATE: u32 = 2;
pub const XTHAL_AMB_WRITETHRU: u32 = 3;
pub const XTHAL_AMB_ISOLATE: u32 = 4;
pub const XTHAL_AMB_GUARD: u32 = 5;
pub const XTHAL_AMB_COHERENT: u32 = 6;
pub const XTHAL_AM_EXCEPTION: u32 = 1;
pub const XTHAL_AM_HITCACHE: u32 = 2;
pub const XTHAL_AM_ALLOCATE: u32 = 4;
pub const XTHAL_AM_WRITETHRU: u32 = 8;
pub const XTHAL_AM_ISOLATE: u32 = 16;
pub const XTHAL_AM_GUARD: u32 = 32;
pub const XTHAL_AM_COHERENT: u32 = 64;
pub const XTHAL_FAM_EXCEPTION: u32 = 1;
pub const XTHAL_FAM_BYPASS: u32 = 0;
pub const XTHAL_FAM_CACHED: u32 = 6;
pub const XTHAL_LAM_EXCEPTION: u32 = 1;
pub const XTHAL_LAM_ISOLATE: u32 = 18;
pub const XTHAL_LAM_BYPASS: u32 = 0;
pub const XTHAL_LAM_BYPASSG: u32 = 32;
pub const XTHAL_LAM_CACHED_NOALLOC: u32 = 2;
pub const XTHAL_LAM_NACACHED: u32 = 2;
pub const XTHAL_LAM_NACACHEDG: u32 = 34;
pub const XTHAL_LAM_CACHED: u32 = 6;
pub const XTHAL_LAM_COHCACHED: u32 = 70;
pub const XTHAL_SAM_EXCEPTION: u32 = 1;
pub const XTHAL_SAM_ISOLATE: u32 = 50;
pub const XTHAL_SAM_BYPASS: u32 = 40;
pub const XTHAL_SAM_WRITETHRU: u32 = 42;
pub const XTHAL_SAM_WRITEBACK: u32 = 38;
pub const XTHAL_SAM_WRITEBACK_NOALLOC: u32 = 34;
pub const XTHAL_SAM_COHWRITEBACK: u32 = 102;
pub const XTHAL_PAM_BYPASS: u32 = 0;
pub const XTHAL_PAM_BYPASS_BUF: u32 = 16;
pub const XTHAL_PAM_CACHED_NOALLOC: u32 = 48;
pub const XTHAL_PAM_WRITETHRU: u32 = 176;
pub const XTHAL_PAM_WRITEBACK_NOALLOC: u32 = 240;
pub const XTHAL_PAM_WRITEBACK: u32 = 496;
pub const XTHAL_CAFLAG_EXPAND: u32 = 256;
pub const XTHAL_CAFLAG_EXACT: u32 = 512;
pub const XTHAL_CAFLAG_NO_PARTIAL: u32 = 1024;
pub const XTHAL_CAFLAG_NO_AUTO_WB: u32 = 2048;
pub const XTHAL_CAFLAG_NO_AUTO_INV: u32 = 4096;
pub const XCHAL_SUCCESS: u32 = 0;
pub const XCHAL_ADDRESS_MISALIGNED: i32 = -1;
pub const XCHAL_INEXACT: i32 = -2;
pub const XCHAL_INVALID_ADDRESS: i32 = -3;
pub const XCHAL_UNSUPPORTED_ON_THIS_ARCH: i32 = -4;
pub const XCHAL_NO_PAGES_MAPPED: i32 = -5;
pub const XTHAL_NO_MAPPING: i32 = -6;
pub const XCHAL_CA_R: u32 = 1073742016;
pub const XCHAL_CA_RX: u32 = 1073742032;
pub const XCHAL_CA_RW: u32 = 1073742048;
pub const XCHAL_CA_RWX: u32 = 1073742064;
pub const XTENSA_HWVERSION_T1020_0: u32 = 102000;
pub const XTENSA_HWCIDSCHEME_T1020_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_0: u32 = 2;
pub const XTENSA_HWVERSION_T1020_1: u32 = 102001;
pub const XTENSA_HWCIDSCHEME_T1020_1: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_1: u32 = 3;
pub const XTENSA_HWVERSION_T1020_2B: u32 = 102002;
pub const XTENSA_HWCIDSCHEME_T1020_2B: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_2B: u32 = 5;
pub const XTENSA_HWVERSION_T1020_2: u32 = 102002;
pub const XTENSA_HWCIDSCHEME_T1020_2: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_2: u32 = 4;
pub const XTENSA_HWVERSION_T1020_3: u32 = 102003;
pub const XTENSA_HWCIDSCHEME_T1020_3: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_3: u32 = 6;
pub const XTENSA_HWVERSION_T1020_4: u32 = 102004;
pub const XTENSA_HWCIDSCHEME_T1020_4: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_4: u32 = 7;
pub const XTENSA_HWVERSION_T1030_0: u32 = 103000;
pub const XTENSA_HWCIDSCHEME_T1030_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_0: u32 = 9;
pub const XTENSA_HWVERSION_T1030_1: u32 = 103001;
pub const XTENSA_HWCIDSCHEME_T1030_1: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_1: u32 = 10;
pub const XTENSA_HWVERSION_T1030_2: u32 = 103002;
pub const XTENSA_HWCIDSCHEME_T1030_2: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_2: u32 = 11;
pub const XTENSA_HWVERSION_T1030_3: u32 = 103003;
pub const XTENSA_HWCIDSCHEME_T1030_3: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_3: u32 = 12;
pub const XTENSA_HWVERSION_T1040_0: u32 = 104000;
pub const XTENSA_HWCIDSCHEME_T1040_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1040_0: u32 = 15;
pub const XTENSA_HWVERSION_T1040_1: u32 = 104001;
pub const XTENSA_HWCIDSCHEME_T1040_1: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_1: u32 = 32;
pub const XTENSA_HWVERSION_T1040_1P: u32 = 104001;
pub const XTENSA_HWCIDSCHEME_T1040_1P: u32 = 10;
pub const XTENSA_HWCIDVERS_T1040_1P: u32 = 16;
pub const XTENSA_HWVERSION_T1040_2: u32 = 104002;
pub const XTENSA_HWCIDSCHEME_T1040_2: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_2: u32 = 33;
pub const XTENSA_HWVERSION_T1040_3: u32 = 104003;
pub const XTENSA_HWCIDSCHEME_T1040_3: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_3: u32 = 34;
pub const XTENSA_HWVERSION_T1050_0: u32 = 105000;
pub const XTENSA_HWCIDSCHEME_T1050_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_0: u32 = 1;
pub const XTENSA_HWVERSION_T1050_1: u32 = 105001;
pub const XTENSA_HWCIDSCHEME_T1050_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_1: u32 = 2;
pub const XTENSA_HWVERSION_T1050_2: u32 = 105002;
pub const XTENSA_HWCIDSCHEME_T1050_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_2: u32 = 4;
pub const XTENSA_HWVERSION_T1050_3: u32 = 105003;
pub const XTENSA_HWCIDSCHEME_T1050_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_3: u32 = 6;
pub const XTENSA_HWVERSION_T1050_4: u32 = 105004;
pub const XTENSA_HWCIDSCHEME_T1050_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_4: u32 = 7;
pub const XTENSA_HWVERSION_T1050_5: u32 = 105005;
pub const XTENSA_HWCIDSCHEME_T1050_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_5: u32 = 8;
pub const XTENSA_HWVERSION_RA_2004_1: u32 = 210000;
pub const XTENSA_HWCIDSCHEME_RA_2004_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2004_1: u32 = 3;
pub const XTENSA_HWVERSION_RA_2005_1: u32 = 210001;
pub const XTENSA_HWCIDSCHEME_RA_2005_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_1: u32 = 20;
pub const XTENSA_HWVERSION_RA_2005_2: u32 = 210002;
pub const XTENSA_HWCIDSCHEME_RA_2005_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_2: u32 = 21;
pub const XTENSA_HWVERSION_RA_2005_3: u32 = 210003;
pub const XTENSA_HWCIDSCHEME_RA_2005_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_3: u32 = 22;
pub const XTENSA_HWVERSION_RA_2006_4: u32 = 210004;
pub const XTENSA_HWCIDSCHEME_RA_2006_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_4: u32 = 23;
pub const XTENSA_HWVERSION_RA_2006_5: u32 = 210005;
pub const XTENSA_HWCIDSCHEME_RA_2006_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_5: u32 = 24;
pub const XTENSA_HWVERSION_RA_2006_6: u32 = 210006;
pub const XTENSA_HWCIDSCHEME_RA_2006_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_6: u32 = 25;
pub const XTENSA_HWVERSION_RA_2007_7: u32 = 210007;
pub const XTENSA_HWCIDSCHEME_RA_2007_7: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2007_7: u32 = 26;
pub const XTENSA_HWVERSION_RA_2008_8: u32 = 210008;
pub const XTENSA_HWCIDSCHEME_RA_2008_8: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2008_8: u32 = 27;
pub const XTENSA_HWVERSION_RB_2006_0: u32 = 220000;
pub const XTENSA_HWCIDSCHEME_RB_2006_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2006_0: u32 = 48;
pub const XTENSA_HWVERSION_RB_2007_1: u32 = 220001;
pub const XTENSA_HWCIDSCHEME_RB_2007_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_1: u32 = 49;
pub const XTENSA_HWVERSION_RB_2007_2: u32 = 221000;
pub const XTENSA_HWCIDSCHEME_RB_2007_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_2: u32 = 52;
pub const XTENSA_HWVERSION_RB_2008_3: u32 = 221001;
pub const XTENSA_HWCIDSCHEME_RB_2008_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2008_3: u32 = 53;
pub const XTENSA_HWVERSION_RB_2008_4: u32 = 221002;
pub const XTENSA_HWCIDSCHEME_RB_2008_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2008_4: u32 = 54;
pub const XTENSA_HWVERSION_RB_2009_5: u32 = 221003;
pub const XTENSA_HWCIDSCHEME_RB_2009_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2009_5: u32 = 55;
pub const XTENSA_HWVERSION_RB_2007_2_MP: u32 = 221100;
pub const XTENSA_HWCIDSCHEME_RB_2007_2_MP: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_2_MP: u32 = 64;
pub const XTENSA_HWVERSION_RC_2009_0: u32 = 230000;
pub const XTENSA_HWCIDSCHEME_RC_2009_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2009_0: u32 = 65;
pub const XTENSA_HWVERSION_RC_2010_1: u32 = 230001;
pub const XTENSA_HWCIDSCHEME_RC_2010_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2010_1: u32 = 66;
pub const XTENSA_HWVERSION_RC_2010_2: u32 = 230002;
pub const XTENSA_HWCIDSCHEME_RC_2010_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2010_2: u32 = 67;
pub const XTENSA_HWVERSION_RC_2011_3: u32 = 230003;
pub const XTENSA_HWCIDSCHEME_RC_2011_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2011_3: u32 = 68;
pub const XTENSA_HWVERSION_RD_2010_0: u32 = 240000;
pub const XTENSA_HWCIDSCHEME_RD_2010_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2010_0: u32 = 80;
pub const XTENSA_HWVERSION_RD_2011_1: u32 = 240001;
pub const XTENSA_HWCIDSCHEME_RD_2011_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_1: u32 = 81;
pub const XTENSA_HWVERSION_RD_2011_2: u32 = 240002;
pub const XTENSA_HWCIDSCHEME_RD_2011_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_2: u32 = 82;
pub const XTENSA_HWVERSION_RD_2011_3: u32 = 240003;
pub const XTENSA_HWCIDSCHEME_RD_2011_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_3: u32 = 83;
pub const XTENSA_HWVERSION_RD_2012_4: u32 = 240004;
pub const XTENSA_HWCIDSCHEME_RD_2012_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2012_4: u32 = 84;
pub const XTENSA_HWVERSION_RD_2012_5: u32 = 240005;
pub const XTENSA_HWCIDSCHEME_RD_2012_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2012_5: u32 = 85;
pub const XTENSA_HWVERSION_RE_2012_0: u32 = 250000;
pub const XTENSA_HWCIDSCHEME_RE_2012_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2012_0: u32 = 96;
pub const XTENSA_HWVERSION_RE_2012_1: u32 = 250001;
pub const XTENSA_HWCIDSCHEME_RE_2012_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2012_1: u32 = 97;
pub const XTENSA_HWVERSION_RE_2013_2: u32 = 250002;
pub const XTENSA_HWCIDSCHEME_RE_2013_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_2: u32 = 98;
pub const XTENSA_HWVERSION_RE_2013_3: u32 = 250003;
pub const XTENSA_HWCIDSCHEME_RE_2013_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_3: u32 = 99;
pub const XTENSA_HWVERSION_RE_2013_4: u32 = 250004;
pub const XTENSA_HWCIDSCHEME_RE_2013_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_4: u32 = 100;
pub const XTENSA_HWVERSION_RE_2014_5: u32 = 250005;
pub const XTENSA_HWCIDSCHEME_RE_2014_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2014_5: u32 = 101;
pub const XTENSA_HWVERSION_RE_2015_6: u32 = 250006;
pub const XTENSA_HWCIDSCHEME_RE_2015_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2015_6: u32 = 102;
pub const XTENSA_HWVERSION_RF_2014_0: u32 = 260000;
pub const XTENSA_HWCIDSCHEME_RF_2014_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2014_0: u32 = 112;
pub const XTENSA_HWVERSION_RF_2014_1: u32 = 260001;
pub const XTENSA_HWCIDSCHEME_RF_2014_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2014_1: u32 = 113;
pub const XTENSA_HWVERSION_RF_2015_2: u32 = 260002;
pub const XTENSA_HWCIDSCHEME_RF_2015_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2015_2: u32 = 114;
pub const XTENSA_HWVERSION_RF_2015_3: u32 = 260003;
pub const XTENSA_HWCIDSCHEME_RF_2015_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2015_3: u32 = 115;
pub const XTENSA_HWVERSION_RG_2015_0: u32 = 270000;
pub const XTENSA_HWCIDSCHEME_RG_2015_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2015_0: u32 = 128;
pub const XTENSA_SWVERSION_T1020_0: u32 = 102000;
pub const XTENSA_SWVERSION_T1020_1: u32 = 102001;
pub const XTENSA_SWVERSION_T1020_2B: u32 = 102002;
pub const XTENSA_SWVERSION_T1020_2: u32 = 102002;
pub const XTENSA_SWVERSION_T1020_3: u32 = 102003;
pub const XTENSA_SWVERSION_T1020_4: u32 = 102004;
pub const XTENSA_SWVERSION_T1030_0: u32 = 103000;
pub const XTENSA_SWVERSION_T1030_1: u32 = 103001;
pub const XTENSA_SWVERSION_T1030_2: u32 = 103002;
pub const XTENSA_SWVERSION_T1030_3: u32 = 103003;
pub const XTENSA_SWVERSION_T1040_0: u32 = 104000;
pub const XTENSA_SWVERSION_T1040_1: u32 = 104001;
pub const XTENSA_SWVERSION_T1040_1P: u32 = 104001;
pub const XTENSA_SWVERSION_T1040_2: u32 = 104002;
pub const XTENSA_SWVERSION_T1040_3: u32 = 104003;
pub const XTENSA_SWVERSION_T1050_0: u32 = 105000;
pub const XTENSA_SWVERSION_T1050_1: u32 = 105001;
pub const XTENSA_SWVERSION_T1050_2: u32 = 105002;
pub const XTENSA_SWVERSION_T1050_3: u32 = 105003;
pub const XTENSA_SWVERSION_T1050_4: u32 = 105004;
pub const XTENSA_SWVERSION_T1050_5: u32 = 105005;
pub const XTENSA_SWVERSION_RA_2004_1: u32 = 600000;
pub const XTENSA_SWVERSION_RA_2005_1: u32 = 600001;
pub const XTENSA_SWVERSION_RA_2005_2: u32 = 600002;
pub const XTENSA_SWVERSION_RA_2005_3: u32 = 600003;
pub const XTENSA_SWVERSION_RA_2006_4: u32 = 600004;
pub const XTENSA_SWVERSION_RA_2006_5: u32 = 600005;
pub const XTENSA_SWVERSION_RA_2006_6: u32 = 600006;
pub const XTENSA_SWVERSION_RA_2007_7: u32 = 600007;
pub const XTENSA_SWVERSION_RA_2008_8: u32 = 600008;
pub const XTENSA_SWVERSION_RB_2006_0: u32 = 700000;
pub const XTENSA_SWVERSION_RB_2007_1: u32 = 700001;
pub const XTENSA_SWVERSION_RB_2007_2: u32 = 701000;
pub const XTENSA_SWVERSION_RB_2008_3: u32 = 701001;
pub const XTENSA_SWVERSION_RB_2008_4: u32 = 701002;
pub const XTENSA_SWVERSION_RB_2009_5: u32 = 701003;
pub const XTENSA_SWVERSION_RB_2007_2_MP: u32 = 701100;
pub const XTENSA_SWVERSION_RC_2009_0: u32 = 800000;
pub const XTENSA_SWVERSION_RC_2010_1: u32 = 800001;
pub const XTENSA_SWVERSION_RC_2010_2: u32 = 800002;
pub const XTENSA_SWVERSION_RC_2011_3: u32 = 800003;
pub const XTENSA_SWVERSION_RD_2010_0: u32 = 900000;
pub const XTENSA_SWVERSION_RD_2011_1: u32 = 900001;
pub const XTENSA_SWVERSION_RD_2011_2: u32 = 900002;
pub const XTENSA_SWVERSION_RD_2011_3: u32 = 900003;
pub const XTENSA_SWVERSION_RD_2012_4: u32 = 900004;
pub const XTENSA_SWVERSION_RD_2012_5: u32 = 900005;
pub const XTENSA_SWVERSION_RE_2012_0: u32 = 1000000;
pub const XTENSA_SWVERSION_RE_2012_1: u32 = 1000001;
pub const XTENSA_SWVERSION_RE_2013_2: u32 = 1000002;
pub const XTENSA_SWVERSION_RE_2013_3: u32 = 1000003;
pub const XTENSA_SWVERSION_RE_2013_4: u32 = 1000004;
pub const XTENSA_SWVERSION_RE_2014_5: u32 = 1000005;
pub const XTENSA_SWVERSION_RE_2015_6: u32 = 1000006;
pub const XTENSA_SWVERSION_RF_2014_0: u32 = 1100000;
pub const XTENSA_SWVERSION_RF_2014_1: u32 = 1100001;
pub const XTENSA_SWVERSION_RF_2015_2: u32 = 1100002;
pub const XTENSA_SWVERSION_RF_2015_3: u32 = 1100003;
pub const XTENSA_SWVERSION_RG_2015_0: u32 = 1200000;
pub const XTENSA_SWVERSION_T1040_1_PREHOTFIX: u32 = 104001;
pub const XTENSA_SWVERSION_6_0_0: u32 = 600000;
pub const XTENSA_SWVERSION_6_0_1: u32 = 600001;
pub const XTENSA_SWVERSION_6_0_2: u32 = 600002;
pub const XTENSA_SWVERSION_6_0_3: u32 = 600003;
pub const XTENSA_SWVERSION_6_0_4: u32 = 600004;
pub const XTENSA_SWVERSION_6_0_5: u32 = 600005;
pub const XTENSA_SWVERSION_6_0_6: u32 = 600006;
pub const XTENSA_SWVERSION_6_0_7: u32 = 600007;
pub const XTENSA_SWVERSION_6_0_8: u32 = 600008;
pub const XTENSA_SWVERSION_7_0_0: u32 = 700000;
pub const XTENSA_SWVERSION_7_0_1: u32 = 700001;
pub const XTENSA_SWVERSION_7_1_0: u32 = 701000;
pub const XTENSA_SWVERSION_7_1_1: u32 = 701001;
pub const XTENSA_SWVERSION_7_1_2: u32 = 701002;
pub const XTENSA_SWVERSION_7_1_3: u32 = 701003;
pub const XTENSA_SWVERSION_7_1_8_MP: u32 = 701100;
pub const XTENSA_SWVERSION_8_0_0: u32 = 800000;
pub const XTENSA_SWVERSION_8_0_1: u32 = 800001;
pub const XTENSA_SWVERSION_8_0_2: u32 = 800002;
pub const XTENSA_SWVERSION_8_0_3: u32 = 800003;
pub const XTENSA_SWVERSION_9_0_0: u32 = 900000;
pub const XTENSA_SWVERSION_9_0_1: u32 = 900001;
pub const XTENSA_SWVERSION_9_0_2: u32 = 900002;
pub const XTENSA_SWVERSION_9_0_3: u32 = 900003;
pub const XTENSA_SWVERSION_9_0_4: u32 = 900004;
pub const XTENSA_SWVERSION_9_0_5: u32 = 900005;
pub const XTENSA_SWVERSION_10_0_0: u32 = 1000000;
pub const XTENSA_SWVERSION_10_0_1: u32 = 1000001;
pub const XTENSA_SWVERSION_10_0_2: u32 = 1000002;
pub const XTENSA_SWVERSION_10_0_3: u32 = 1000003;
pub const XTENSA_SWVERSION_10_0_4: u32 = 1000004;
pub const XTENSA_SWVERSION_10_0_5: u32 = 1000005;
pub const XTENSA_SWVERSION_10_0_6: u32 = 1000006;
pub const XTENSA_SWVERSION_11_0_0: u32 = 1100000;
pub const XTENSA_SWVERSION_11_0_1: u32 = 1100001;
pub const XTENSA_SWVERSION_11_0_2: u32 = 1100002;
pub const XTENSA_SWVERSION_11_0_3: u32 = 1100003;
pub const XTENSA_SWVERSION_12_0_0: u32 = 1200000;
pub const XTENSA_RELEASE_NAME: &'static [u8; 10usize] = b"RF-2015.3\0";
pub const XTENSA_RELEASE_CANONICAL_NAME: &'static [u8; 10usize] = b"RF-2015.3\0";
pub const XTENSA_SWVERSION: u32 = 1100003;
pub const XTENSA_SWVERSION_NAME: &'static [u8; 7usize] = b"11.0.3\0";
pub const XTENSA_SWVERSION_CANONICAL_NAME: &'static [u8; 7usize] = b"11.0.3\0";
pub const XTENSA_SWVERSION_MAJORMID_NAME: &'static [u8; 5usize] = b"11.0\0";
pub const XTENSA_SWVERSION_MAJOR_NAME: &'static [u8; 3usize] = b"11\0";
pub const XTENSA_SWVERSION_LICENSE_NAME: &'static [u8; 5usize] = b"11.0\0";
pub const XCHAL_CA_BYPASS: u32 = 2;
pub const XCHAL_CA_BYPASSBUF: u32 = 6;
pub const XCHAL_CA_WRITETHRU: u32 = 2;
pub const XCHAL_CA_WRITEBACK: u32 = 2;
pub const XCHAL_HAVE_CA_WRITEBACK_NOALLOC: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC: u32 = 2;
pub const XCHAL_CA_BYPASS_RW: u32 = 0;
pub const XCHAL_CA_WRITETHRU_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC_RW: u32 = 0;
pub const XCHAL_CA_ILLEGAL: u32 = 15;
pub const XCHAL_CA_ISOLATE: u32 = 0;
pub const XCHAL_MMU_ASID_INVALID: u32 = 0;
pub const XCHAL_MMU_ASID_KERNEL: u32 = 0;
pub const XCHAL_MMU_SR_BITS: u32 = 0;
pub const XCHAL_MMU_CA_BITS: u32 = 4;
pub const XCHAL_MMU_MAX_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_MMU_MIN_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_ITLB_WAY_BITS: u32 = 0;
pub const XCHAL_ITLB_WAYS: u32 = 1;
pub const XCHAL_ITLB_ARF_WAYS: u32 = 0;
pub const XCHAL_ITLB_SETS: u32 = 1;
pub const XCHAL_ITLB_WAY0_SET: u32 = 0;
pub const XCHAL_ITLB_ARF_SETS: u32 = 0;
pub const XCHAL_ITLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_ITLB_SET0_WAY: u32 = 0;
pub const XCHAL_ITLB_SET0_WAYS: u32 = 1;
pub const XCHAL_ITLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_ITLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_ITLB_SET0_ARF: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_ITLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_ITLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_ITLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_WAY_BITS: u32 = 0;
pub const XCHAL_DTLB_WAYS: u32 = 1;
pub const XCHAL_DTLB_ARF_WAYS: u32 = 0;
pub const XCHAL_DTLB_SETS: u32 = 1;
pub const XCHAL_DTLB_WAY0_SET: u32 = 0;
pub const XCHAL_DTLB_ARF_SETS: u32 = 0;
pub const XCHAL_DTLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_DTLB_SET0_WAY: u32 = 0;
pub const XCHAL_DTLB_SET0_WAYS: u32 = 1;
pub const XCHAL_DTLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_DTLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_DTLB_SET0_ARF: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_DTLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_DTLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_DTLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_CP_NUM: u32 = 1;
pub const XCHAL_CP_MAX: u32 = 1;
pub const XCHAL_CP_MASK: u32 = 1;
pub const XCHAL_CP_PORT_MASK: u32 = 0;
pub const XCHAL_CP0_NAME: &'static [u8; 4usize] = b"FPU\0";
pub const XCHAL_CP0_SA_SIZE: u32 = 72;
pub const XCHAL_CP0_SA_ALIGN: u32 = 4;
pub const XCHAL_CP_ID_FPU: u32 = 0;
pub const XCHAL_CP1_SA_SIZE: u32 = 0;
pub const XCHAL_CP1_SA_ALIGN: u32 = 1;
pub const XCHAL_CP2_SA_SIZE: u32 = 0;
pub const XCHAL_CP2_SA_ALIGN: u32 = 1;
pub const XCHAL_CP3_SA_SIZE: u32 = 0;
pub const XCHAL_CP3_SA_ALIGN: u32 = 1;
pub const XCHAL_CP4_SA_SIZE: u32 = 0;
pub const XCHAL_CP4_SA_ALIGN: u32 = 1;
pub const XCHAL_CP5_SA_SIZE: u32 = 0;
pub const XCHAL_CP5_SA_ALIGN: u32 = 1;
pub const XCHAL_CP6_SA_SIZE: u32 = 0;
pub const XCHAL_CP6_SA_ALIGN: u32 = 1;
pub const XCHAL_CP7_SA_SIZE: u32 = 0;
pub const XCHAL_CP7_SA_ALIGN: u32 = 1;
pub const XCHAL_NCP_SA_SIZE: u32 = 48;
pub const XCHAL_NCP_SA_ALIGN: u32 = 4;
pub const XCHAL_TOTAL_SA_SIZE: u32 = 128;
pub const XCHAL_TOTAL_SA_ALIGN: u32 = 4;
pub const XCHAL_NCP_SA_NUM: u32 = 12;
pub const XCHAL_CP0_SA_NUM: u32 = 18;
pub const XCHAL_CP1_SA_NUM: u32 = 0;
pub const XCHAL_CP2_SA_NUM: u32 = 0;
pub const XCHAL_CP3_SA_NUM: u32 = 0;
pub const XCHAL_CP4_SA_NUM: u32 = 0;
pub const XCHAL_CP5_SA_NUM: u32 = 0;
pub const XCHAL_CP6_SA_NUM: u32 = 0;
pub const XCHAL_CP7_SA_NUM: u32 = 0;
pub const XCHAL_HAVE_LE: u32 = 1;
pub const XCHAL_MEMORY_ORDER: u32 = 0;
pub const XCHAL_HAVE_HIGHLEVEL_INTERRUPTS: u32 = 1;
pub const XCHAL_NUM_LOWPRI_LEVELS: u32 = 1;
pub const XCHAL_FIRST_HIGHPRI_LEVEL: u32 = 2;
pub const XCHAL_INTLEVEL0_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_MASK: u32 = 0;
pub const XCHAL_INTLEVEL9_MASK: u32 = 0;
pub const XCHAL_INTLEVEL10_MASK: u32 = 0;
pub const XCHAL_INTLEVEL11_MASK: u32 = 0;
pub const XCHAL_INTLEVEL12_MASK: u32 = 0;
pub const XCHAL_INTLEVEL13_MASK: u32 = 0;
pub const XCHAL_INTLEVEL14_MASK: u32 = 0;
pub const XCHAL_INTLEVEL15_MASK: u32 = 0;
pub const XCHAL_INTLEVEL0_ANDBELOW_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL9_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL10_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL11_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL12_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL13_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL14_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL15_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_LOWPRI_MASK: u32 = 407551;
pub const XCHAL_INTCLEARABLE_MASK: u32 = 1883243648;
pub const XCHAL_INTSETTABLE_MASK: u32 = 536871040;
pub const XCHAL_EXTINT0_MASK: u32 = 1;
pub const XCHAL_EXTINT1_MASK: u32 = 2;
pub const XCHAL_EXTINT2_MASK: u32 = 4;
pub const XCHAL_EXTINT3_MASK: u32 = 8;
pub const XCHAL_EXTINT4_MASK: u32 = 16;
pub const XCHAL_EXTINT5_MASK: u32 = 32;
pub const XCHAL_EXTINT6_MASK: u32 = 256;
pub const XCHAL_EXTINT7_MASK: u32 = 512;
pub const XCHAL_EXTINT8_MASK: u32 = 1024;
pub const XCHAL_EXTINT9_MASK: u32 = 4096;
pub const XCHAL_EXTINT10_MASK: u32 = 8192;
pub const XCHAL_EXTINT11_MASK: u32 = 16384;
pub const XCHAL_EXTINT12_MASK: u32 = 131072;
pub const XCHAL_EXTINT13_MASK: u32 = 262144;
pub const XCHAL_EXTINT14_MASK: u32 = 524288;
pub const XCHAL_EXTINT15_MASK: u32 = 1048576;
pub const XCHAL_EXTINT16_MASK: u32 = 2097152;
pub const XCHAL_EXTINT17_MASK: u32 = 4194304;
pub const XCHAL_EXTINT18_MASK: u32 = 8388608;
pub const XCHAL_EXTINT19_MASK: u32 = 16777216;
pub const XCHAL_EXTINT20_MASK: u32 = 33554432;
pub const XCHAL_EXTINT21_MASK: u32 = 67108864;
pub const XCHAL_EXTINT22_MASK: u32 = 134217728;
pub const XCHAL_EXTINT23_MASK: u32 = 268435456;
pub const XCHAL_EXTINT24_MASK: u32 = 1073741824;
pub const XCHAL_EXTINT25_MASK: u32 = 2147483648;
pub const XCHAL_HAVE_OLD_EXC_ARCH: u32 = 0;
pub const XCHAL_HAVE_EXCM: u32 = 1;
pub const XCHAL_PROGRAMEXC_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_USEREXC_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_PROGRAMEXC_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_USEREXC_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_STACKEDEXC_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_KERNELEXC_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_STACKEDEXC_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_KERNELEXC_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_EXCCAUSE_ILLEGAL_INSTRUCTION: u32 = 0;
pub const XCHAL_EXCCAUSE_SYSTEM_CALL: u32 = 1;
pub const XCHAL_EXCCAUSE_INSTRUCTION_FETCH_ERROR: u32 = 2;
pub const XCHAL_EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const XCHAL_EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const XCHAL_EXCCAUSE_ALLOCA: u32 = 5;
pub const XCHAL_EXCCAUSE_INTEGER_DIVIDE_BY_ZERO: u32 = 6;
pub const XCHAL_EXCCAUSE_SPECULATION: u32 = 7;
pub const XCHAL_EXCCAUSE_PRIVILEGED: u32 = 8;
pub const XCHAL_EXCCAUSE_UNALIGNED: u32 = 9;
pub const XCHAL_EXCCAUSE_ITLB_MISS: u32 = 16;
pub const XCHAL_EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const XCHAL_EXCCAUSE_ITLB_PRIVILEGE: u32 = 18;
pub const XCHAL_EXCCAUSE_ITLB_SIZE_RESTRICTION: u32 = 19;
pub const XCHAL_EXCCAUSE_FETCH_CACHE_ATTRIBUTE: u32 = 20;
pub const XCHAL_EXCCAUSE_DTLB_MISS: u32 = 24;
pub const XCHAL_EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const XCHAL_EXCCAUSE_DTLB_PRIVILEGE: u32 = 26;
pub const XCHAL_EXCCAUSE_DTLB_SIZE_RESTRICTION: u32 = 27;
pub const XCHAL_EXCCAUSE_LOAD_CACHE_ATTRIBUTE: u32 = 28;
pub const XCHAL_EXCCAUSE_STORE_CACHE_ATTRIBUTE: u32 = 29;
pub const XCHAL_EXCCAUSE_COPROCESSOR0_DISABLED: u32 = 32;
pub const XCHAL_EXCCAUSE_COPROCESSOR1_DISABLED: u32 = 33;
pub const XCHAL_EXCCAUSE_COPROCESSOR2_DISABLED: u32 = 34;
pub const XCHAL_EXCCAUSE_COPROCESSOR3_DISABLED: u32 = 35;
pub const XCHAL_EXCCAUSE_COPROCESSOR4_DISABLED: u32 = 36;
pub const XCHAL_EXCCAUSE_COPROCESSOR5_DISABLED: u32 = 37;
pub const XCHAL_EXCCAUSE_COPROCESSOR6_DISABLED: u32 = 38;
pub const XCHAL_EXCCAUSE_COPROCESSOR7_DISABLED: u32 = 39;
pub const XCHAL_DBREAKC_VALIDMASK: u32 = 3221225535;
pub const XCHAL_DBREAKC_MASK_BITS: u32 = 6;
pub const XCHAL_DBREAKC_MASK_NUM: u32 = 64;
pub const XCHAL_DBREAKC_MASK_SHIFT: u32 = 0;
pub const XCHAL_DBREAKC_MASK_MASK: u32 = 63;
pub const XCHAL_DBREAKC_LOADBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_LOADBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const XCHAL_DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const XCHAL_DBREAKC_STOREBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_STOREBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const XCHAL_DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const XCHAL_PS_VALIDMASK: u32 = 462655;
pub const XCHAL_PS_INTLEVEL_BITS: u32 = 4;
pub const XCHAL_PS_INTLEVEL_NUM: u32 = 16;
pub const XCHAL_PS_INTLEVEL_SHIFT: u32 = 0;
pub const XCHAL_PS_INTLEVEL_MASK: u32 = 15;
pub const XCHAL_PS_EXCM_BITS: u32 = 1;
pub const XCHAL_PS_EXCM_NUM: u32 = 2;
pub const XCHAL_PS_EXCM_SHIFT: u32 = 4;
pub const XCHAL_PS_EXCM_MASK: u32 = 16;
pub const XCHAL_PS_UM_BITS: u32 = 1;
pub const XCHAL_PS_UM_NUM: u32 = 2;
pub const XCHAL_PS_UM_SHIFT: u32 = 5;
pub const XCHAL_PS_UM_MASK: u32 = 32;
pub const XCHAL_PS_RING_BITS: u32 = 2;
pub const XCHAL_PS_RING_NUM: u32 = 4;
pub const XCHAL_PS_RING_SHIFT: u32 = 6;
pub const XCHAL_PS_RING_MASK: u32 = 192;
pub const XCHAL_PS_OWB_BITS: u32 = 4;
pub const XCHAL_PS_OWB_NUM: u32 = 16;
pub const XCHAL_PS_OWB_SHIFT: u32 = 8;
pub const XCHAL_PS_OWB_MASK: u32 = 3840;
pub const XCHAL_PS_CALLINC_BITS: u32 = 2;
pub const XCHAL_PS_CALLINC_NUM: u32 = 4;
pub const XCHAL_PS_CALLINC_SHIFT: u32 = 16;
pub const XCHAL_PS_CALLINC_MASK: u32 = 196608;
pub const XCHAL_PS_WOE_BITS: u32 = 1;
pub const XCHAL_PS_WOE_NUM: u32 = 2;
pub const XCHAL_PS_WOE_SHIFT: u32 = 18;
pub const XCHAL_PS_WOE_MASK: u32 = 262144;
pub const XCHAL_EXCCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_EXCCAUSE_BITS: u32 = 6;
pub const XCHAL_EXCCAUSE_NUM: u32 = 64;
pub const XCHAL_EXCCAUSE_SHIFT: u32 = 0;
pub const XCHAL_EXCCAUSE_MASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_ICOUNT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_ICOUNT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const XCHAL_DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const XCHAL_DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const XCHAL_DEBUGCAUSE_BREAKN_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAKN_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const XCHAL_NUM_IROM: u32 = 1;
pub const XCHAL_NUM_IRAM: u32 = 2;
pub const XCHAL_NUM_DROM: u32 = 1;
pub const XCHAL_NUM_DRAM: u32 = 2;
pub const XCHAL_IROM0_VADDR: u32 = 1082130432;
pub const XCHAL_IROM0_PADDR: u32 = 1082130432;
pub const XCHAL_IROM0_SIZE: u32 = 4194304;
pub const XCHAL_IRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_SIZE: u32 = 4194304;
pub const XCHAL_IRAM1_VADDR: u32 = 1077936128;
pub const XCHAL_IRAM1_PADDR: u32 = 1077936128;
pub const XCHAL_IRAM1_SIZE: u32 = 4194304;
pub const XCHAL_DROM0_VADDR: u32 = 1061158912;
pub const XCHAL_DROM0_PADDR: u32 = 1061158912;
pub const XCHAL_DROM0_SIZE: u32 = 4194304;
pub const XCHAL_DRAM0_VADDR: u32 = 1073217536;
pub const XCHAL_DRAM0_PADDR: u32 = 1073217536;
pub const XCHAL_DRAM0_SIZE: u32 = 524288;
pub const XCHAL_DRAM1_VADDR: u32 = 1065353216;
pub const XCHAL_DRAM1_PADDR: u32 = 1065353216;
pub const XCHAL_DRAM1_SIZE: u32 = 4194304;
pub const XCHAL_CACHE_PREFCTL_DEFAULT: u32 = 4164;
pub const XCHAL_CACHE_LINEWIDTH_MAX: u32 = 2;
pub const XCHAL_CACHE_LINESIZE_MAX: u32 = 4;
pub const XCHAL_ICACHE_SETSIZE: u32 = 1;
pub const XCHAL_DCACHE_SETSIZE: u32 = 1;
pub const XCHAL_CACHE_SETWIDTH_MAX: u32 = 0;
pub const XCHAL_CACHE_SETSIZE_MAX: u32 = 1;
pub const XCHAL_ICACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_V: u32 = 1;
pub const XCHAL_ICACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_F: u32 = 0;
pub const XCHAL_ICACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_L: u32 = 0;
pub const XCHAL_DCACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_V: u32 = 1;
pub const XCHAL_DCACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_F: u32 = 0;
pub const XCHAL_DCACHE_TAG_D_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_D: u32 = 0;
pub const XCHAL_DCACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_L: u32 = 0;
pub const XCHAL_CACHE_MEMCTL_DEFAULT: u32 = 0;
pub const _MEMCTL_SNOOP_EN: u32 = 0;
pub const _MEMCTL_L0IBUF_EN: u32 = 1;
pub const XCHAL_SNOOP_LB_MEMCTL_DEFAULT: u32 = 1;
pub const XCHAL_ALIGN_MAX: u32 = 4;
pub const XCHAL_HW_RELEASE_MAJOR: u32 = 2600;
pub const XCHAL_HW_RELEASE_MINOR: u32 = 3;
pub const XCHAL_HW_RELEASE_NAME: &'static [u8; 8usize] = b"LX6.0.3\0";
pub const XCHAL_EXTRA_SA_SIZE: u32 = 48;
pub const XCHAL_EXTRA_SA_ALIGN: u32 = 4;
pub const XCHAL_CPEXTRA_SA_SIZE: u32 = 128;
pub const XCHAL_CPEXTRA_SA_ALIGN: u32 = 4;
pub const XCHAL_CP1_NAME: u32 = 0;
pub const XCHAL_CP1_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP2_NAME: u32 = 0;
pub const XCHAL_CP2_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP3_NAME: u32 = 0;
pub const XCHAL_CP3_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP4_NAME: u32 = 0;
pub const XCHAL_CP4_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP5_NAME: u32 = 0;
pub const XCHAL_CP5_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP6_NAME: u32 = 0;
pub const XCHAL_CP6_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP7_NAME: u32 = 0;
pub const XCHAL_CP7_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CPEXTRA_SA_SIZE_TOR2: u32 = 128;
pub const XCHAL_INST_ILLN: u32 = 61549;
pub const XCHAL_INST_ILLN_BYTE0: u32 = 109;
pub const XCHAL_INST_ILLN_BYTE1: u32 = 240;
pub const XTHAL_INST_ILL: u32 = 0;
pub const XCHAL_ERRATUM_453: u32 = 0;
pub const XCHAL_ERRATUM_497: u32 = 0;
pub const XCHAL_ERRATUM_572: u32 = 1;
pub const XSHAL_USE_ABSOLUTE_LITERALS: u32 = 0;
pub const XSHAL_HAVE_TEXT_SECTION_LITERALS: u32 = 1;
pub const XTHAL_ABI_WINDOWED: u32 = 0;
pub const XTHAL_ABI_CALL0: u32 = 1;
pub const XTHAL_CLIB_NEWLIB: u32 = 0;
pub const XTHAL_CLIB_UCLIBC: u32 = 1;
pub const XTHAL_CLIB_XCLIB: u32 = 2;
pub const XSHAL_USE_FLOATING_POINT: u32 = 1;
pub const XSHAL_FLOATING_POINT_ABI: u32 = 0;
pub const XSHAL_IOBLOCK_CACHED_VADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_PADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_SIZE: u32 = 234881024;
pub const XSHAL_IOBLOCK_BYPASS_VADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_PADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_SIZE: u32 = 234881024;
pub const XSHAL_ROM_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_PADDR: u32 = 1342177280;
pub const XSHAL_ROM_SIZE: u32 = 16777216;
pub const XSHAL_ROM_AVAIL_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_AVAIL_VSIZE: u32 = 16777216;
pub const XSHAL_RAM_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_PADDR: u32 = 1610612736;
pub const XSHAL_RAM_VSIZE: u32 = 536870912;
pub const XSHAL_RAM_PSIZE: u32 = 536870912;
pub const XSHAL_RAM_SIZE: u32 = 536870912;
pub const XSHAL_RAM_AVAIL_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_AVAIL_VSIZE: u32 = 536870912;
pub const XSHAL_RAM_BYPASS_VADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PSIZE: u32 = 536870912;
pub const XSHAL_SIMIO_CACHED_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_BYPASS_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_PADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_SIZE: u32 = 536870912;
pub const XSHAL_MAGIC_EXIT: u32 = 0;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEBACK: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEALLOC: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITETHRU: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_BYPASS: u32 = 572662306;
pub const XSHAL_ALLVALID_CACHEATTR_DEFAULT: u32 = 572657938;
pub const XSHAL_STRICT_CACHEATTR_WRITEBACK: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITEALLOC: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITETHRU: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_BYPASS: u32 = 4294910511;
pub const XSHAL_STRICT_CACHEATTR_DEFAULT: u32 = 4294906143;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_TRAPNULL_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_ISS_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_PIPE_REGIONS: u32 = 0;
pub const XSHAL_ISS_SDRAM_REGIONS: u32 = 0;
pub const XSHAL_XT2000_CACHEATTR_WRITEBACK: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITEALLOC: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITETHRU: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_BYPASS: u32 = 4280427055;
pub const XSHAL_XT2000_CACHEATTR_DEFAULT: u32 = 4280422687;
pub const XSHAL_XT2000_PIPE_REGIONS: u32 = 0;
pub const XSHAL_XT2000_SDRAM_REGIONS: u32 = 1088;
pub const XSHAL_VECTORS_PACKED: u32 = 0;
pub const XSHAL_STATIC_VECTOR_SELECT: u32 = 1;
pub const XSHAL_RESET_VECTOR_VADDR: u32 = 1073742848;
pub const XSHAL_RESET_VECTOR_PADDR: u32 = 1073742848;
pub const XSHAL_RESET_VECTOR_SIZE: u32 = 768;
pub const XSHAL_RESET_VECTOR_ISROM: u32 = 0;
pub const XSHAL_USER_VECTOR_SIZE: u32 = 56;
pub const XSHAL_USER_VECTOR_ISROM: u32 = 0;
pub const XSHAL_PROGRAMEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_USEREXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNEL_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNEL_VECTOR_ISROM: u32 = 0;
pub const XSHAL_STACKEDEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNELEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_DOUBLEEXC_VECTOR_SIZE: u32 = 64;
pub const XSHAL_DOUBLEEXC_VECTOR_ISROM: u32 = 0;
pub const XSHAL_WINDOW_VECTORS_SIZE: u32 = 376;
pub const XSHAL_WINDOW_VECTORS_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL2_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL2_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL3_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL3_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL4_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL4_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL5_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL5_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL6_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL6_VECTOR_ISROM: u32 = 0;
pub const XSHAL_DEBUG_VECTOR_SIZE: u32 = 56;
pub const XSHAL_DEBUG_VECTOR_ISROM: u32 = 0;
pub const XSHAL_NMI_VECTOR_SIZE: u32 = 56;
pub const XSHAL_NMI_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL7_VECTOR_SIZE: u32 = 56;
pub const EXCCAUSE_EXCCAUSE_SHIFT: u32 = 0;
pub const EXCCAUSE_EXCCAUSE_MASK: u32 = 63;
pub const EXCCAUSE_ILLEGAL: u32 = 0;
pub const EXCCAUSE_SYSCALL: u32 = 1;
pub const EXCCAUSE_INSTR_ERROR: u32 = 2;
pub const EXCCAUSE_IFETCHERROR: u32 = 2;
pub const EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const EXCCAUSE_LOADSTOREERROR: u32 = 3;
pub const EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const EXCCAUSE_LEVEL1INTERRUPT: u32 = 4;
pub const EXCCAUSE_ALLOCA: u32 = 5;
pub const EXCCAUSE_DIVIDE_BY_ZERO: u32 = 6;
pub const EXCCAUSE_SPECULATION: u32 = 7;
pub const EXCCAUSE_PRIVILEGED: u32 = 8;
pub const EXCCAUSE_UNALIGNED: u32 = 9;
pub const EXCCAUSE_INSTR_DATA_ERROR: u32 = 12;
pub const EXCCAUSE_LOAD_STORE_DATA_ERROR: u32 = 13;
pub const EXCCAUSE_INSTR_ADDR_ERROR: u32 = 14;
pub const EXCCAUSE_LOAD_STORE_ADDR_ERROR: u32 = 15;
pub const EXCCAUSE_ITLB_MISS: u32 = 16;
pub const EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const EXCCAUSE_INSTR_RING: u32 = 18;
pub const EXCCAUSE_INSTR_PROHIBITED: u32 = 20;
pub const EXCCAUSE_DTLB_MISS: u32 = 24;
pub const EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const EXCCAUSE_LOAD_STORE_RING: u32 = 26;
pub const EXCCAUSE_LOAD_PROHIBITED: u32 = 28;
pub const EXCCAUSE_STORE_PROHIBITED: u32 = 29;
pub const EXCCAUSE_CP0_DISABLED: u32 = 32;
pub const EXCCAUSE_CP1_DISABLED: u32 = 33;
pub const EXCCAUSE_CP2_DISABLED: u32 = 34;
pub const EXCCAUSE_CP3_DISABLED: u32 = 35;
pub const EXCCAUSE_CP4_DISABLED: u32 = 36;
pub const EXCCAUSE_CP5_DISABLED: u32 = 37;
pub const EXCCAUSE_CP6_DISABLED: u32 = 38;
pub const EXCCAUSE_CP7_DISABLED: u32 = 39;
pub const PS_WOE_SHIFT: u32 = 18;
pub const PS_WOE_MASK: u32 = 262144;
pub const PS_WOE: u32 = 262144;
pub const PS_CALLINC_SHIFT: u32 = 16;
pub const PS_CALLINC_MASK: u32 = 196608;
pub const PS_OWB_SHIFT: u32 = 8;
pub const PS_OWB_MASK: u32 = 3840;
pub const PS_RING_SHIFT: u32 = 6;
pub const PS_RING_MASK: u32 = 192;
pub const PS_UM_SHIFT: u32 = 5;
pub const PS_UM_MASK: u32 = 32;
pub const PS_UM: u32 = 32;
pub const PS_EXCM_SHIFT: u32 = 4;
pub const PS_EXCM_MASK: u32 = 16;
pub const PS_EXCM: u32 = 16;
pub const PS_INTLEVEL_SHIFT: u32 = 0;
pub const PS_INTLEVEL_MASK: u32 = 15;
pub const PS_PROGSTACK_SHIFT: u32 = 5;
pub const PS_PROGSTACK_MASK: u32 = 32;
pub const PS_PROG_SHIFT: u32 = 5;
pub const PS_PROG_MASK: u32 = 32;
pub const PS_PROG: u32 = 32;
pub const DBREAKC_MASK_SHIFT: u32 = 0;
pub const DBREAKC_MASK_MASK: u32 = 63;
pub const DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const MESR_MEME: u32 = 1;
pub const MESR_MEME_SHIFT: u32 = 0;
pub const MESR_DME: u32 = 2;
pub const MESR_DME_SHIFT: u32 = 1;
pub const MESR_RCE: u32 = 16;
pub const MESR_RCE_SHIFT: u32 = 4;
pub const MESR_ERRENAB: u32 = 256;
pub const MESR_ERRENAB_SHIFT: u32 = 8;
pub const MESR_ERRTEST: u32 = 512;
pub const MESR_ERRTEST_SHIFT: u32 = 9;
pub const MESR_DATEXC: u32 = 1024;
pub const MESR_DATEXC_SHIFT: u32 = 10;
pub const MESR_INSEXC: u32 = 2048;
pub const MESR_INSEXC_SHIFT: u32 = 11;
pub const MESR_WAYNUM_SHIFT: u32 = 16;
pub const MESR_ACCTYPE_SHIFT: u32 = 20;
pub const MESR_MEMTYPE_SHIFT: u32 = 24;
pub const MESR_ERRTYPE_SHIFT: u32 = 30;
pub const MEMCTL_SNOOP_EN_SHIFT: u32 = 1;
pub const MEMCTL_SNOOP_EN: u32 = 2;
pub const MEMCTL_L0IBUF_EN_SHIFT: u32 = 0;
pub const MEMCTL_L0IBUF_EN: u32 = 1;
pub const MEMCTL_INV_EN_SHIFT: u32 = 23;
pub const MEMCTL_INV_EN: u32 = 8388608;
pub const MEMCTL_DCWU_SHIFT: u32 = 8;
pub const MEMCTL_DCWU_BITS: u32 = 5;
pub const MEMCTL_DCWA_SHIFT: u32 = 13;
pub const MEMCTL_DCWA_BITS: u32 = 5;
pub const MEMCTL_ICWU_SHIFT: u32 = 18;
pub const MEMCTL_ICWU_BITS: u32 = 5;
pub const MEMCTL_DCWU_MASK: u32 = 7936;
pub const MEMCTL_DCWA_MASK: u32 = 253952;
pub const MEMCTL_ICWU_MASK: u32 = 8126464;
pub const MEMCTL_DCWU_CLR_MASK: i32 = -7937;
pub const MEMCTL_DCWA_CLR_MASK: i32 = -253953;
pub const MEMCTL_ICWU_CLR_MASK: i32 = -8126465;
pub const MEMCTL_DCW_CLR_MASK: i32 = -1;
pub const MEMCTL_IDCW_CLR_MASK: i32 = -1;
pub const CALL0_ABI: u32 = 0;
pub const ALIGNPAD: u32 = 2;
pub const KERNELSTACKSIZE: u32 = 1024;
pub const XT_CP0_SA: u32 = 0;
pub const XT_CPENABLE: u32 = 0;
pub const XT_CPSTORED: u32 = 2;
pub const XT_CP_CS_ST: u32 = 4;
pub const XT_CP_ASA: u32 = 8;
pub const CORE_ID_PRO: u32 = 52685;
pub const CORE_ID_APP: u32 = 43947;
pub const STK_INTEXC_EXTRA: u32 = 0;
pub const XT_CLIB_CONTEXT_AREA_SIZE: u32 = 0;
pub const XT_USER_SIZE: u32 = 1024;
pub const __have_longlong64: u32 = 1;
pub const __int8_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST8_MAX: u32 = 127;
pub const UINT_FAST8_MAX: u32 = 255;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST16_MAX: u32 = 32767;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const UINTMAX_MAX: i32 = -1;
pub const SIZE_MAX: u32 = 4294967295;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 255;
pub const WINT_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const MACSTR: &'static [u8; 30usize] = b"%02x:%02x:%02x:%02x:%02x:%02x\0";
pub const configUSE_PREEMPTION: u32 = 1;
pub const configUSE_IDLE_HOOK: u32 = 1;
pub const configUSE_TICK_HOOK: u32 = 1;
pub const configTICK_RATE_HZ: u32 = 100;
pub const configMAX_PRIORITIES: u32 = 25;
pub const configMINIMAL_STACK_SIZE: u32 = 768;
pub const configIDLE_TASK_STACK_SIZE: u32 = 1536;
pub const configISR_STACK_SIZE: u32 = 1536;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 1;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configUSE_TRACE_FACILITY_2: u32 = 0;
pub const configBENCHMARK: u32 = 0;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 0;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 2;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskCleanUpResources: u32 = 0;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 1;
pub const INCLUDE_pcTaskGetTaskName: u32 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 1;
pub const INCLUDE_pxTaskGetStackStart: u32 = 1;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 1;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 1;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 3;
pub const configUSE_NEWLIB_REENTRANT: u32 = 1;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configUSE_TIMERS: u32 = 1;
pub const configTIMER_TASK_PRIORITY: u32 = 1;
pub const configTIMER_QUEUE_LENGTH: u32 = 10;
pub const configTIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 1;
pub const INCLUDE_eTaskGetState: u32 = 1;
pub const configUSE_QUEUE_SETS: u32 = 1;
pub const configXT_BOARD: u32 = 1;
pub const configXT_SIMULATOR: u32 = 0;
pub const configENABLE_TASK_SNAPSHOT: u32 = 1;
pub const configCHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const ESP_TASK_PRIO_MAX: u32 = 25;
pub const ESP_TASK_PRIO_MIN: u32 = 0;
pub const ESP_TASK_BT_CONTROLLER_PRIO: u32 = 23;
pub const TASK_EXTRA_STACK_SIZE: u32 = 512;
pub const BT_TASK_EXTRA_STACK_SIZE: u32 = 512;
pub const ESP_TASK_BT_CONTROLLER_STACK: u32 = 4096;
pub const ESP_TASK_TIMER_PRIO: u32 = 22;
pub const ESP_TASK_TIMER_STACK: u32 = 4096;
pub const ESP_TASKD_EVENT_PRIO: u32 = 20;
pub const ESP_TASKD_EVENT_STACK: u32 = 2816;
pub const ESP_TASK_TCPIP_PRIO: u32 = 18;
pub const ESP_TASK_TCPIP_STACK: u32 = 3584;
pub const ESP_TASK_MAIN_PRIO: u32 = 1;
pub const ESP_TASK_MAIN_STACK: u32 = 16896;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 128;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const TMP_MAX: u32 = 26;
pub const L_cuserid: u32 = 9;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const ESP_ERR_FLASH_BASE: u32 = 24576;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const ESP_IDF_VERSION_MAJOR: u32 = 4;
pub const ESP_IDF_VERSION_MINOR: u32 = 0;
pub const ESP_IDF_VERSION_PATCH: u32 = 0;
pub const TWO_UNIVERSAL_MAC_ADDR: u32 = 2;
pub const FOUR_UNIVERSAL_MAC_ADDR: u32 = 4;
pub const UNIVERSAL_MAC_ADDR_NUM: u32 = 4;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 1;
pub const MEM_LIBC_MALLOC: u32 = 1;
pub const MEMP_MEM_MALLOC: u32 = 1;
pub const MEM_ALIGNMENT: u32 = 4;
pub const MEMP_NUM_NETCONN: u32 = 10;
pub const MEMP_NUM_RAW_PCB: u32 = 16;
pub const MEMP_NUM_TCP_PCB: u32 = 16;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 16;
pub const MEMP_NUM_UDP_PCB: u32 = 16;
pub const ARP_QUEUEING: u32 = 1;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const LWIP_RAW: u32 = 1;
pub const LWIP_DHCP: u32 = 1;
pub const DHCP_MAXRTX: u32 = 0;
pub const DHCP_DOES_ARP_CHECK: u32 = 1;
pub const LWIP_IGMP: u32 = 1;
pub const LWIP_DNS: u32 = 1;
pub const DNS_MAX_SERVERS: u32 = 3;
pub const DNS_FALLBACK_SERVER_INDEX: u32 = 2;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const TCP_MSS: u32 = 1440;
pub const TCP_MSL: u32 = 60000;
pub const TCP_MAXRTX: u32 = 12;
pub const TCP_SYNMAXRTX: u32 = 6;
pub const TCP_LISTEN_BACKLOG: u32 = 1;
pub const TCP_OVERSIZE: u32 = 1440;
pub const LWIP_NETIF_HOSTNAME: u32 = 1;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 1;
pub const LWIP_NETIF_LOOPBACK: u32 = 1;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const TCPIP_THREAD_NAME: &'static [u8; 4usize] = b"tiT\0";
pub const TCPIP_THREAD_STACKSIZE: u32 = 3584;
pub const TCPIP_THREAD_PRIO: u32 = 18;
pub const TCPIP_MBOX_SIZE: u32 = 32;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 6;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 6;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 6;
pub const DEFAULT_THREAD_STACKSIZE: u32 = 3584;
pub const DEFAULT_THREAD_PRIO: u32 = 18;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 6;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 0;
pub const LWIP_SO_SNDTIMEO: u32 = 1;
pub const LWIP_SO_RCVTIMEO: u32 = 1;
pub const LWIP_TCP_KEEPALIVE: u32 = 1;
pub const SO_REUSE: u32 = 1;
pub const SO_REUSE_RXTOALL: u32 = 1;
pub const LWIP_IPV6: u32 = 1;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 0;
pub const LWIP_SOCKET_OFFSET: u32 = 54;
pub const ESP_LWIP: u32 = 1;
pub const ESP_LWIP_ARP: u32 = 1;
pub const ESP_PER_SOC_TCP_WND: u32 = 0;
pub const ESP_THREAD_SAFE: u32 = 1;
pub const ESP_DHCP: u32 = 1;
pub const ESP_DNS: u32 = 1;
pub const ESP_IPV6_AUTOCONFIG: u32 = 1;
pub const ESP_PERF: u32 = 0;
pub const ESP_RANDOM_TCP_PORT: u32 = 1;
pub const ESP_IP4_ATON: u32 = 1;
pub const ESP_LIGHT_SLEEP: u32 = 1;
pub const ESP_STATS_TCP: u32 = 0;
pub const ESP_DHCPS_TIMER: u32 = 1;
pub const ESP_PING: u32 = 1;
pub const ESP_HAS_SELECT: u32 = 1;
pub const ESP_AUTO_RECV: u32 = 1;
pub const ESP_GRATUITOUS_ARP: u32 = 1;
pub const ESP_IP4_ROUTE: u32 = 1;
pub const ESP_AUTO_IP: u32 = 1;
pub const ESP_PBUF: u32 = 1;
pub const ESP_PPP: u32 = 1;
pub const ESP_IPV6: u32 = 1;
pub const ESP_SOCKET: u32 = 1;
pub const ESP_LWIP_SELECT: u32 = 1;
pub const ESP_LWIP_LOCK: u32 = 1;
pub const ESP_LWIP_IGMP_TIMERS_ONDEMAND: u32 = 1;
pub const ESP_LWIP_MLD6_TIMERS_ONDEMAND: u32 = 1;
pub const TCP_SND_BUF: u32 = 5744;
pub const TCP_WND: u32 = 5744;
pub const CHECKSUM_CHECK_UDP: u32 = 0;
pub const CHECKSUM_CHECK_IP: u32 = 0;
pub const LWIP_NETCONN_FULLDUPLEX: u32 = 1;
pub const LWIP_NETCONN_SEM_PER_THREAD: u32 = 1;
pub const LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const LWIP_TIMEVAL_PRIVATE: u32 = 0;
pub const SNTP_SERVER_DNS: u32 = 1;
pub const SNTP_UPDATE_DELAY: u32 = 3600000;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const LBEG: u32 = 0;
pub const LEND: u32 = 1;
pub const LCOUNT: u32 = 2;
pub const SAR: u32 = 3;
pub const BR: u32 = 4;
pub const SCOMPARE1: u32 = 12;
pub const ACCLO: u32 = 16;
pub const ACCHI: u32 = 17;
pub const MR_0: u32 = 32;
pub const MR_1: u32 = 33;
pub const MR_2: u32 = 34;
pub const MR_3: u32 = 35;
pub const WINDOWBASE: u32 = 72;
pub const WINDOWSTART: u32 = 73;
pub const IBREAKENABLE: u32 = 96;
pub const MEMCTL: u32 = 97;
pub const ATOMCTL: u32 = 99;
pub const DDR: u32 = 104;
pub const IBREAKA_0: u32 = 128;
pub const IBREAKA_1: u32 = 129;
pub const DBREAKA_0: u32 = 144;
pub const DBREAKA_1: u32 = 145;
pub const DBREAKC_0: u32 = 160;
pub const DBREAKC_1: u32 = 161;
pub const EPC_1: u32 = 177;
pub const EPC_2: u32 = 178;
pub const EPC_3: u32 = 179;
pub const EPC_4: u32 = 180;
pub const EPC_5: u32 = 181;
pub const EPC_6: u32 = 182;
pub const EPC_7: u32 = 183;
pub const DEPC: u32 = 192;
pub const EPS_2: u32 = 194;
pub const EPS_3: u32 = 195;
pub const EPS_4: u32 = 196;
pub const EPS_5: u32 = 197;
pub const EPS_6: u32 = 198;
pub const EPS_7: u32 = 199;
pub const EXCSAVE_1: u32 = 209;
pub const EXCSAVE_2: u32 = 210;
pub const EXCSAVE_3: u32 = 211;
pub const EXCSAVE_4: u32 = 212;
pub const EXCSAVE_5: u32 = 213;
pub const EXCSAVE_6: u32 = 214;
pub const EXCSAVE_7: u32 = 215;
pub const CPENABLE: u32 = 224;
pub const INTERRUPT: u32 = 226;
pub const INTENABLE: u32 = 228;
pub const PS: u32 = 230;
pub const VECBASE: u32 = 231;
pub const EXCCAUSE: u32 = 232;
pub const DEBUGCAUSE: u32 = 233;
pub const CCOUNT: u32 = 234;
pub const PRID: u32 = 235;
pub const ICOUNT: u32 = 236;
pub const ICOUNTLEVEL: u32 = 237;
pub const EXCVADDR: u32 = 238;
pub const CCOMPARE_0: u32 = 240;
pub const CCOMPARE_1: u32 = 241;
pub const CCOMPARE_2: u32 = 242;
pub const MISC_REG_0: u32 = 244;
pub const MISC_REG_1: u32 = 245;
pub const MISC_REG_2: u32 = 246;
pub const MISC_REG_3: u32 = 247;
pub const MR: u32 = 32;
pub const IBREAKA: u32 = 128;
pub const DBREAKA: u32 = 144;
pub const DBREAKC: u32 = 160;
pub const EPC: u32 = 176;
pub const EPS: u32 = 192;
pub const EXCSAVE: u32 = 208;
pub const CCOMPARE: u32 = 240;
pub const INTREAD: u32 = 226;
pub const INTSET: u32 = 226;
pub const INTCLEAR: u32 = 227;
pub const CORE_STATE_SIGNATURE: u32 = 2982522861;
pub const XTOS_KEEPON_MEM: u32 = 256;
pub const XTOS_KEEPON_MEM_SHIFT: u32 = 8;
pub const XTOS_KEEPON_DEBUG: u32 = 4096;
pub const XTOS_KEEPON_DEBUG_SHIFT: u32 = 12;
pub const XTOS_COREF_PSO: u32 = 1;
pub const XTOS_COREF_PSO_SHIFT: u32 = 0;
pub const MALLOC_CAP_EXEC: u32 = 1;
pub const MALLOC_CAP_32BIT: u32 = 2;
pub const MALLOC_CAP_8BIT: u32 = 4;
pub const MALLOC_CAP_DMA: u32 = 8;
pub const MALLOC_CAP_PID2: u32 = 16;
pub const MALLOC_CAP_PID3: u32 = 32;
pub const MALLOC_CAP_PID4: u32 = 64;
pub const MALLOC_CAP_PID5: u32 = 128;
pub const MALLOC_CAP_PID6: u32 = 256;
pub const MALLOC_CAP_PID7: u32 = 512;
pub const MALLOC_CAP_SPIRAM: u32 = 1024;
pub const MALLOC_CAP_INTERNAL: u32 = 2048;
pub const MALLOC_CAP_DEFAULT: u32 = 4096;
pub const MALLOC_CAP_INVALID: u32 = 2147483648;
pub const portMUX_FREE_VAL: u32 = 3007315967;
pub const portMUX_NO_TIMEOUT: i32 = -1;
pub const portMUX_TRY_LOCK: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 1;
pub const portTcbMemoryCaps: u32 = 2052;
pub const portStackMemoryCaps: u32 = 2052;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 4;
pub const portBYTE_ALIGNMENT_MASK: u32 = 3;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const INCLUDE_xTimerGetTimerDaemonTaskHandle: u32 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const INCLUDE_xEventGroupSetBitFromISR: u32 = 0;
pub const configASSERT_DEFINED: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 0;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 0;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configUSE_TIME_SLICING: u32 = 1;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configTASKLIST_INCLUDE_COREID: u32 = 0;
pub const configUSE_TRACE_FACILITY: u32 = 0;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 0;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 0;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 1;
pub const configESP32_PER_TASK_DATA: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const ARG_MAX: u32 = 4096;
pub const PATH_MAX: u32 = 1024;
pub const SCHAR_MAX: u32 = 127;
pub const SHRT_MAX: u32 = 32767;
pub const INT_MAX: u32 = 2147483647;
pub const LONG_MAX: u32 = 2147483647;
pub const SCHAR_MIN: i32 = -128;
pub const SHRT_MIN: i32 = -32768;
pub const INT_MIN: i32 = -2147483648;
pub const LONG_MIN: i32 = -2147483648;
pub const UCHAR_MAX: u32 = 255;
pub const USHRT_MAX: u32 = 65535;
pub const UINT_MAX: u32 = 4294967295;
pub const ULONG_MAX: u32 = 4294967295;
pub const CHAR_BIT: u32 = 8;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LONG_LONG_MAX: u64 = 9223372036854775807;
pub const LONG_LONG_MIN: i64 = -9223372036854775808;
pub const ULONG_LONG_MAX: i32 = -1;
pub const tskKERNEL_VERSION_NUMBER: &'static [u8; 7usize] = b"V8.2.0\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 8;
pub const tskKERNEL_VERSION_MINOR: u32 = 2;
pub const tskKERNEL_VERSION_BUILD: u32 = 0;
pub const tskNO_AFFINITY: u32 = 2147483647;
pub const LWIP_COMPAT_MUTEX: u32 = 0;
pub const BYTE_ORDER: u32 = 1234;
pub const S16_F: &'static [u8; 2usize] = b"d\0";
pub const U16_F: &'static [u8; 2usize] = b"d\0";
pub const X16_F: &'static [u8; 2usize] = b"x\0";
pub const S32_F: &'static [u8; 2usize] = b"d\0";
pub const U32_F: &'static [u8; 2usize] = b"d\0";
pub const X32_F: &'static [u8; 2usize] = b"x\0";
pub const LWIP_NO_STDDEF_H: u32 = 0;
pub const LWIP_NO_STDINT_H: u32 = 0;
pub const LWIP_HAVE_INT64: u32 = 1;
pub const LWIP_NO_INTTYPES_H: u32 = 0;
pub const X8_F: &'static [u8; 3usize] = b"02\0";
pub const LWIP_NO_LIMITS_H: u32 = 0;
pub const SSIZE_MAX: u32 = 2147483647;
pub const LWIP_UINT32_MAX: u32 = 4294967295;
pub const LWIP_NO_CTYPE_H: u32 = 0;
pub const _U: u32 = 1;
pub const _L: u32 = 2;
pub const _N: u32 = 4;
pub const _S: u32 = 8;
pub const _P: u32 = 16;
pub const _C: u32 = 32;
pub const _X: u32 = 64;
pub const _B: u32 = 128;
pub const LWIP_DBG_LEVEL_ALL: u32 = 0;
pub const LWIP_DBG_LEVEL_WARNING: u32 = 1;
pub const LWIP_DBG_LEVEL_SERIOUS: u32 = 2;
pub const LWIP_DBG_LEVEL_SEVERE: u32 = 3;
pub const LWIP_DBG_MASK_LEVEL: u32 = 3;
pub const LWIP_DBG_LEVEL_OFF: u32 = 0;
pub const LWIP_DBG_ON: u32 = 128;
pub const LWIP_DBG_OFF: u32 = 0;
pub const LWIP_DBG_TRACE: u32 = 64;
pub const LWIP_DBG_STATE: u32 = 32;
pub const LWIP_DBG_FRESH: u32 = 16;
pub const LWIP_DBG_HALT: u32 = 8;
pub const NO_SYS: u32 = 0;
pub const LWIP_TIMERS: u32 = 1;
pub const LWIP_TIMERS_CUSTOM: u32 = 0;
pub const LWIP_MPU_COMPATIBLE: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 0;
pub const MEMP_MEM_INIT: u32 = 0;
pub const MEM_SIZE: u32 = 1600;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 0;
pub const MEM_OVERFLOW_CHECK: u32 = 0;
pub const MEM_SANITY_CHECK: u32 = 0;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_PBUF: u32 = 16;
pub const MEMP_NUM_TCP_SEG: u32 = 16;
pub const MEMP_NUM_ALTCP_PCB: u32 = 16;
pub const MEMP_NUM_REASSDATA: u32 = 5;
pub const MEMP_NUM_FRAG_PBUF: u32 = 15;
pub const MEMP_NUM_ARP_QUEUE: u32 = 30;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_NETBUF: u32 = 2;
pub const MEMP_NUM_SELECT_CB: u32 = 4;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 8;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 8;
pub const MEMP_NUM_NETDB: u32 = 1;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 1;
pub const PBUF_POOL_SIZE: u32 = 16;
pub const MEMP_NUM_API_MSG: u32 = 8;
pub const MEMP_NUM_DNS_API_MSG: u32 = 8;
pub const MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA: u32 = 8;
pub const MEMP_NUM_NETIFAPI_MSG: u32 = 8;
pub const LWIP_ARP: u32 = 1;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ARP_MAXAGE: u32 = 300;
pub const ARP_QUEUE_LEN: u32 = 3;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const LWIP_ETHERNET: u32 = 1;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 0;
pub const LWIP_IPV4: u32 = 1;
pub const IP_FORWARD: u32 = 0;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_DEFAULT_TTL: u32 = 255;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const IP_FORWARD_ALLOW_TX_ON_RX_NETIF: u32 = 0;
pub const LWIP_ICMP: u32 = 1;
pub const ICMP_TTL: u32 = 255;
pub const RAW_TTL: u32 = 255;
pub const LWIP_DHCP_BOOTP_FILE: u32 = 0;
pub const LWIP_DHCP_GET_NTP_SRV: u32 = 0;
pub const LWIP_DHCP_MAX_DNS_SERVERS: u32 = 3;
pub const LWIP_AUTOIP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const LWIP_MIB2_CALLBACKS: u32 = 0;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_MAX_RETRIES: u32 = 4;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const LWIP_DNS_SECURE_RAND_XID: u32 = 1;
pub const LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING: u32 = 2;
pub const LWIP_DNS_SECURE_RAND_SRC_PORT: u32 = 4;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 0;
pub const LWIP_UDP: u32 = 1;
pub const LWIP_UDPLITE: u32 = 0;
pub const UDP_TTL: u32 = 255;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const LWIP_TCP: u32 = 1;
pub const TCP_TTL: u32 = 255;
pub const LWIP_TCP_SACK_OUT: u32 = 0;
pub const LWIP_TCP_MAX_SACK_NUM: u32 = 4;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_SND_QUEUELEN: u32 = 16;
pub const TCP_OOSEQ_MAX_BYTES: u32 = 0;
pub const TCP_OOSEQ_MAX_PBUFS: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const LWIP_EVENT_API: u32 = 0;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const LWIP_WND_SCALE: u32 = 0;
pub const TCP_RCV_SCALE: u32 = 0;
pub const LWIP_TCP_PCB_NUM_EXT_ARGS: u32 = 0;
pub const LWIP_ALTCP: u32 = 0;
pub const LWIP_ALTCP_TLS: u32 = 0;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const PBUF_LINK_ENCAPSULATION_HLEN: u32 = 0;
pub const LWIP_SINGLE_NETIF: u32 = 0;
pub const LWIP_NETIF_API: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_EXT_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 0;
pub const LWIP_NETIF_REMOVE_CALLBACK: u32 = 0;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_NUM_NETIF_CLIENT_DATA: u32 = 0;
pub const LWIP_LOOPIF_MULTICAST: u32 = 0;
pub const SLIPIF_THREAD_NAME: &'static [u8; 12usize] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &'static [u8; 5usize] = b"lwIP\0";
pub const LWIP_NETCONN: u32 = 1;
pub const LWIP_TCPIP_TIMEOUT: u32 = 0;
pub const LWIP_SOCKET: u32 = 1;
pub const LWIP_COMPAT_SOCKETS: u32 = 1;
pub const LWIP_SO_SNDRCVTIMEO_NONSTANDARD: u32 = 0;
pub const LWIP_SO_LINGER: u32 = 0;
pub const RECV_BUFSIZE_DEFAULT: u32 = 2147483647;
pub const LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT: u32 = 20000;
pub const LWIP_FIONREAD_LINUXMODE: u32 = 0;
pub const LWIP_SOCKET_SELECT: u32 = 1;
pub const LWIP_SOCKET_POLL: u32 = 1;
pub const LINK_STATS: u32 = 0;
pub const ETHARP_STATS: u32 = 0;
pub const IP_STATS: u32 = 0;
pub const IPFRAG_STATS: u32 = 0;
pub const ICMP_STATS: u32 = 0;
pub const IGMP_STATS: u32 = 0;
pub const UDP_STATS: u32 = 0;
pub const TCP_STATS: u32 = 0;
pub const MEM_STATS: u32 = 0;
pub const MEMP_STATS: u32 = 0;
pub const SYS_STATS: u32 = 0;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const IP6_STATS: u32 = 0;
pub const ICMP6_STATS: u32 = 0;
pub const IP6_FRAG_STATS: u32 = 0;
pub const MLD6_STATS: u32 = 0;
pub const ND6_STATS: u32 = 0;
pub const MIB2_STATS: u32 = 0;
pub const LWIP_CHECKSUM_CTRL_PER_NETIF: u32 = 0;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_GEN_ICMP: u32 = 1;
pub const CHECKSUM_GEN_ICMP6: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP6: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub const IPV6_REASS_MAXAGE: u32 = 60;
pub const LWIP_IPV6_SCOPES_DEBUG: u32 = 0;
pub const LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const LWIP_IPV6_FORWARD: u32 = 0;
pub const LWIP_IPV6_FRAG: u32 = 1;
pub const LWIP_IPV6_REASS: u32 = 1;
pub const LWIP_IPV6_SEND_ROUTER_SOLICIT: u32 = 1;
pub const LWIP_IPV6_AUTOCONFIG: u32 = 1;
pub const LWIP_IPV6_ADDRESS_LIFETIMES: u32 = 1;
pub const LWIP_IPV6_DUP_DETECT_ATTEMPTS: u32 = 1;
pub const LWIP_ICMP6: u32 = 1;
pub const LWIP_ICMP6_DATASIZE: u32 = 8;
pub const LWIP_ICMP6_HL: u32 = 255;
pub const LWIP_IPV6_MLD: u32 = 1;
pub const MEMP_NUM_MLD6_GROUP: u32 = 4;
pub const LWIP_ND6_QUEUEING: u32 = 1;
pub const MEMP_NUM_ND6_QUEUE: u32 = 20;
pub const LWIP_ND6_NUM_NEIGHBORS: u32 = 10;
pub const LWIP_ND6_NUM_DESTINATIONS: u32 = 10;
pub const LWIP_ND6_NUM_PREFIXES: u32 = 5;
pub const LWIP_ND6_NUM_ROUTERS: u32 = 3;
pub const LWIP_ND6_MAX_MULTICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_UNICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_ANYCAST_DELAY_TIME: u32 = 1000;
pub const LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT: u32 = 3;
pub const LWIP_ND6_REACHABLE_TIME: u32 = 30000;
pub const LWIP_ND6_RETRANS_TIMER: u32 = 1000;
pub const LWIP_ND6_DELAY_FIRST_PROBE_TIME: u32 = 5000;
pub const LWIP_ND6_ALLOW_RA_UPDATES: u32 = 1;
pub const LWIP_ND6_TCP_REACHABILITY_HINTS: u32 = 1;
pub const LWIP_ND6_RDNSS_MAX_DNS_SERVERS: u32 = 0;
pub const LWIP_IPV6_DHCP6: u32 = 0;
pub const LWIP_IPV6_DHCP6_STATEFUL: u32 = 0;
pub const LWIP_IPV6_DHCP6_STATELESS: u32 = 0;
pub const LWIP_DHCP6_GET_NTP_SRV: u32 = 0;
pub const LWIP_DHCP6_MAX_NTP_SERVERS: u32 = 1;
pub const LWIP_DHCP6_MAX_DNS_SERVERS: u32 = 3;
pub const LWIP_DBG_MIN_LEVEL: u32 = 0;
pub const LWIP_DBG_TYPES_ON: u32 = 128;
pub const API_MSG_DEBUG: u32 = 0;
pub const IGMP_DEBUG: u32 = 0;
pub const INET_DEBUG: u32 = 0;
pub const IP_REASS_DEBUG: u32 = 0;
pub const RAW_DEBUG: u32 = 0;
pub const MEM_DEBUG: u32 = 0;
pub const SYS_DEBUG: u32 = 0;
pub const TIMERS_DEBUG: u32 = 0;
pub const TCP_FR_DEBUG: u32 = 0;
pub const TCP_RTO_DEBUG: u32 = 0;
pub const TCP_CWND_DEBUG: u32 = 0;
pub const TCP_WND_DEBUG: u32 = 0;
pub const TCP_RST_DEBUG: u32 = 0;
pub const TCP_QLEN_DEBUG: u32 = 0;
pub const UDP_DEBUG: u32 = 0;
pub const SLIP_DEBUG: u32 = 0;
pub const AUTOIP_DEBUG: u32 = 0;
pub const DNS_DEBUG: u32 = 0;
pub const IP6_DEBUG: u32 = 0;
pub const DHCP6_DEBUG: u32 = 0;
pub const LWIP_TESTMODE: u32 = 0;
pub const LWIP_PERF: u32 = 0;
pub const IP_CLASSA_NET: u32 = 4278190080;
pub const IP_CLASSA_NSHIFT: u32 = 24;
pub const IP_CLASSA_HOST: u32 = 16777215;
pub const IP_CLASSA_MAX: u32 = 128;
pub const IP_CLASSB_NET: u32 = 4294901760;
pub const IP_CLASSB_NSHIFT: u32 = 16;
pub const IP_CLASSB_HOST: u32 = 65535;
pub const IP_CLASSB_MAX: u32 = 65536;
pub const IP_CLASSC_NET: u32 = 4294967040;
pub const IP_CLASSC_NSHIFT: u32 = 8;
pub const IP_CLASSC_HOST: u32 = 255;
pub const IP_CLASSD_NET: u32 = 4026531840;
pub const IP_CLASSD_NSHIFT: u32 = 28;
pub const IP_CLASSD_HOST: u32 = 268435455;
pub const IP_LOOPBACKNET: u32 = 127;
pub const IP4ADDR_STRLEN_MAX: u32 = 16;
pub const IP6_NO_ZONE: u32 = 0;
pub const IPV6_CUSTOM_SCOPES: u32 = 0;
pub const IP6_MULTICAST_SCOPE_RESERVED: u32 = 0;
pub const IP6_MULTICAST_SCOPE_RESERVED0: u32 = 0;
pub const IP6_MULTICAST_SCOPE_INTERFACE_LOCAL: u32 = 1;
pub const IP6_MULTICAST_SCOPE_LINK_LOCAL: u32 = 2;
pub const IP6_MULTICAST_SCOPE_RESERVED3: u32 = 3;
pub const IP6_MULTICAST_SCOPE_ADMIN_LOCAL: u32 = 4;
pub const IP6_MULTICAST_SCOPE_SITE_LOCAL: u32 = 5;
pub const IP6_MULTICAST_SCOPE_ORGANIZATION_LOCAL: u32 = 8;
pub const IP6_MULTICAST_SCOPE_GLOBAL: u32 = 14;
pub const IP6_MULTICAST_SCOPE_RESERVEDF: u32 = 15;
pub const IP6_ADDR_INVALID: u32 = 0;
pub const IP6_ADDR_TENTATIVE: u32 = 8;
pub const IP6_ADDR_TENTATIVE_1: u32 = 9;
pub const IP6_ADDR_TENTATIVE_2: u32 = 10;
pub const IP6_ADDR_TENTATIVE_3: u32 = 11;
pub const IP6_ADDR_TENTATIVE_4: u32 = 12;
pub const IP6_ADDR_TENTATIVE_5: u32 = 13;
pub const IP6_ADDR_TENTATIVE_6: u32 = 14;
pub const IP6_ADDR_TENTATIVE_7: u32 = 15;
pub const IP6_ADDR_VALID: u32 = 16;
pub const IP6_ADDR_PREFERRED: u32 = 48;
pub const IP6_ADDR_DEPRECATED: u32 = 16;
pub const IP6_ADDR_DUPLICATED: u32 = 64;
pub const IP6_ADDR_TENTATIVE_COUNT_MASK: u32 = 7;
pub const IP6_ADDR_LIFE_STATIC: u32 = 0;
pub const IP6_ADDR_LIFE_INFINITE: u32 = 4294967295;
pub const IP6ADDR_STRLEN_MAX: u32 = 46;
pub const IPADDR_STRLEN_MAX: u32 = 46;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const ESP_ERR_NVS_BASE: u32 = 4352;
pub const ESP_ERR_NVS_NOT_INITIALIZED: u32 = 4353;
pub const ESP_ERR_NVS_NOT_FOUND: u32 = 4354;
pub const ESP_ERR_NVS_TYPE_MISMATCH: u32 = 4355;
pub const ESP_ERR_NVS_READ_ONLY: u32 = 4356;
pub const ESP_ERR_NVS_NOT_ENOUGH_SPACE: u32 = 4357;
pub const ESP_ERR_NVS_INVALID_NAME: u32 = 4358;
pub const ESP_ERR_NVS_INVALID_HANDLE: u32 = 4359;
pub const ESP_ERR_NVS_REMOVE_FAILED: u32 = 4360;
pub const ESP_ERR_NVS_KEY_TOO_LONG: u32 = 4361;
pub const ESP_ERR_NVS_PAGE_FULL: u32 = 4362;
pub const ESP_ERR_NVS_INVALID_STATE: u32 = 4363;
pub const ESP_ERR_NVS_INVALID_LENGTH: u32 = 4364;
pub const ESP_ERR_NVS_NO_FREE_PAGES: u32 = 4365;
pub const ESP_ERR_NVS_VALUE_TOO_LONG: u32 = 4366;
pub const ESP_ERR_NVS_PART_NOT_FOUND: u32 = 4367;
pub const ESP_ERR_NVS_NEW_VERSION_FOUND: u32 = 4368;
pub const ESP_ERR_NVS_XTS_ENCR_FAILED: u32 = 4369;
pub const ESP_ERR_NVS_XTS_DECR_FAILED: u32 = 4370;
pub const ESP_ERR_NVS_XTS_CFG_FAILED: u32 = 4371;
pub const ESP_ERR_NVS_XTS_CFG_NOT_FOUND: u32 = 4372;
pub const ESP_ERR_NVS_ENCR_NOT_SUPPORTED: u32 = 4373;
pub const ESP_ERR_NVS_KEYS_NOT_INITIALIZED: u32 = 4374;
pub const ESP_ERR_NVS_CORRUPT_KEY_PART: u32 = 4375;
pub const ESP_ERR_NVS_CONTENT_DIFFERS: u32 = 4376;
pub const NVS_DEFAULT_PART_NAME: &'static [u8; 4usize] = b"nvs\0";
pub const ESP_ERR_FLASH_NOT_INITIALISED: u32 = 24579;
pub const ESP_ERR_FLASH_UNSUPPORTED_HOST: u32 = 24580;
pub const ESP_ERR_FLASH_UNSUPPORTED_CHIP: u32 = 24581;
pub const ESP_ERR_FLASH_PROTECTED: u32 = 24582;
pub const ESP_ERR_FLASH_OP_FAIL: u32 = 24577;
pub const ESP_ERR_FLASH_OP_TIMEOUT: u32 = 24578;
pub const SPI_FLASH_SEC_SIZE: u32 = 4096;
pub const SPI_FLASH_MMU_PAGE_SIZE: u32 = 65536;
pub const SPI_FLASH_CACHE2PHYS_FAIL: u32 = 4294967295;
pub const NVS_KEY_SIZE: u32 = 32;
pub const ESP_EVENT_ANY_ID: i32 = -1;
pub const WIFI_PROTOCOL_11B: u32 = 1;
pub const WIFI_PROTOCOL_11G: u32 = 2;
pub const WIFI_PROTOCOL_11N: u32 = 4;
pub const WIFI_PROTOCOL_LR: u32 = 8;
pub const ESP_WIFI_MAX_CONN_NUM: u32 = 10;
pub const WIFI_VENDOR_IE_ELEMENT_ID: u32 = 221;
pub const WIFI_PROMIS_FILTER_MASK_ALL: u32 = 4294967295;
pub const WIFI_PROMIS_FILTER_MASK_MGMT: u32 = 1;
pub const WIFI_PROMIS_FILTER_MASK_CTRL: u32 = 2;
pub const WIFI_PROMIS_FILTER_MASK_DATA: u32 = 4;
pub const WIFI_PROMIS_FILTER_MASK_MISC: u32 = 8;
pub const WIFI_PROMIS_FILTER_MASK_DATA_MPDU: u32 = 16;
pub const WIFI_PROMIS_FILTER_MASK_DATA_AMPDU: u32 = 32;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ALL: u32 = 4286578688;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_WRAPPER: u32 = 8388608;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BAR: u32 = 16777216;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BA: u32 = 33554432;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_PSPOLL: u32 = 67108864;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_RTS: u32 = 134217728;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CTS: u32 = 268435456;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ACK: u32 = 536870912;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFEND: u32 = 1073741824;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFENDACK: u32 = 2147483648;
pub const WIFI_EVENT_MASK_ALL: u32 = 4294967295;
pub const WIFI_EVENT_MASK_NONE: u32 = 0;
pub const DHCPS_COARSE_TIMER_SECS: u32 = 1;
pub const DHCPS_MAX_LEASE: u32 = 100;
pub const DHCPS_LEASE_TIME_DEF: u32 = 120;
pub const DHCPS_LEASE_UNIT: u32 = 60;
pub const IPSTR: &'static [u8; 12usize] = b"%d.%d.%d.%d\0";
pub const IPV6STR: &'static [u8; 40usize] = b"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\0";
pub const ESP_ERR_TCPIP_ADAPTER_BASE: u32 = 20480;
pub const ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS: u32 = 20481;
pub const ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY: u32 = 20482;
pub const ESP_ERR_TCPIP_ADAPTER_DHCPC_START_FAILED: u32 = 20483;
pub const ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED: u32 = 20484;
pub const ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STOPPED: u32 = 20485;
pub const ESP_ERR_TCPIP_ADAPTER_NO_MEM: u32 = 20486;
pub const ESP_ERR_TCPIP_ADAPTER_DHCP_NOT_STOPPED: u32 = 20487;
pub const TCPIP_HOSTNAME_MAX_SIZE: u32 = 32;
pub const LOG_LOCAL_LEVEL: u32 = 3;
pub const LOG_COLOR_BLACK: &'static [u8; 3usize] = b"30\0";
pub const LOG_COLOR_RED: &'static [u8; 3usize] = b"31\0";
pub const LOG_COLOR_GREEN: &'static [u8; 3usize] = b"32\0";
pub const LOG_COLOR_BROWN: &'static [u8; 3usize] = b"33\0";
pub const LOG_COLOR_BLUE: &'static [u8; 3usize] = b"34\0";
pub const LOG_COLOR_PURPLE: &'static [u8; 3usize] = b"35\0";
pub const LOG_COLOR_CYAN: &'static [u8; 3usize] = b"36\0";
pub const LOG_RESET_COLOR: &'static [u8; 5usize] = b"\x1B[0m\0";
pub const PTHREAD_STACK_MIN: u32 = 768;
pub const ESP_WIFI_CRYPTO_VERSION: u32 = 1;
pub const ESP_WIFI_OS_ADAPTER_VERSION: u32 = 4;
pub const ESP_WIFI_OS_ADAPTER_MAGIC: u32 = 3735928495;
pub const OSI_FUNCS_TIME_BLOCKING: u32 = 4294967295;
pub const OSI_QUEUE_SEND_FRONT: u32 = 0;
pub const OSI_QUEUE_SEND_BACK: u32 = 1;
pub const OSI_QUEUE_SEND_OVERWRITE: u32 = 2;
pub const ESP_ERR_WIFI_NOT_INIT: u32 = 12289;
pub const ESP_ERR_WIFI_NOT_STARTED: u32 = 12290;
pub const ESP_ERR_WIFI_NOT_STOPPED: u32 = 12291;
pub const ESP_ERR_WIFI_IF: u32 = 12292;
pub const ESP_ERR_WIFI_MODE: u32 = 12293;
pub const ESP_ERR_WIFI_STATE: u32 = 12294;
pub const ESP_ERR_WIFI_CONN: u32 = 12295;
pub const ESP_ERR_WIFI_NVS: u32 = 12296;
pub const ESP_ERR_WIFI_MAC: u32 = 12297;
pub const ESP_ERR_WIFI_SSID: u32 = 12298;
pub const ESP_ERR_WIFI_PASSWORD: u32 = 12299;
pub const ESP_ERR_WIFI_TIMEOUT: u32 = 12300;
pub const ESP_ERR_WIFI_WAKE_FAIL: u32 = 12301;
pub const ESP_ERR_WIFI_WOULD_BLOCK: u32 = 12302;
pub const ESP_ERR_WIFI_NOT_CONNECT: u32 = 12303;
pub const ESP_ERR_WIFI_POST: u32 = 12306;
pub const ESP_ERR_WIFI_INIT_STATE: u32 = 12307;
pub const ESP_ERR_WIFI_STOP_STATE: u32 = 12308;
pub const WIFI_STATIC_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const WIFI_CSI_ENABLED: u32 = 0;
pub const WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const WIFI_NVS_ENABLED: u32 = 1;
pub const WIFI_NANO_FORMAT_ENABLED: u32 = 0;
pub const WIFI_INIT_CONFIG_MAGIC: u32 = 523190095;
pub const WIFI_DEFAULT_TX_BA_WIN: u32 = 6;
pub const WIFI_DEFAULT_RX_BA_WIN: u32 = 6;
pub const WIFI_TASK_CORE_ID: u32 = 0;
pub const WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const GPIO_ID_PIN0: u32 = 0;
pub const GPIO_FUNC_IN_HIGH: u32 = 56;
pub const GPIO_FUNC_IN_LOW: u32 = 48;
pub const ESP_INTR_FLAG_LEVEL1: u32 = 2;
pub const ESP_INTR_FLAG_LEVEL2: u32 = 4;
pub const ESP_INTR_FLAG_LEVEL3: u32 = 8;
pub const ESP_INTR_FLAG_LEVEL4: u32 = 16;
pub const ESP_INTR_FLAG_LEVEL5: u32 = 32;
pub const ESP_INTR_FLAG_LEVEL6: u32 = 64;
pub const ESP_INTR_FLAG_NMI: u32 = 128;
pub const ESP_INTR_FLAG_SHARED: u32 = 256;
pub const ESP_INTR_FLAG_EDGE: u32 = 512;
pub const ESP_INTR_FLAG_IRAM: u32 = 1024;
pub const ESP_INTR_FLAG_INTRDISABLED: u32 = 2048;
pub const ESP_INTR_FLAG_LOWMED: u32 = 14;
pub const ESP_INTR_FLAG_HIGH: u32 = 240;
pub const ESP_INTR_FLAG_LEVELMASK: u32 = 254;
pub const ETS_INTERNAL_TIMER0_INTR_SOURCE: i32 = -1;
pub const ETS_INTERNAL_TIMER1_INTR_SOURCE: i32 = -2;
pub const ETS_INTERNAL_TIMER2_INTR_SOURCE: i32 = -3;
pub const ETS_INTERNAL_SW0_INTR_SOURCE: i32 = -4;
pub const ETS_INTERNAL_SW1_INTR_SOURCE: i32 = -5;
pub const ETS_INTERNAL_PROFILING_INTR_SOURCE: i32 = -6;
pub const ETS_INTERNAL_INTR_SOURCE_OFF: u32 = 6;
pub const GPIO_PIN_COUNT: u32 = 40;
pub const PRO_CPU_NUM: u32 = 0;
pub const APP_CPU_NUM: u32 = 1;
pub const SOC_IROM_LOW: u32 = 1074593792;
pub const SOC_IROM_HIGH: u32 = 1077936128;
pub const SOC_DROM_LOW: u32 = 1061158912;
pub const SOC_DROM_HIGH: u32 = 1065353216;
pub const SOC_DRAM_LOW: u32 = 1073405952;
pub const SOC_DRAM_HIGH: u32 = 1073741824;
pub const SOC_RTC_IRAM_LOW: u32 = 1074528256;
pub const SOC_RTC_IRAM_HIGH: u32 = 1074536448;
pub const SOC_RTC_DATA_LOW: u32 = 1342177280;
pub const SOC_RTC_DATA_HIGH: u32 = 1342185472;
pub const SOC_EXTRAM_DATA_LOW: u32 = 1065353216;
pub const SOC_EXTRAM_DATA_HIGH: u32 = 1069547520;
pub const SOC_MAX_CONTIGUOUS_RAM_SIZE: u32 = 4194304;
pub const DR_REG_DPORT_BASE: u32 = 1072693248;
pub const DR_REG_AES_BASE: u32 = 1072697344;
pub const DR_REG_RSA_BASE: u32 = 1072701440;
pub const DR_REG_SHA_BASE: u32 = 1072705536;
pub const DR_REG_FLASH_MMU_TABLE_PRO: u32 = 1072758784;
pub const DR_REG_FLASH_MMU_TABLE_APP: u32 = 1072766976;
pub const DR_REG_DPORT_END: u32 = 1072775164;
pub const DR_REG_UART_BASE: u32 = 1072955392;
pub const DR_REG_SPI1_BASE: u32 = 1072963584;
pub const DR_REG_SPI0_BASE: u32 = 1072967680;
pub const DR_REG_GPIO_BASE: u32 = 1072971776;
pub const DR_REG_GPIO_SD_BASE: u32 = 1072975616;
pub const DR_REG_FE2_BASE: u32 = 1072975872;
pub const DR_REG_FE_BASE: u32 = 1072979968;
pub const DR_REG_FRC_TIMER_BASE: u32 = 1072984064;
pub const DR_REG_RTCCNTL_BASE: u32 = 1072988160;
pub const DR_REG_RTCIO_BASE: u32 = 1072989184;
pub const DR_REG_SENS_BASE: u32 = 1072990208;
pub const DR_REG_RTC_I2C_BASE: u32 = 1072991232;
pub const DR_REG_IO_MUX_BASE: u32 = 1072992256;
pub const DR_REG_HINF_BASE: u32 = 1073000448;
pub const DR_REG_UHCI1_BASE: u32 = 1073004544;
pub const DR_REG_I2S_BASE: u32 = 1073016832;
pub const DR_REG_UART1_BASE: u32 = 1073020928;
pub const DR_REG_BT_BASE: u32 = 1073025024;
pub const DR_REG_I2C_EXT_BASE: u32 = 1073033216;
pub const DR_REG_UHCI0_BASE: u32 = 1073037312;
pub const DR_REG_SLCHOST_BASE: u32 = 1073041408;
pub const DR_REG_RMT_BASE: u32 = 1073045504;
pub const DR_REG_PCNT_BASE: u32 = 1073049600;
pub const DR_REG_SLC_BASE: u32 = 1073053696;
pub const DR_REG_LEDC_BASE: u32 = 1073057792;
pub const DR_REG_EFUSE_BASE: u32 = 1073061888;
pub const DR_REG_SPI_ENCRYPT_BASE: u32 = 1073065984;
pub const DR_REG_NRX_BASE: u32 = 1073073152;
pub const DR_REG_BB_BASE: u32 = 1073074176;
pub const DR_REG_PWM_BASE: u32 = 1073078272;
pub const DR_REG_TIMERGROUP0_BASE: u32 = 1073082368;
pub const DR_REG_TIMERGROUP1_BASE: u32 = 1073086464;
pub const DR_REG_RTCMEM0_BASE: u32 = 1073090560;
pub const DR_REG_RTCMEM1_BASE: u32 = 1073094656;
pub const DR_REG_RTCMEM2_BASE: u32 = 1073098752;
pub const DR_REG_SPI2_BASE: u32 = 1073102848;
pub const DR_REG_SPI3_BASE: u32 = 1073106944;
pub const DR_REG_SYSCON_BASE: u32 = 1073111040;
pub const DR_REG_APB_CTRL_BASE: u32 = 1073111040;
pub const DR_REG_I2C1_EXT_BASE: u32 = 1073115136;
pub const DR_REG_SDMMC_BASE: u32 = 1073119232;
pub const DR_REG_EMAC_BASE: u32 = 1073123328;
pub const DR_REG_CAN_BASE: u32 = 1073131520;
pub const DR_REG_PWM1_BASE: u32 = 1073135616;
pub const DR_REG_I2S1_BASE: u32 = 1073139712;
pub const DR_REG_UART2_BASE: u32 = 1073143808;
pub const DR_REG_PWM2_BASE: u32 = 1073147904;
pub const DR_REG_PWM3_BASE: u32 = 1073152000;
pub const PERIPHS_SPI_ENCRYPT_BASEADDR: u32 = 1073065984;
pub const APB_CLK_FREQ_ROM: u32 = 26000000;
pub const CPU_CLK_FREQ_ROM: u32 = 26000000;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const REF_CLK_FREQ: u32 = 1000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const WDT_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 5000000;
pub const SPI_CLK_DIV: u32 = 4;
pub const TICKS_PER_US_ROM: u32 = 26;
pub const GPIO_MATRIX_DELAY_NS: u32 = 25;
pub const SOC_IROM_MASK_LOW: u32 = 1073741824;
pub const SOC_IROM_MASK_HIGH: u32 = 1074200576;
pub const SOC_CACHE_PRO_LOW: u32 = 1074200576;
pub const SOC_CACHE_PRO_HIGH: u32 = 1074233344;
pub const SOC_CACHE_APP_LOW: u32 = 1074233344;
pub const SOC_CACHE_APP_HIGH: u32 = 1074266112;
pub const SOC_IRAM_LOW: u32 = 1074266112;
pub const SOC_IRAM_HIGH: u32 = 1074397184;
pub const SOC_RTC_DRAM_LOW: u32 = 1073217536;
pub const SOC_RTC_DRAM_HIGH: u32 = 1073225728;
pub const SOC_DIRAM_IRAM_LOW: u32 = 1074397184;
pub const SOC_DIRAM_IRAM_HIGH: u32 = 1074528252;
pub const SOC_DIRAM_DRAM_LOW: u32 = 1073610752;
pub const SOC_DIRAM_DRAM_HIGH: u32 = 1073741820;
pub const SOC_DMA_LOW: u32 = 1073405952;
pub const SOC_DMA_HIGH: u32 = 1073741824;
pub const SOC_BYTE_ACCESSIBLE_LOW: u32 = 1073283072;
pub const SOC_BYTE_ACCESSIBLE_HIGH: u32 = 1073741824;
pub const SOC_MEM_INTERNAL_LOW: u32 = 1073283072;
pub const SOC_MEM_INTERNAL_HIGH: u32 = 1074536448;
pub const ETS_WIFI_MAC_INTR_SOURCE: u32 = 0;
pub const ETS_WIFI_MAC_NMI_SOURCE: u32 = 1;
pub const ETS_WIFI_BB_INTR_SOURCE: u32 = 2;
pub const ETS_BT_MAC_INTR_SOURCE: u32 = 3;
pub const ETS_BT_BB_INTR_SOURCE: u32 = 4;
pub const ETS_BT_BB_NMI_SOURCE: u32 = 5;
pub const ETS_RWBT_INTR_SOURCE: u32 = 6;
pub const ETS_RWBLE_INTR_SOURCE: u32 = 7;
pub const ETS_RWBT_NMI_SOURCE: u32 = 8;
pub const ETS_RWBLE_NMI_SOURCE: u32 = 9;
pub const ETS_SLC0_INTR_SOURCE: u32 = 10;
pub const ETS_SLC1_INTR_SOURCE: u32 = 11;
pub const ETS_UHCI0_INTR_SOURCE: u32 = 12;
pub const ETS_UHCI1_INTR_SOURCE: u32 = 13;
pub const ETS_TG0_T0_LEVEL_INTR_SOURCE: u32 = 14;
pub const ETS_TG0_T1_LEVEL_INTR_SOURCE: u32 = 15;
pub const ETS_TG0_WDT_LEVEL_INTR_SOURCE: u32 = 16;
pub const ETS_TG0_LACT_LEVEL_INTR_SOURCE: u32 = 17;
pub const ETS_TG1_T0_LEVEL_INTR_SOURCE: u32 = 18;
pub const ETS_TG1_T1_LEVEL_INTR_SOURCE: u32 = 19;
pub const ETS_TG1_WDT_LEVEL_INTR_SOURCE: u32 = 20;
pub const ETS_TG1_LACT_LEVEL_INTR_SOURCE: u32 = 21;
pub const ETS_GPIO_INTR_SOURCE: u32 = 22;
pub const ETS_GPIO_NMI_SOURCE: u32 = 23;
pub const ETS_FROM_CPU_INTR0_SOURCE: u32 = 24;
pub const ETS_FROM_CPU_INTR1_SOURCE: u32 = 25;
pub const ETS_FROM_CPU_INTR2_SOURCE: u32 = 26;
pub const ETS_FROM_CPU_INTR3_SOURCE: u32 = 27;
pub const ETS_SPI0_INTR_SOURCE: u32 = 28;
pub const ETS_SPI1_INTR_SOURCE: u32 = 29;
pub const ETS_SPI2_INTR_SOURCE: u32 = 30;
pub const ETS_SPI3_INTR_SOURCE: u32 = 31;
pub const ETS_I2S0_INTR_SOURCE: u32 = 32;
pub const ETS_I2S1_INTR_SOURCE: u32 = 33;
pub const ETS_UART0_INTR_SOURCE: u32 = 34;
pub const ETS_UART1_INTR_SOURCE: u32 = 35;
pub const ETS_UART2_INTR_SOURCE: u32 = 36;
pub const ETS_SDIO_HOST_INTR_SOURCE: u32 = 37;
pub const ETS_ETH_MAC_INTR_SOURCE: u32 = 38;
pub const ETS_PWM0_INTR_SOURCE: u32 = 39;
pub const ETS_PWM1_INTR_SOURCE: u32 = 40;
pub const ETS_PWM2_INTR_SOURCE: u32 = 41;
pub const ETS_PWM3_INTR_SOURCE: u32 = 42;
pub const ETS_LEDC_INTR_SOURCE: u32 = 43;
pub const ETS_EFUSE_INTR_SOURCE: u32 = 44;
pub const ETS_CAN_INTR_SOURCE: u32 = 45;
pub const ETS_RTC_CORE_INTR_SOURCE: u32 = 46;
pub const ETS_RMT_INTR_SOURCE: u32 = 47;
pub const ETS_PCNT_INTR_SOURCE: u32 = 48;
pub const ETS_I2C_EXT0_INTR_SOURCE: u32 = 49;
pub const ETS_I2C_EXT1_INTR_SOURCE: u32 = 50;
pub const ETS_RSA_INTR_SOURCE: u32 = 51;
pub const ETS_SPI1_DMA_INTR_SOURCE: u32 = 52;
pub const ETS_SPI2_DMA_INTR_SOURCE: u32 = 53;
pub const ETS_SPI3_DMA_INTR_SOURCE: u32 = 54;
pub const ETS_WDT_INTR_SOURCE: u32 = 55;
pub const ETS_TIMER1_INTR_SOURCE: u32 = 56;
pub const ETS_TIMER2_INTR_SOURCE: u32 = 57;
pub const ETS_TG0_T0_EDGE_INTR_SOURCE: u32 = 58;
pub const ETS_TG0_T1_EDGE_INTR_SOURCE: u32 = 59;
pub const ETS_TG0_WDT_EDGE_INTR_SOURCE: u32 = 60;
pub const ETS_TG0_LACT_EDGE_INTR_SOURCE: u32 = 61;
pub const ETS_TG1_T0_EDGE_INTR_SOURCE: u32 = 62;
pub const ETS_TG1_T1_EDGE_INTR_SOURCE: u32 = 63;
pub const ETS_TG1_WDT_EDGE_INTR_SOURCE: u32 = 64;
pub const ETS_TG1_LACT_EDGE_INTR_SOURCE: u32 = 65;
pub const ETS_MMU_IA_INTR_SOURCE: u32 = 66;
pub const ETS_MPU_IA_INTR_SOURCE: u32 = 67;
pub const ETS_CACHE_IA_INTR_SOURCE: u32 = 68;
pub const ETS_WMAC_INUM: u32 = 0;
pub const ETS_BT_HOST_INUM: u32 = 1;
pub const ETS_WBB_INUM: u32 = 4;
pub const ETS_TG0_T1_INUM: u32 = 10;
pub const ETS_FRC1_INUM: u32 = 22;
pub const ETS_T1_WDT_INUM: u32 = 24;
pub const ETS_CACHEERR_INUM: u32 = 25;
pub const ETS_DPORT_INUM: u32 = 28;
pub const ETS_SLC_INUM: u32 = 1;
pub const ETS_UART0_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_INVALID_INUM: u32 = 6;
pub const SLP_OE_V: u32 = 1;
pub const SLP_OE_S: u32 = 0;
pub const SLP_SEL_V: u32 = 1;
pub const SLP_SEL_S: u32 = 1;
pub const SLP_PD_V: u32 = 1;
pub const SLP_PD_S: u32 = 2;
pub const SLP_PU_V: u32 = 1;
pub const SLP_PU_S: u32 = 3;
pub const SLP_IE_V: u32 = 1;
pub const SLP_IE_S: u32 = 4;
pub const SLP_DRV: u32 = 3;
pub const SLP_DRV_V: u32 = 3;
pub const SLP_DRV_S: u32 = 5;
pub const FUN_PD_V: u32 = 1;
pub const FUN_PD_S: u32 = 7;
pub const FUN_PU_V: u32 = 1;
pub const FUN_PU_S: u32 = 8;
pub const FUN_IE_V: u32 = 1;
pub const FUN_IE_S: u32 = 9;
pub const FUN_DRV: u32 = 3;
pub const FUN_DRV_V: u32 = 3;
pub const FUN_DRV_S: u32 = 10;
pub const MCU_SEL: u32 = 7;
pub const MCU_SEL_V: u32 = 7;
pub const MCU_SEL_S: u32 = 12;
pub const PIN_FUNC_GPIO: u32 = 2;
pub const PIN_CTRL: u32 = 1072992256;
pub const CLK_OUT3: u32 = 15;
pub const CLK_OUT3_V: u32 = 15;
pub const CLK_OUT3_S: u32 = 8;
pub const CLK_OUT3_M: u32 = 3840;
pub const CLK_OUT2: u32 = 15;
pub const CLK_OUT2_V: u32 = 15;
pub const CLK_OUT2_S: u32 = 4;
pub const CLK_OUT2_M: u32 = 240;
pub const CLK_OUT1: u32 = 15;
pub const CLK_OUT1_V: u32 = 15;
pub const CLK_OUT1_S: u32 = 0;
pub const CLK_OUT1_M: u32 = 15;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1072992324;
pub const IO_MUX_GPIO0_REG: u32 = 1072992324;
pub const FUNC_GPIO0_EMAC_TX_CLK: u32 = 5;
pub const FUNC_GPIO0_GPIO0: u32 = 2;
pub const FUNC_GPIO0_CLK_OUT1: u32 = 1;
pub const FUNC_GPIO0_GPIO0_0: u32 = 0;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1072992392;
pub const IO_MUX_GPIO1_REG: u32 = 1072992392;
pub const FUNC_U0TXD_EMAC_RXD2: u32 = 5;
pub const FUNC_U0TXD_GPIO1: u32 = 2;
pub const FUNC_U0TXD_CLK_OUT3: u32 = 1;
pub const FUNC_U0TXD_U0TXD: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1072992320;
pub const IO_MUX_GPIO2_REG: u32 = 1072992320;
pub const FUNC_GPIO2_SD_DATA0: u32 = 4;
pub const FUNC_GPIO2_HS2_DATA0: u32 = 3;
pub const FUNC_GPIO2_GPIO2: u32 = 2;
pub const FUNC_GPIO2_HSPIWP: u32 = 1;
pub const FUNC_GPIO2_GPIO2_0: u32 = 0;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1072992388;
pub const IO_MUX_GPIO3_REG: u32 = 1072992388;
pub const FUNC_U0RXD_GPIO3: u32 = 2;
pub const FUNC_U0RXD_CLK_OUT2: u32 = 1;
pub const FUNC_U0RXD_U0RXD: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1072992328;
pub const IO_MUX_GPIO4_REG: u32 = 1072992328;
pub const FUNC_GPIO4_EMAC_TX_ER: u32 = 5;
pub const FUNC_GPIO4_SD_DATA1: u32 = 4;
pub const FUNC_GPIO4_HS2_DATA1: u32 = 3;
pub const FUNC_GPIO4_GPIO4: u32 = 2;
pub const FUNC_GPIO4_HSPIHD: u32 = 1;
pub const FUNC_GPIO4_GPIO4_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1072992364;
pub const IO_MUX_GPIO5_REG: u32 = 1072992364;
pub const FUNC_GPIO5_EMAC_RX_CLK: u32 = 5;
pub const FUNC_GPIO5_HS1_DATA6: u32 = 3;
pub const FUNC_GPIO5_GPIO5: u32 = 2;
pub const FUNC_GPIO5_VSPICS0: u32 = 1;
pub const FUNC_GPIO5_GPIO5_0: u32 = 0;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1072992352;
pub const IO_MUX_GPIO6_REG: u32 = 1072992352;
pub const FUNC_SD_CLK_U1CTS: u32 = 4;
pub const FUNC_SD_CLK_HS1_CLK: u32 = 3;
pub const FUNC_SD_CLK_GPIO6: u32 = 2;
pub const FUNC_SD_CLK_SPICLK: u32 = 1;
pub const FUNC_SD_CLK_SD_CLK: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1072992356;
pub const IO_MUX_GPIO7_REG: u32 = 1072992356;
pub const FUNC_SD_DATA0_U2RTS: u32 = 4;
pub const FUNC_SD_DATA0_HS1_DATA0: u32 = 3;
pub const FUNC_SD_DATA0_GPIO7: u32 = 2;
pub const FUNC_SD_DATA0_SPIQ: u32 = 1;
pub const FUNC_SD_DATA0_SD_DATA0: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1072992360;
pub const IO_MUX_GPIO8_REG: u32 = 1072992360;
pub const FUNC_SD_DATA1_U2CTS: u32 = 4;
pub const FUNC_SD_DATA1_HS1_DATA1: u32 = 3;
pub const FUNC_SD_DATA1_GPIO8: u32 = 2;
pub const FUNC_SD_DATA1_SPID: u32 = 1;
pub const FUNC_SD_DATA1_SD_DATA1: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1072992340;
pub const IO_MUX_GPIO9_REG: u32 = 1072992340;
pub const FUNC_SD_DATA2_U1RXD: u32 = 4;
pub const FUNC_SD_DATA2_HS1_DATA2: u32 = 3;
pub const FUNC_SD_DATA2_GPIO9: u32 = 2;
pub const FUNC_SD_DATA2_SPIHD: u32 = 1;
pub const FUNC_SD_DATA2_SD_DATA2: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1072992344;
pub const IO_MUX_GPIO10_REG: u32 = 1072992344;
pub const FUNC_SD_DATA3_U1TXD: u32 = 4;
pub const FUNC_SD_DATA3_HS1_DATA3: u32 = 3;
pub const FUNC_SD_DATA3_GPIO10: u32 = 2;
pub const FUNC_SD_DATA3_SPIWP: u32 = 1;
pub const FUNC_SD_DATA3_SD_DATA3: u32 = 0;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1072992348;
pub const IO_MUX_GPIO11_REG: u32 = 1072992348;
pub const FUNC_SD_CMD_U1RTS: u32 = 4;
pub const FUNC_SD_CMD_HS1_CMD: u32 = 3;
pub const FUNC_SD_CMD_GPIO11: u32 = 2;
pub const FUNC_SD_CMD_SPICS0: u32 = 1;
pub const FUNC_SD_CMD_SD_CMD: u32 = 0;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1072992308;
pub const IO_MUX_GPIO12_REG: u32 = 1072992308;
pub const FUNC_MTDI_EMAC_TXD3: u32 = 5;
pub const FUNC_MTDI_SD_DATA2: u32 = 4;
pub const FUNC_MTDI_HS2_DATA2: u32 = 3;
pub const FUNC_MTDI_GPIO12: u32 = 2;
pub const FUNC_MTDI_HSPIQ: u32 = 1;
pub const FUNC_MTDI_MTDI: u32 = 0;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1072992312;
pub const IO_MUX_GPIO13_REG: u32 = 1072992312;
pub const FUNC_MTCK_EMAC_RX_ER: u32 = 5;
pub const FUNC_MTCK_SD_DATA3: u32 = 4;
pub const FUNC_MTCK_HS2_DATA3: u32 = 3;
pub const FUNC_MTCK_GPIO13: u32 = 2;
pub const FUNC_MTCK_HSPID: u32 = 1;
pub const FUNC_MTCK_MTCK: u32 = 0;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1072992304;
pub const IO_MUX_GPIO14_REG: u32 = 1072992304;
pub const FUNC_MTMS_EMAC_TXD2: u32 = 5;
pub const FUNC_MTMS_SD_CLK: u32 = 4;
pub const FUNC_MTMS_HS2_CLK: u32 = 3;
pub const FUNC_MTMS_GPIO14: u32 = 2;
pub const FUNC_MTMS_HSPICLK: u32 = 1;
pub const FUNC_MTMS_MTMS: u32 = 0;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1072992316;
pub const IO_MUX_GPIO15_REG: u32 = 1072992316;
pub const FUNC_MTDO_EMAC_RXD3: u32 = 5;
pub const FUNC_MTDO_SD_CMD: u32 = 4;
pub const FUNC_MTDO_HS2_CMD: u32 = 3;
pub const FUNC_MTDO_GPIO15: u32 = 2;
pub const FUNC_MTDO_HSPICS0: u32 = 1;
pub const FUNC_MTDO_MTDO: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO16_U: u32 = 1072992332;
pub const IO_MUX_GPIO16_REG: u32 = 1072992332;
pub const FUNC_GPIO16_EMAC_CLK_OUT: u32 = 5;
pub const FUNC_GPIO16_U2RXD: u32 = 4;
pub const FUNC_GPIO16_HS1_DATA4: u32 = 3;
pub const FUNC_GPIO16_GPIO16: u32 = 2;
pub const FUNC_GPIO16_GPIO16_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO17_U: u32 = 1072992336;
pub const IO_MUX_GPIO17_REG: u32 = 1072992336;
pub const FUNC_GPIO17_EMAC_CLK_OUT_180: u32 = 5;
pub const FUNC_GPIO17_U2TXD: u32 = 4;
pub const FUNC_GPIO17_HS1_DATA5: u32 = 3;
pub const FUNC_GPIO17_GPIO17: u32 = 2;
pub const FUNC_GPIO17_GPIO17_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO18_U: u32 = 1072992368;
pub const IO_MUX_GPIO18_REG: u32 = 1072992368;
pub const FUNC_GPIO18_HS1_DATA7: u32 = 3;
pub const FUNC_GPIO18_GPIO18: u32 = 2;
pub const FUNC_GPIO18_VSPICLK: u32 = 1;
pub const FUNC_GPIO18_GPIO18_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO19_U: u32 = 1072992372;
pub const IO_MUX_GPIO19_REG: u32 = 1072992372;
pub const FUNC_GPIO19_EMAC_TXD0: u32 = 5;
pub const FUNC_GPIO19_U0CTS: u32 = 3;
pub const FUNC_GPIO19_GPIO19: u32 = 2;
pub const FUNC_GPIO19_VSPIQ: u32 = 1;
pub const FUNC_GPIO19_GPIO19_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO20_U: u32 = 1072992376;
pub const IO_MUX_GPIO20_REG: u32 = 1072992376;
pub const FUNC_GPIO20_GPIO20: u32 = 2;
pub const FUNC_GPIO20_GPIO20_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO21_U: u32 = 1072992380;
pub const IO_MUX_GPIO21_REG: u32 = 1072992380;
pub const FUNC_GPIO21_EMAC_TX_EN: u32 = 5;
pub const FUNC_GPIO21_GPIO21: u32 = 2;
pub const FUNC_GPIO21_VSPIHD: u32 = 1;
pub const FUNC_GPIO21_GPIO21_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO22_U: u32 = 1072992384;
pub const IO_MUX_GPIO22_REG: u32 = 1072992384;
pub const FUNC_GPIO22_EMAC_TXD1: u32 = 5;
pub const FUNC_GPIO22_U0RTS: u32 = 3;
pub const FUNC_GPIO22_GPIO22: u32 = 2;
pub const FUNC_GPIO22_VSPIWP: u32 = 1;
pub const FUNC_GPIO22_GPIO22_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO23_U: u32 = 1072992396;
pub const IO_MUX_GPIO23_REG: u32 = 1072992396;
pub const FUNC_GPIO23_HS1_STROBE: u32 = 3;
pub const FUNC_GPIO23_GPIO23: u32 = 2;
pub const FUNC_GPIO23_VSPID: u32 = 1;
pub const FUNC_GPIO23_GPIO23_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO24_U: u32 = 1072992400;
pub const IO_MUX_GPIO24_REG: u32 = 1072992400;
pub const FUNC_GPIO24_GPIO24: u32 = 2;
pub const FUNC_GPIO24_GPIO24_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO25_U: u32 = 1072992292;
pub const IO_MUX_GPIO25_REG: u32 = 1072992292;
pub const FUNC_GPIO25_EMAC_RXD0: u32 = 5;
pub const FUNC_GPIO25_GPIO25: u32 = 2;
pub const FUNC_GPIO25_GPIO25_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO26_U: u32 = 1072992296;
pub const IO_MUX_GPIO26_REG: u32 = 1072992296;
pub const FUNC_GPIO26_EMAC_RXD1: u32 = 5;
pub const FUNC_GPIO26_GPIO26: u32 = 2;
pub const FUNC_GPIO26_GPIO26_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO27_U: u32 = 1072992300;
pub const IO_MUX_GPIO27_REG: u32 = 1072992300;
pub const FUNC_GPIO27_EMAC_RX_DV: u32 = 5;
pub const FUNC_GPIO27_GPIO27: u32 = 2;
pub const FUNC_GPIO27_GPIO27_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO32_U: u32 = 1072992284;
pub const IO_MUX_GPIO32_REG: u32 = 1072992284;
pub const FUNC_GPIO32_GPIO32: u32 = 2;
pub const FUNC_GPIO32_GPIO32_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO33_U: u32 = 1072992288;
pub const IO_MUX_GPIO33_REG: u32 = 1072992288;
pub const FUNC_GPIO33_GPIO33: u32 = 2;
pub const FUNC_GPIO33_GPIO33_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO34_U: u32 = 1072992276;
pub const IO_MUX_GPIO34_REG: u32 = 1072992276;
pub const FUNC_GPIO34_GPIO34: u32 = 2;
pub const FUNC_GPIO34_GPIO34_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO35_U: u32 = 1072992280;
pub const IO_MUX_GPIO35_REG: u32 = 1072992280;
pub const FUNC_GPIO35_GPIO35: u32 = 2;
pub const FUNC_GPIO35_GPIO35_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO36_U: u32 = 1072992260;
pub const IO_MUX_GPIO36_REG: u32 = 1072992260;
pub const FUNC_GPIO36_GPIO36: u32 = 2;
pub const FUNC_GPIO36_GPIO36_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO37_U: u32 = 1072992264;
pub const IO_MUX_GPIO37_REG: u32 = 1072992264;
pub const FUNC_GPIO37_GPIO37: u32 = 2;
pub const FUNC_GPIO37_GPIO37_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO38_U: u32 = 1072992268;
pub const IO_MUX_GPIO38_REG: u32 = 1072992268;
pub const FUNC_GPIO38_GPIO38: u32 = 2;
pub const FUNC_GPIO38_GPIO38_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO39_U: u32 = 1072992272;
pub const IO_MUX_GPIO39_REG: u32 = 1072992272;
pub const FUNC_GPIO39_GPIO39: u32 = 2;
pub const FUNC_GPIO39_GPIO39_0: u32 = 0;
pub const GPIO_BT_SELECT_REG: u32 = 1072971776;
pub const GPIO_BT_SEL: u32 = 4294967295;
pub const GPIO_BT_SEL_V: u32 = 4294967295;
pub const GPIO_BT_SEL_S: u32 = 0;
pub const GPIO_OUT_REG: u32 = 1072971780;
pub const GPIO_OUT_DATA: u32 = 4294967295;
pub const GPIO_OUT_DATA_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_S: u32 = 0;
pub const GPIO_OUT_W1TS_REG: u32 = 1072971784;
pub const GPIO_OUT_DATA_W1TS: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TS_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT_W1TC_REG: u32 = 1072971788;
pub const GPIO_OUT_DATA_W1TC: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TC_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TC_S: u32 = 0;
pub const GPIO_OUT1_REG: u32 = 1072971792;
pub const GPIO_OUT1_DATA: u32 = 255;
pub const GPIO_OUT1_DATA_V: u32 = 255;
pub const GPIO_OUT1_DATA_S: u32 = 0;
pub const GPIO_OUT1_W1TS_REG: u32 = 1072971796;
pub const GPIO_OUT1_DATA_W1TS: u32 = 255;
pub const GPIO_OUT1_DATA_W1TS_V: u32 = 255;
pub const GPIO_OUT1_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT1_W1TC_REG: u32 = 1072971800;
pub const GPIO_OUT1_DATA_W1TC: u32 = 255;
pub const GPIO_OUT1_DATA_W1TC_V: u32 = 255;
pub const GPIO_OUT1_DATA_W1TC_S: u32 = 0;
pub const GPIO_SDIO_SELECT_REG: u32 = 1072971804;
pub const GPIO_SDIO_SEL: u32 = 255;
pub const GPIO_SDIO_SEL_V: u32 = 255;
pub const GPIO_SDIO_SEL_S: u32 = 0;
pub const GPIO_ENABLE_REG: u32 = 1072971808;
pub const GPIO_ENABLE_DATA: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_S: u32 = 0;
pub const GPIO_ENABLE_W1TS_REG: u32 = 1072971812;
pub const GPIO_ENABLE_DATA_W1TS: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TS_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TS_S: u32 = 0;
pub const GPIO_ENABLE_W1TC_REG: u32 = 1072971816;
pub const GPIO_ENABLE_DATA_W1TC: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TC_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TC_S: u32 = 0;
pub const GPIO_ENABLE1_REG: u32 = 1072971820;
pub const GPIO_ENABLE1_DATA: u32 = 255;
pub const GPIO_ENABLE1_DATA_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_S: u32 = 0;
pub const GPIO_ENABLE1_W1TS_REG: u32 = 1072971824;
pub const GPIO_ENABLE1_DATA_W1TS: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TS_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TS_S: u32 = 0;
pub const GPIO_ENABLE1_W1TC_REG: u32 = 1072971828;
pub const GPIO_ENABLE1_DATA_W1TC: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TC_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TC_S: u32 = 0;
pub const GPIO_STRAP_REG: u32 = 1072971832;
pub const GPIO_STRAPPING: u32 = 65535;
pub const GPIO_STRAPPING_V: u32 = 65535;
pub const GPIO_STRAPPING_S: u32 = 0;
pub const GPIO_IN_REG: u32 = 1072971836;
pub const GPIO_IN_DATA: u32 = 4294967295;
pub const GPIO_IN_DATA_V: u32 = 4294967295;
pub const GPIO_IN_DATA_S: u32 = 0;
pub const GPIO_IN1_REG: u32 = 1072971840;
pub const GPIO_IN1_DATA: u32 = 255;
pub const GPIO_IN1_DATA_V: u32 = 255;
pub const GPIO_IN1_DATA_S: u32 = 0;
pub const GPIO_STATUS_REG: u32 = 1072971844;
pub const GPIO_STATUS_INT: u32 = 4294967295;
pub const GPIO_STATUS_INT_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_S: u32 = 0;
pub const GPIO_STATUS_W1TS_REG: u32 = 1072971848;
pub const GPIO_STATUS_INT_W1TS: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TS_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TS_S: u32 = 0;
pub const GPIO_STATUS_W1TC_REG: u32 = 1072971852;
pub const GPIO_STATUS_INT_W1TC: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TC_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TC_S: u32 = 0;
pub const GPIO_STATUS1_REG: u32 = 1072971856;
pub const GPIO_STATUS1_INT: u32 = 255;
pub const GPIO_STATUS1_INT_V: u32 = 255;
pub const GPIO_STATUS1_INT_S: u32 = 0;
pub const GPIO_STATUS1_W1TS_REG: u32 = 1072971860;
pub const GPIO_STATUS1_INT_W1TS: u32 = 255;
pub const GPIO_STATUS1_INT_W1TS_V: u32 = 255;
pub const GPIO_STATUS1_INT_W1TS_S: u32 = 0;
pub const GPIO_STATUS1_W1TC_REG: u32 = 1072971864;
pub const GPIO_STATUS1_INT_W1TC: u32 = 255;
pub const GPIO_STATUS1_INT_W1TC_V: u32 = 255;
pub const GPIO_STATUS1_INT_W1TC_S: u32 = 0;
pub const GPIO_ACPU_INT_REG: u32 = 1072971872;
pub const GPIO_APPCPU_INT: u32 = 4294967295;
pub const GPIO_APPCPU_INT_V: u32 = 4294967295;
pub const GPIO_APPCPU_INT_S: u32 = 0;
pub const GPIO_ACPU_NMI_INT_REG: u32 = 1072971876;
pub const GPIO_APPCPU_NMI_INT: u32 = 4294967295;
pub const GPIO_APPCPU_NMI_INT_V: u32 = 4294967295;
pub const GPIO_APPCPU_NMI_INT_S: u32 = 0;
pub const GPIO_PCPU_INT_REG: u32 = 1072971880;
pub const GPIO_PROCPU_INT: u32 = 4294967295;
pub const GPIO_PROCPU_INT_V: u32 = 4294967295;
pub const GPIO_PROCPU_INT_S: u32 = 0;
pub const GPIO_PCPU_NMI_INT_REG: u32 = 1072971884;
pub const GPIO_PROCPU_NMI_INT: u32 = 4294967295;
pub const GPIO_PROCPU_NMI_INT_V: u32 = 4294967295;
pub const GPIO_PROCPU_NMI_INT_S: u32 = 0;
pub const GPIO_CPUSDIO_INT_REG: u32 = 1072971888;
pub const GPIO_SDIO_INT: u32 = 4294967295;
pub const GPIO_SDIO_INT_V: u32 = 4294967295;
pub const GPIO_SDIO_INT_S: u32 = 0;
pub const GPIO_ACPU_INT1_REG: u32 = 1072971892;
pub const GPIO_APPCPU_INT_H: u32 = 255;
pub const GPIO_APPCPU_INT_H_V: u32 = 255;
pub const GPIO_APPCPU_INT_H_S: u32 = 0;
pub const GPIO_ACPU_NMI_INT1_REG: u32 = 1072971896;
pub const GPIO_APPCPU_NMI_INT_H: u32 = 255;
pub const GPIO_APPCPU_NMI_INT_H_V: u32 = 255;
pub const GPIO_APPCPU_NMI_INT_H_S: u32 = 0;
pub const GPIO_PCPU_INT1_REG: u32 = 1072971900;
pub const GPIO_PROCPU_INT_H: u32 = 255;
pub const GPIO_PROCPU_INT_H_V: u32 = 255;
pub const GPIO_PROCPU_INT_H_S: u32 = 0;
pub const GPIO_PCPU_NMI_INT1_REG: u32 = 1072971904;
pub const GPIO_PROCPU_NMI_INT_H: u32 = 255;
pub const GPIO_PROCPU_NMI_INT_H_V: u32 = 255;
pub const GPIO_PROCPU_NMI_INT_H_S: u32 = 0;
pub const GPIO_CPUSDIO_INT1_REG: u32 = 1072971908;
pub const GPIO_SDIO_INT_H: u32 = 255;
pub const GPIO_SDIO_INT_H_V: u32 = 255;
pub const GPIO_SDIO_INT_H_S: u32 = 0;
pub const GPIO_PIN_INT_ENA: u32 = 31;
pub const GPIO_PIN_INT_ENA_V: u32 = 31;
pub const GPIO_PIN_INT_ENA_S: u32 = 13;
pub const GPIO_PIN_CONFIG: u32 = 3;
pub const GPIO_PIN_CONFIG_V: u32 = 3;
pub const GPIO_PIN_CONFIG_S: u32 = 11;
pub const GPIO_PIN_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN_INT_TYPE: u32 = 7;
pub const GPIO_PIN_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN0_REG: u32 = 1072971912;
pub const GPIO_PIN0_INT_ENA: u32 = 31;
pub const GPIO_PIN0_INT_ENA_V: u32 = 31;
pub const GPIO_PIN0_INT_ENA_S: u32 = 13;
pub const GPIO_PIN0_CONFIG: u32 = 3;
pub const GPIO_PIN0_CONFIG_V: u32 = 3;
pub const GPIO_PIN0_CONFIG_S: u32 = 11;
pub const GPIO_PIN0_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN0_INT_TYPE: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN0_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN0_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN1_REG: u32 = 1072971916;
pub const GPIO_PIN1_INT_ENA: u32 = 31;
pub const GPIO_PIN1_INT_ENA_V: u32 = 31;
pub const GPIO_PIN1_INT_ENA_S: u32 = 13;
pub const GPIO_PIN1_CONFIG: u32 = 3;
pub const GPIO_PIN1_CONFIG_V: u32 = 3;
pub const GPIO_PIN1_CONFIG_S: u32 = 11;
pub const GPIO_PIN1_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN1_INT_TYPE: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN1_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN1_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN2_REG: u32 = 1072971920;
pub const GPIO_PIN2_INT_ENA: u32 = 31;
pub const GPIO_PIN2_INT_ENA_V: u32 = 31;
pub const GPIO_PIN2_INT_ENA_S: u32 = 13;
pub const GPIO_PIN2_CONFIG: u32 = 3;
pub const GPIO_PIN2_CONFIG_V: u32 = 3;
pub const GPIO_PIN2_CONFIG_S: u32 = 11;
pub const GPIO_PIN2_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN2_INT_TYPE: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN2_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN2_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN3_REG: u32 = 1072971924;
pub const GPIO_PIN3_INT_ENA: u32 = 31;
pub const GPIO_PIN3_INT_ENA_V: u32 = 31;
pub const GPIO_PIN3_INT_ENA_S: u32 = 13;
pub const GPIO_PIN3_CONFIG: u32 = 3;
pub const GPIO_PIN3_CONFIG_V: u32 = 3;
pub const GPIO_PIN3_CONFIG_S: u32 = 11;
pub const GPIO_PIN3_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN3_INT_TYPE: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN3_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN3_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN4_REG: u32 = 1072971928;
pub const GPIO_PIN4_INT_ENA: u32 = 31;
pub const GPIO_PIN4_INT_ENA_V: u32 = 31;
pub const GPIO_PIN4_INT_ENA_S: u32 = 13;
pub const GPIO_PIN4_CONFIG: u32 = 3;
pub const GPIO_PIN4_CONFIG_V: u32 = 3;
pub const GPIO_PIN4_CONFIG_S: u32 = 11;
pub const GPIO_PIN4_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN4_INT_TYPE: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN4_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN4_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN5_REG: u32 = 1072971932;
pub const GPIO_PIN5_INT_ENA: u32 = 31;
pub const GPIO_PIN5_INT_ENA_V: u32 = 31;
pub const GPIO_PIN5_INT_ENA_S: u32 = 13;
pub const GPIO_PIN5_CONFIG: u32 = 3;
pub const GPIO_PIN5_CONFIG_V: u32 = 3;
pub const GPIO_PIN5_CONFIG_S: u32 = 11;
pub const GPIO_PIN5_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN5_INT_TYPE: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN5_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN5_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN6_REG: u32 = 1072971936;
pub const GPIO_PIN6_INT_ENA: u32 = 31;
pub const GPIO_PIN6_INT_ENA_V: u32 = 31;
pub const GPIO_PIN6_INT_ENA_S: u32 = 13;
pub const GPIO_PIN6_CONFIG: u32 = 3;
pub const GPIO_PIN6_CONFIG_V: u32 = 3;
pub const GPIO_PIN6_CONFIG_S: u32 = 11;
pub const GPIO_PIN6_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN6_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN6_INT_TYPE: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN6_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN6_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN7_REG: u32 = 1072971940;
pub const GPIO_PIN7_INT_ENA: u32 = 31;
pub const GPIO_PIN7_INT_ENA_V: u32 = 31;
pub const GPIO_PIN7_INT_ENA_S: u32 = 13;
pub const GPIO_PIN7_CONFIG: u32 = 3;
pub const GPIO_PIN7_CONFIG_V: u32 = 3;
pub const GPIO_PIN7_CONFIG_S: u32 = 11;
pub const GPIO_PIN7_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN7_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN7_INT_TYPE: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN7_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN7_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN8_REG: u32 = 1072971944;
pub const GPIO_PIN8_INT_ENA: u32 = 31;
pub const GPIO_PIN8_INT_ENA_V: u32 = 31;
pub const GPIO_PIN8_INT_ENA_S: u32 = 13;
pub const GPIO_PIN8_CONFIG: u32 = 3;
pub const GPIO_PIN8_CONFIG_V: u32 = 3;
pub const GPIO_PIN8_CONFIG_S: u32 = 11;
pub const GPIO_PIN8_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN8_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN8_INT_TYPE: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN8_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN8_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN9_REG: u32 = 1072971948;
pub const GPIO_PIN9_INT_ENA: u32 = 31;
pub const GPIO_PIN9_INT_ENA_V: u32 = 31;
pub const GPIO_PIN9_INT_ENA_S: u32 = 13;
pub const GPIO_PIN9_CONFIG: u32 = 3;
pub const GPIO_PIN9_CONFIG_V: u32 = 3;
pub const GPIO_PIN9_CONFIG_S: u32 = 11;
pub const GPIO_PIN9_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN9_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN9_INT_TYPE: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN9_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN9_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN10_REG: u32 = 1072971952;
pub const GPIO_PIN10_INT_ENA: u32 = 31;
pub const GPIO_PIN10_INT_ENA_V: u32 = 31;
pub const GPIO_PIN10_INT_ENA_S: u32 = 13;
pub const GPIO_PIN10_CONFIG: u32 = 3;
pub const GPIO_PIN10_CONFIG_V: u32 = 3;
pub const GPIO_PIN10_CONFIG_S: u32 = 11;
pub const GPIO_PIN10_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN10_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN10_INT_TYPE: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN10_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN10_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN11_REG: u32 = 1072971956;
pub const GPIO_PIN11_INT_ENA: u32 = 31;
pub const GPIO_PIN11_INT_ENA_V: u32 = 31;
pub const GPIO_PIN11_INT_ENA_S: u32 = 13;
pub const GPIO_PIN11_CONFIG: u32 = 3;
pub const GPIO_PIN11_CONFIG_V: u32 = 3;
pub const GPIO_PIN11_CONFIG_S: u32 = 11;
pub const GPIO_PIN11_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN11_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN11_INT_TYPE: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN11_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN11_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN12_REG: u32 = 1072971960;
pub const GPIO_PIN12_INT_ENA: u32 = 31;
pub const GPIO_PIN12_INT_ENA_V: u32 = 31;
pub const GPIO_PIN12_INT_ENA_S: u32 = 13;
pub const GPIO_PIN12_CONFIG: u32 = 3;
pub const GPIO_PIN12_CONFIG_V: u32 = 3;
pub const GPIO_PIN12_CONFIG_S: u32 = 11;
pub const GPIO_PIN12_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN12_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN12_INT_TYPE: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN12_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN12_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN13_REG: u32 = 1072971964;
pub const GPIO_PIN13_INT_ENA: u32 = 31;
pub const GPIO_PIN13_INT_ENA_V: u32 = 31;
pub const GPIO_PIN13_INT_ENA_S: u32 = 13;
pub const GPIO_PIN13_CONFIG: u32 = 3;
pub const GPIO_PIN13_CONFIG_V: u32 = 3;
pub const GPIO_PIN13_CONFIG_S: u32 = 11;
pub const GPIO_PIN13_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN13_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN13_INT_TYPE: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN13_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN13_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN14_REG: u32 = 1072971968;
pub const GPIO_PIN14_INT_ENA: u32 = 31;
pub const GPIO_PIN14_INT_ENA_V: u32 = 31;
pub const GPIO_PIN14_INT_ENA_S: u32 = 13;
pub const GPIO_PIN14_CONFIG: u32 = 3;
pub const GPIO_PIN14_CONFIG_V: u32 = 3;
pub const GPIO_PIN14_CONFIG_S: u32 = 11;
pub const GPIO_PIN14_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN14_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN14_INT_TYPE: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN14_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN14_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN15_REG: u32 = 1072971972;
pub const GPIO_PIN15_INT_ENA: u32 = 31;
pub const GPIO_PIN15_INT_ENA_V: u32 = 31;
pub const GPIO_PIN15_INT_ENA_S: u32 = 13;
pub const GPIO_PIN15_CONFIG: u32 = 3;
pub const GPIO_PIN15_CONFIG_V: u32 = 3;
pub const GPIO_PIN15_CONFIG_S: u32 = 11;
pub const GPIO_PIN15_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN15_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN15_INT_TYPE: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN15_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN15_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN16_REG: u32 = 1072971976;
pub const GPIO_PIN16_INT_ENA: u32 = 31;
pub const GPIO_PIN16_INT_ENA_V: u32 = 31;
pub const GPIO_PIN16_INT_ENA_S: u32 = 13;
pub const GPIO_PIN16_CONFIG: u32 = 3;
pub const GPIO_PIN16_CONFIG_V: u32 = 3;
pub const GPIO_PIN16_CONFIG_S: u32 = 11;
pub const GPIO_PIN16_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN16_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN16_INT_TYPE: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN16_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN16_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN17_REG: u32 = 1072971980;
pub const GPIO_PIN17_INT_ENA: u32 = 31;
pub const GPIO_PIN17_INT_ENA_V: u32 = 31;
pub const GPIO_PIN17_INT_ENA_S: u32 = 13;
pub const GPIO_PIN17_CONFIG: u32 = 3;
pub const GPIO_PIN17_CONFIG_V: u32 = 3;
pub const GPIO_PIN17_CONFIG_S: u32 = 11;
pub const GPIO_PIN17_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN17_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN17_INT_TYPE: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN17_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN17_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN18_REG: u32 = 1072971984;
pub const GPIO_PIN18_INT_ENA: u32 = 31;
pub const GPIO_PIN18_INT_ENA_V: u32 = 31;
pub const GPIO_PIN18_INT_ENA_S: u32 = 13;
pub const GPIO_PIN18_CONFIG: u32 = 3;
pub const GPIO_PIN18_CONFIG_V: u32 = 3;
pub const GPIO_PIN18_CONFIG_S: u32 = 11;
pub const GPIO_PIN18_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN18_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN18_INT_TYPE: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN18_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN18_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN19_REG: u32 = 1072971988;
pub const GPIO_PIN19_INT_ENA: u32 = 31;
pub const GPIO_PIN19_INT_ENA_V: u32 = 31;
pub const GPIO_PIN19_INT_ENA_S: u32 = 13;
pub const GPIO_PIN19_CONFIG: u32 = 3;
pub const GPIO_PIN19_CONFIG_V: u32 = 3;
pub const GPIO_PIN19_CONFIG_S: u32 = 11;
pub const GPIO_PIN19_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN19_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN19_INT_TYPE: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN19_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN19_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN20_REG: u32 = 1072971992;
pub const GPIO_PIN20_INT_ENA: u32 = 31;
pub const GPIO_PIN20_INT_ENA_V: u32 = 31;
pub const GPIO_PIN20_INT_ENA_S: u32 = 13;
pub const GPIO_PIN20_CONFIG: u32 = 3;
pub const GPIO_PIN20_CONFIG_V: u32 = 3;
pub const GPIO_PIN20_CONFIG_S: u32 = 11;
pub const GPIO_PIN20_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN20_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN20_INT_TYPE: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN20_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN20_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN21_REG: u32 = 1072971996;
pub const GPIO_PIN21_INT_ENA: u32 = 31;
pub const GPIO_PIN21_INT_ENA_V: u32 = 31;
pub const GPIO_PIN21_INT_ENA_S: u32 = 13;
pub const GPIO_PIN21_CONFIG: u32 = 3;
pub const GPIO_PIN21_CONFIG_V: u32 = 3;
pub const GPIO_PIN21_CONFIG_S: u32 = 11;
pub const GPIO_PIN21_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN21_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN21_INT_TYPE: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN21_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN21_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN22_REG: u32 = 1072972000;
pub const GPIO_PIN22_INT_ENA: u32 = 31;
pub const GPIO_PIN22_INT_ENA_V: u32 = 31;
pub const GPIO_PIN22_INT_ENA_S: u32 = 13;
pub const GPIO_PIN22_CONFIG: u32 = 3;
pub const GPIO_PIN22_CONFIG_V: u32 = 3;
pub const GPIO_PIN22_CONFIG_S: u32 = 11;
pub const GPIO_PIN22_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN22_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN22_INT_TYPE: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN22_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN22_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN23_REG: u32 = 1072972004;
pub const GPIO_PIN23_INT_ENA: u32 = 31;
pub const GPIO_PIN23_INT_ENA_V: u32 = 31;
pub const GPIO_PIN23_INT_ENA_S: u32 = 13;
pub const GPIO_PIN23_CONFIG: u32 = 3;
pub const GPIO_PIN23_CONFIG_V: u32 = 3;
pub const GPIO_PIN23_CONFIG_S: u32 = 11;
pub const GPIO_PIN23_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN23_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN23_INT_TYPE: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN23_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN23_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN24_REG: u32 = 1072972008;
pub const GPIO_PIN24_INT_ENA: u32 = 31;
pub const GPIO_PIN24_INT_ENA_V: u32 = 31;
pub const GPIO_PIN24_INT_ENA_S: u32 = 13;
pub const GPIO_PIN24_CONFIG: u32 = 3;
pub const GPIO_PIN24_CONFIG_V: u32 = 3;
pub const GPIO_PIN24_CONFIG_S: u32 = 11;
pub const GPIO_PIN24_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN24_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN24_INT_TYPE: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN24_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN24_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN25_REG: u32 = 1072972012;
pub const GPIO_PIN25_INT_ENA: u32 = 31;
pub const GPIO_PIN25_INT_ENA_V: u32 = 31;
pub const GPIO_PIN25_INT_ENA_S: u32 = 13;
pub const GPIO_PIN25_CONFIG: u32 = 3;
pub const GPIO_PIN25_CONFIG_V: u32 = 3;
pub const GPIO_PIN25_CONFIG_S: u32 = 11;
pub const GPIO_PIN25_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN25_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN25_INT_TYPE: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN25_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN25_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN26_REG: u32 = 1072972016;
pub const GPIO_PIN26_INT_ENA: u32 = 31;
pub const GPIO_PIN26_INT_ENA_V: u32 = 31;
pub const GPIO_PIN26_INT_ENA_S: u32 = 13;
pub const GPIO_PIN26_CONFIG: u32 = 3;
pub const GPIO_PIN26_CONFIG_V: u32 = 3;
pub const GPIO_PIN26_CONFIG_S: u32 = 11;
pub const GPIO_PIN26_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN26_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN26_INT_TYPE: u32 = 7;
pub const GPIO_PIN26_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN26_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN26_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN26_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN27_REG: u32 = 1072972020;
pub const GPIO_PIN27_INT_ENA: u32 = 31;
pub const GPIO_PIN27_INT_ENA_V: u32 = 31;
pub const GPIO_PIN27_INT_ENA_S: u32 = 13;
pub const GPIO_PIN27_CONFIG: u32 = 3;
pub const GPIO_PIN27_CONFIG_V: u32 = 3;
pub const GPIO_PIN27_CONFIG_S: u32 = 11;
pub const GPIO_PIN27_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN27_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN27_INT_TYPE: u32 = 7;
pub const GPIO_PIN27_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN27_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN27_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN27_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN28_REG: u32 = 1072972024;
pub const GPIO_PIN28_INT_ENA: u32 = 31;
pub const GPIO_PIN28_INT_ENA_V: u32 = 31;
pub const GPIO_PIN28_INT_ENA_S: u32 = 13;
pub const GPIO_PIN28_CONFIG: u32 = 3;
pub const GPIO_PIN28_CONFIG_V: u32 = 3;
pub const GPIO_PIN28_CONFIG_S: u32 = 11;
pub const GPIO_PIN28_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN28_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN28_INT_TYPE: u32 = 7;
pub const GPIO_PIN28_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN28_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN28_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN28_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN29_REG: u32 = 1072972028;
pub const GPIO_PIN29_INT_ENA: u32 = 31;
pub const GPIO_PIN29_INT_ENA_V: u32 = 31;
pub const GPIO_PIN29_INT_ENA_S: u32 = 13;
pub const GPIO_PIN29_CONFIG: u32 = 3;
pub const GPIO_PIN29_CONFIG_V: u32 = 3;
pub const GPIO_PIN29_CONFIG_S: u32 = 11;
pub const GPIO_PIN29_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN29_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN29_INT_TYPE: u32 = 7;
pub const GPIO_PIN29_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN29_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN29_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN29_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN30_REG: u32 = 1072972032;
pub const GPIO_PIN30_INT_ENA: u32 = 31;
pub const GPIO_PIN30_INT_ENA_V: u32 = 31;
pub const GPIO_PIN30_INT_ENA_S: u32 = 13;
pub const GPIO_PIN30_CONFIG: u32 = 3;
pub const GPIO_PIN30_CONFIG_V: u32 = 3;
pub const GPIO_PIN30_CONFIG_S: u32 = 11;
pub const GPIO_PIN30_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN30_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN30_INT_TYPE: u32 = 7;
pub const GPIO_PIN30_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN30_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN30_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN30_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN31_REG: u32 = 1072972036;
pub const GPIO_PIN31_INT_ENA: u32 = 31;
pub const GPIO_PIN31_INT_ENA_V: u32 = 31;
pub const GPIO_PIN31_INT_ENA_S: u32 = 13;
pub const GPIO_PIN31_CONFIG: u32 = 3;
pub const GPIO_PIN31_CONFIG_V: u32 = 3;
pub const GPIO_PIN31_CONFIG_S: u32 = 11;
pub const GPIO_PIN31_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN31_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN31_INT_TYPE: u32 = 7;
pub const GPIO_PIN31_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN31_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN31_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN31_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN32_REG: u32 = 1072972040;
pub const GPIO_PIN32_INT_ENA: u32 = 31;
pub const GPIO_PIN32_INT_ENA_V: u32 = 31;
pub const GPIO_PIN32_INT_ENA_S: u32 = 13;
pub const GPIO_PIN32_CONFIG: u32 = 3;
pub const GPIO_PIN32_CONFIG_V: u32 = 3;
pub const GPIO_PIN32_CONFIG_S: u32 = 11;
pub const GPIO_PIN32_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN32_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN32_INT_TYPE: u32 = 7;
pub const GPIO_PIN32_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN32_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN32_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN32_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN33_REG: u32 = 1072972044;
pub const GPIO_PIN33_INT_ENA: u32 = 31;
pub const GPIO_PIN33_INT_ENA_V: u32 = 31;
pub const GPIO_PIN33_INT_ENA_S: u32 = 13;
pub const GPIO_PIN33_CONFIG: u32 = 3;
pub const GPIO_PIN33_CONFIG_V: u32 = 3;
pub const GPIO_PIN33_CONFIG_S: u32 = 11;
pub const GPIO_PIN33_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN33_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN33_INT_TYPE: u32 = 7;
pub const GPIO_PIN33_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN33_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN33_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN33_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN34_REG: u32 = 1072972048;
pub const GPIO_PIN34_INT_ENA: u32 = 31;
pub const GPIO_PIN34_INT_ENA_V: u32 = 31;
pub const GPIO_PIN34_INT_ENA_S: u32 = 13;
pub const GPIO_PIN34_CONFIG: u32 = 3;
pub const GPIO_PIN34_CONFIG_V: u32 = 3;
pub const GPIO_PIN34_CONFIG_S: u32 = 11;
pub const GPIO_PIN34_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN34_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN34_INT_TYPE: u32 = 7;
pub const GPIO_PIN34_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN34_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN34_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN34_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN35_REG: u32 = 1072972052;
pub const GPIO_PIN35_INT_ENA: u32 = 31;
pub const GPIO_PIN35_INT_ENA_V: u32 = 31;
pub const GPIO_PIN35_INT_ENA_S: u32 = 13;
pub const GPIO_PIN35_CONFIG: u32 = 3;
pub const GPIO_PIN35_CONFIG_V: u32 = 3;
pub const GPIO_PIN35_CONFIG_S: u32 = 11;
pub const GPIO_PIN35_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN35_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN35_INT_TYPE: u32 = 7;
pub const GPIO_PIN35_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN35_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN35_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN35_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN36_REG: u32 = 1072972056;
pub const GPIO_PIN36_INT_ENA: u32 = 31;
pub const GPIO_PIN36_INT_ENA_V: u32 = 31;
pub const GPIO_PIN36_INT_ENA_S: u32 = 13;
pub const GPIO_PIN36_CONFIG: u32 = 3;
pub const GPIO_PIN36_CONFIG_V: u32 = 3;
pub const GPIO_PIN36_CONFIG_S: u32 = 11;
pub const GPIO_PIN36_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN36_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN36_INT_TYPE: u32 = 7;
pub const GPIO_PIN36_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN36_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN36_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN36_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN37_REG: u32 = 1072972060;
pub const GPIO_PIN37_INT_ENA: u32 = 31;
pub const GPIO_PIN37_INT_ENA_V: u32 = 31;
pub const GPIO_PIN37_INT_ENA_S: u32 = 13;
pub const GPIO_PIN37_CONFIG: u32 = 3;
pub const GPIO_PIN37_CONFIG_V: u32 = 3;
pub const GPIO_PIN37_CONFIG_S: u32 = 11;
pub const GPIO_PIN37_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN37_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN37_INT_TYPE: u32 = 7;
pub const GPIO_PIN37_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN37_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN37_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN37_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN38_REG: u32 = 1072972064;
pub const GPIO_PIN38_INT_ENA: u32 = 31;
pub const GPIO_PIN38_INT_ENA_V: u32 = 31;
pub const GPIO_PIN38_INT_ENA_S: u32 = 13;
pub const GPIO_PIN38_CONFIG: u32 = 3;
pub const GPIO_PIN38_CONFIG_V: u32 = 3;
pub const GPIO_PIN38_CONFIG_S: u32 = 11;
pub const GPIO_PIN38_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN38_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN38_INT_TYPE: u32 = 7;
pub const GPIO_PIN38_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN38_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN38_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN38_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN39_REG: u32 = 1072972068;
pub const GPIO_PIN39_INT_ENA: u32 = 31;
pub const GPIO_PIN39_INT_ENA_V: u32 = 31;
pub const GPIO_PIN39_INT_ENA_S: u32 = 13;
pub const GPIO_PIN39_CONFIG: u32 = 3;
pub const GPIO_PIN39_CONFIG_V: u32 = 3;
pub const GPIO_PIN39_CONFIG_S: u32 = 11;
pub const GPIO_PIN39_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN39_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN39_INT_TYPE: u32 = 7;
pub const GPIO_PIN39_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN39_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN39_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN39_PAD_DRIVER_S: u32 = 2;
pub const GPIO_cali_conf_REG: u32 = 1072972072;
pub const GPIO_CALI_START_V: u32 = 1;
pub const GPIO_CALI_START_S: u32 = 31;
pub const GPIO_CALI_RTC_MAX: u32 = 1023;
pub const GPIO_CALI_RTC_MAX_V: u32 = 1023;
pub const GPIO_CALI_RTC_MAX_S: u32 = 0;
pub const GPIO_cali_data_REG: u32 = 1072972076;
pub const GPIO_CALI_RDY_SYNC2_V: u32 = 1;
pub const GPIO_CALI_RDY_SYNC2_S: u32 = 31;
pub const GPIO_CALI_RDY_REAL_V: u32 = 1;
pub const GPIO_CALI_RDY_REAL_S: u32 = 30;
pub const GPIO_CALI_VALUE_SYNC2: u32 = 1048575;
pub const GPIO_CALI_VALUE_SYNC2_V: u32 = 1048575;
pub const GPIO_CALI_VALUE_SYNC2_S: u32 = 0;
pub const GPIO_FUNC0_IN_SEL_CFG_REG: u32 = 1072972080;
pub const GPIO_SIG0_IN_SEL_V: u32 = 1;
pub const GPIO_SIG0_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC0_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC0_IN_SEL: u32 = 63;
pub const GPIO_FUNC0_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC0_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC1_IN_SEL_CFG_REG: u32 = 1072972084;
pub const GPIO_SIG1_IN_SEL_V: u32 = 1;
pub const GPIO_SIG1_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC1_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC1_IN_SEL: u32 = 63;
pub const GPIO_FUNC1_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC1_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC2_IN_SEL_CFG_REG: u32 = 1072972088;
pub const GPIO_SIG2_IN_SEL_V: u32 = 1;
pub const GPIO_SIG2_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC2_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC2_IN_SEL: u32 = 63;
pub const GPIO_FUNC2_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC2_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC3_IN_SEL_CFG_REG: u32 = 1072972092;
pub const GPIO_SIG3_IN_SEL_V: u32 = 1;
pub const GPIO_SIG3_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC3_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC3_IN_SEL: u32 = 63;
pub const GPIO_FUNC3_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC3_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC4_IN_SEL_CFG_REG: u32 = 1072972096;
pub const GPIO_SIG4_IN_SEL_V: u32 = 1;
pub const GPIO_SIG4_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC4_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC4_IN_SEL: u32 = 63;
pub const GPIO_FUNC4_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC4_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC5_IN_SEL_CFG_REG: u32 = 1072972100;
pub const GPIO_SIG5_IN_SEL_V: u32 = 1;
pub const GPIO_SIG5_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC5_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC5_IN_SEL: u32 = 63;
pub const GPIO_FUNC5_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC5_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC6_IN_SEL_CFG_REG: u32 = 1072972104;
pub const GPIO_SIG6_IN_SEL_V: u32 = 1;
pub const GPIO_SIG6_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC6_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC6_IN_SEL: u32 = 63;
pub const GPIO_FUNC6_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC6_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC7_IN_SEL_CFG_REG: u32 = 1072972108;
pub const GPIO_SIG7_IN_SEL_V: u32 = 1;
pub const GPIO_SIG7_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC7_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC7_IN_SEL: u32 = 63;
pub const GPIO_FUNC7_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC7_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC8_IN_SEL_CFG_REG: u32 = 1072972112;
pub const GPIO_SIG8_IN_SEL_V: u32 = 1;
pub const GPIO_SIG8_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC8_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC8_IN_SEL: u32 = 63;
pub const GPIO_FUNC8_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC8_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC9_IN_SEL_CFG_REG: u32 = 1072972116;
pub const GPIO_SIG9_IN_SEL_V: u32 = 1;
pub const GPIO_SIG9_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC9_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC9_IN_SEL: u32 = 63;
pub const GPIO_FUNC9_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC9_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC10_IN_SEL_CFG_REG: u32 = 1072972120;
pub const GPIO_SIG10_IN_SEL_V: u32 = 1;
pub const GPIO_SIG10_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC10_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC10_IN_SEL: u32 = 63;
pub const GPIO_FUNC10_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC10_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC11_IN_SEL_CFG_REG: u32 = 1072972124;
pub const GPIO_SIG11_IN_SEL_V: u32 = 1;
pub const GPIO_SIG11_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC11_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC11_IN_SEL: u32 = 63;
pub const GPIO_FUNC11_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC11_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC12_IN_SEL_CFG_REG: u32 = 1072972128;
pub const GPIO_SIG12_IN_SEL_V: u32 = 1;
pub const GPIO_SIG12_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC12_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC12_IN_SEL: u32 = 63;
pub const GPIO_FUNC12_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC12_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC13_IN_SEL_CFG_REG: u32 = 1072972132;
pub const GPIO_SIG13_IN_SEL_V: u32 = 1;
pub const GPIO_SIG13_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC13_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC13_IN_SEL: u32 = 63;
pub const GPIO_FUNC13_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC13_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC14_IN_SEL_CFG_REG: u32 = 1072972136;
pub const GPIO_SIG14_IN_SEL_V: u32 = 1;
pub const GPIO_SIG14_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC14_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC14_IN_SEL: u32 = 63;
pub const GPIO_FUNC14_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC14_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC15_IN_SEL_CFG_REG: u32 = 1072972140;
pub const GPIO_SIG15_IN_SEL_V: u32 = 1;
pub const GPIO_SIG15_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC15_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC15_IN_SEL: u32 = 63;
pub const GPIO_FUNC15_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC15_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC16_IN_SEL_CFG_REG: u32 = 1072972144;
pub const GPIO_SIG16_IN_SEL_V: u32 = 1;
pub const GPIO_SIG16_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC16_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC16_IN_SEL: u32 = 63;
pub const GPIO_FUNC16_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC16_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC17_IN_SEL_CFG_REG: u32 = 1072972148;
pub const GPIO_SIG17_IN_SEL_V: u32 = 1;
pub const GPIO_SIG17_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC17_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC17_IN_SEL: u32 = 63;
pub const GPIO_FUNC17_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC17_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC18_IN_SEL_CFG_REG: u32 = 1072972152;
pub const GPIO_SIG18_IN_SEL_V: u32 = 1;
pub const GPIO_SIG18_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC18_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC18_IN_SEL: u32 = 63;
pub const GPIO_FUNC18_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC18_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC19_IN_SEL_CFG_REG: u32 = 1072972156;
pub const GPIO_SIG19_IN_SEL_V: u32 = 1;
pub const GPIO_SIG19_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC19_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC19_IN_SEL: u32 = 63;
pub const GPIO_FUNC19_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC19_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC20_IN_SEL_CFG_REG: u32 = 1072972160;
pub const GPIO_SIG20_IN_SEL_V: u32 = 1;
pub const GPIO_SIG20_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC20_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC20_IN_SEL: u32 = 63;
pub const GPIO_FUNC20_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC20_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC21_IN_SEL_CFG_REG: u32 = 1072972164;
pub const GPIO_SIG21_IN_SEL_V: u32 = 1;
pub const GPIO_SIG21_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC21_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC21_IN_SEL: u32 = 63;
pub const GPIO_FUNC21_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC21_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC22_IN_SEL_CFG_REG: u32 = 1072972168;
pub const GPIO_SIG22_IN_SEL_V: u32 = 1;
pub const GPIO_SIG22_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC22_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC22_IN_SEL: u32 = 63;
pub const GPIO_FUNC22_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC22_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC23_IN_SEL_CFG_REG: u32 = 1072972172;
pub const GPIO_SIG23_IN_SEL_V: u32 = 1;
pub const GPIO_SIG23_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC23_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC23_IN_SEL: u32 = 63;
pub const GPIO_FUNC23_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC23_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC24_IN_SEL_CFG_REG: u32 = 1072972176;
pub const GPIO_SIG24_IN_SEL_V: u32 = 1;
pub const GPIO_SIG24_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC24_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC24_IN_SEL: u32 = 63;
pub const GPIO_FUNC24_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC24_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC25_IN_SEL_CFG_REG: u32 = 1072972180;
pub const GPIO_SIG25_IN_SEL_V: u32 = 1;
pub const GPIO_SIG25_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC25_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC25_IN_SEL: u32 = 63;
pub const GPIO_FUNC25_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC25_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC26_IN_SEL_CFG_REG: u32 = 1072972184;
pub const GPIO_SIG26_IN_SEL_V: u32 = 1;
pub const GPIO_SIG26_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC26_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC26_IN_SEL: u32 = 63;
pub const GPIO_FUNC26_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC26_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC27_IN_SEL_CFG_REG: u32 = 1072972188;
pub const GPIO_SIG27_IN_SEL_V: u32 = 1;
pub const GPIO_SIG27_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC27_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC27_IN_SEL: u32 = 63;
pub const GPIO_FUNC27_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC27_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC28_IN_SEL_CFG_REG: u32 = 1072972192;
pub const GPIO_SIG28_IN_SEL_V: u32 = 1;
pub const GPIO_SIG28_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC28_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC28_IN_SEL: u32 = 63;
pub const GPIO_FUNC28_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC28_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC29_IN_SEL_CFG_REG: u32 = 1072972196;
pub const GPIO_SIG29_IN_SEL_V: u32 = 1;
pub const GPIO_SIG29_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC29_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC29_IN_SEL: u32 = 63;
pub const GPIO_FUNC29_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC29_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC30_IN_SEL_CFG_REG: u32 = 1072972200;
pub const GPIO_SIG30_IN_SEL_V: u32 = 1;
pub const GPIO_SIG30_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC30_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC30_IN_SEL: u32 = 63;
pub const GPIO_FUNC30_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC30_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC31_IN_SEL_CFG_REG: u32 = 1072972204;
pub const GPIO_SIG31_IN_SEL_V: u32 = 1;
pub const GPIO_SIG31_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC31_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC31_IN_SEL: u32 = 63;
pub const GPIO_FUNC31_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC31_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC32_IN_SEL_CFG_REG: u32 = 1072972208;
pub const GPIO_SIG32_IN_SEL_V: u32 = 1;
pub const GPIO_SIG32_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC32_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC32_IN_SEL: u32 = 63;
pub const GPIO_FUNC32_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC32_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC33_IN_SEL_CFG_REG: u32 = 1072972212;
pub const GPIO_SIG33_IN_SEL_V: u32 = 1;
pub const GPIO_SIG33_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC33_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC33_IN_SEL: u32 = 63;
pub const GPIO_FUNC33_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC33_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC34_IN_SEL_CFG_REG: u32 = 1072972216;
pub const GPIO_SIG34_IN_SEL_V: u32 = 1;
pub const GPIO_SIG34_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC34_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC34_IN_SEL: u32 = 63;
pub const GPIO_FUNC34_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC34_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC35_IN_SEL_CFG_REG: u32 = 1072972220;
pub const GPIO_SIG35_IN_SEL_V: u32 = 1;
pub const GPIO_SIG35_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC35_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC35_IN_SEL: u32 = 63;
pub const GPIO_FUNC35_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC35_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC36_IN_SEL_CFG_REG: u32 = 1072972224;
pub const GPIO_SIG36_IN_SEL_V: u32 = 1;
pub const GPIO_SIG36_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC36_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC36_IN_SEL: u32 = 63;
pub const GPIO_FUNC36_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC36_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC37_IN_SEL_CFG_REG: u32 = 1072972228;
pub const GPIO_SIG37_IN_SEL_V: u32 = 1;
pub const GPIO_SIG37_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC37_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC37_IN_SEL: u32 = 63;
pub const GPIO_FUNC37_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC37_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC38_IN_SEL_CFG_REG: u32 = 1072972232;
pub const GPIO_SIG38_IN_SEL_V: u32 = 1;
pub const GPIO_SIG38_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC38_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC38_IN_SEL: u32 = 63;
pub const GPIO_FUNC38_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC38_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC39_IN_SEL_CFG_REG: u32 = 1072972236;
pub const GPIO_SIG39_IN_SEL_V: u32 = 1;
pub const GPIO_SIG39_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC39_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC39_IN_SEL: u32 = 63;
pub const GPIO_FUNC39_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC39_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC40_IN_SEL_CFG_REG: u32 = 1072972240;
pub const GPIO_SIG40_IN_SEL_V: u32 = 1;
pub const GPIO_SIG40_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC40_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC40_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC40_IN_SEL: u32 = 63;
pub const GPIO_FUNC40_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC40_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC41_IN_SEL_CFG_REG: u32 = 1072972244;
pub const GPIO_SIG41_IN_SEL_V: u32 = 1;
pub const GPIO_SIG41_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC41_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC41_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC41_IN_SEL: u32 = 63;
pub const GPIO_FUNC41_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC41_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC42_IN_SEL_CFG_REG: u32 = 1072972248;
pub const GPIO_SIG42_IN_SEL_V: u32 = 1;
pub const GPIO_SIG42_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC42_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC42_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC42_IN_SEL: u32 = 63;
pub const GPIO_FUNC42_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC42_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC43_IN_SEL_CFG_REG: u32 = 1072972252;
pub const GPIO_SIG43_IN_SEL_V: u32 = 1;
pub const GPIO_SIG43_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC43_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC43_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC43_IN_SEL: u32 = 63;
pub const GPIO_FUNC43_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC43_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC44_IN_SEL_CFG_REG: u32 = 1072972256;
pub const GPIO_SIG44_IN_SEL_V: u32 = 1;
pub const GPIO_SIG44_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC44_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC44_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC44_IN_SEL: u32 = 63;
pub const GPIO_FUNC44_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC44_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC45_IN_SEL_CFG_REG: u32 = 1072972260;
pub const GPIO_SIG45_IN_SEL_V: u32 = 1;
pub const GPIO_SIG45_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC45_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC45_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC45_IN_SEL: u32 = 63;
pub const GPIO_FUNC45_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC45_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC46_IN_SEL_CFG_REG: u32 = 1072972264;
pub const GPIO_SIG46_IN_SEL_V: u32 = 1;
pub const GPIO_SIG46_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC46_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC46_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC46_IN_SEL: u32 = 63;
pub const GPIO_FUNC46_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC46_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC47_IN_SEL_CFG_REG: u32 = 1072972268;
pub const GPIO_SIG47_IN_SEL_V: u32 = 1;
pub const GPIO_SIG47_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC47_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC47_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC47_IN_SEL: u32 = 63;
pub const GPIO_FUNC47_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC47_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC48_IN_SEL_CFG_REG: u32 = 1072972272;
pub const GPIO_SIG48_IN_SEL_V: u32 = 1;
pub const GPIO_SIG48_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC48_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC48_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC48_IN_SEL: u32 = 63;
pub const GPIO_FUNC48_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC48_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC49_IN_SEL_CFG_REG: u32 = 1072972276;
pub const GPIO_SIG49_IN_SEL_V: u32 = 1;
pub const GPIO_SIG49_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC49_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC49_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC49_IN_SEL: u32 = 63;
pub const GPIO_FUNC49_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC49_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC50_IN_SEL_CFG_REG: u32 = 1072972280;
pub const GPIO_SIG50_IN_SEL_V: u32 = 1;
pub const GPIO_SIG50_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC50_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC50_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC50_IN_SEL: u32 = 63;
pub const GPIO_FUNC50_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC50_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC51_IN_SEL_CFG_REG: u32 = 1072972284;
pub const GPIO_SIG51_IN_SEL_V: u32 = 1;
pub const GPIO_SIG51_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC51_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC51_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC51_IN_SEL: u32 = 63;
pub const GPIO_FUNC51_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC51_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC52_IN_SEL_CFG_REG: u32 = 1072972288;
pub const GPIO_SIG52_IN_SEL_V: u32 = 1;
pub const GPIO_SIG52_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC52_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC52_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC52_IN_SEL: u32 = 63;
pub const GPIO_FUNC52_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC52_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC53_IN_SEL_CFG_REG: u32 = 1072972292;
pub const GPIO_SIG53_IN_SEL_V: u32 = 1;
pub const GPIO_SIG53_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC53_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC53_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC53_IN_SEL: u32 = 63;
pub const GPIO_FUNC53_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC53_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC54_IN_SEL_CFG_REG: u32 = 1072972296;
pub const GPIO_SIG54_IN_SEL_V: u32 = 1;
pub const GPIO_SIG54_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC54_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC54_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC54_IN_SEL: u32 = 63;
pub const GPIO_FUNC54_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC54_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC55_IN_SEL_CFG_REG: u32 = 1072972300;
pub const GPIO_SIG55_IN_SEL_V: u32 = 1;
pub const GPIO_SIG55_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC55_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC55_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC55_IN_SEL: u32 = 63;
pub const GPIO_FUNC55_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC55_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC56_IN_SEL_CFG_REG: u32 = 1072972304;
pub const GPIO_SIG56_IN_SEL_V: u32 = 1;
pub const GPIO_SIG56_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC56_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC56_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC56_IN_SEL: u32 = 63;
pub const GPIO_FUNC56_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC56_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC57_IN_SEL_CFG_REG: u32 = 1072972308;
pub const GPIO_SIG57_IN_SEL_V: u32 = 1;
pub const GPIO_SIG57_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC57_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC57_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC57_IN_SEL: u32 = 63;
pub const GPIO_FUNC57_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC57_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC58_IN_SEL_CFG_REG: u32 = 1072972312;
pub const GPIO_SIG58_IN_SEL_V: u32 = 1;
pub const GPIO_SIG58_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC58_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC58_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC58_IN_SEL: u32 = 63;
pub const GPIO_FUNC58_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC58_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC59_IN_SEL_CFG_REG: u32 = 1072972316;
pub const GPIO_SIG59_IN_SEL_V: u32 = 1;
pub const GPIO_SIG59_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC59_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC59_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC59_IN_SEL: u32 = 63;
pub const GPIO_FUNC59_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC59_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC60_IN_SEL_CFG_REG: u32 = 1072972320;
pub const GPIO_SIG60_IN_SEL_V: u32 = 1;
pub const GPIO_SIG60_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC60_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC60_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC60_IN_SEL: u32 = 63;
pub const GPIO_FUNC60_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC60_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC61_IN_SEL_CFG_REG: u32 = 1072972324;
pub const GPIO_SIG61_IN_SEL_V: u32 = 1;
pub const GPIO_SIG61_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC61_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC61_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC61_IN_SEL: u32 = 63;
pub const GPIO_FUNC61_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC61_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC62_IN_SEL_CFG_REG: u32 = 1072972328;
pub const GPIO_SIG62_IN_SEL_V: u32 = 1;
pub const GPIO_SIG62_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC62_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC62_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC62_IN_SEL: u32 = 63;
pub const GPIO_FUNC62_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC62_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC63_IN_SEL_CFG_REG: u32 = 1072972332;
pub const GPIO_SIG63_IN_SEL_V: u32 = 1;
pub const GPIO_SIG63_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC63_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC63_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC63_IN_SEL: u32 = 63;
pub const GPIO_FUNC63_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC63_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC64_IN_SEL_CFG_REG: u32 = 1072972336;
pub const GPIO_SIG64_IN_SEL_V: u32 = 1;
pub const GPIO_SIG64_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC64_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC64_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC64_IN_SEL: u32 = 63;
pub const GPIO_FUNC64_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC64_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC65_IN_SEL_CFG_REG: u32 = 1072972340;
pub const GPIO_SIG65_IN_SEL_V: u32 = 1;
pub const GPIO_SIG65_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC65_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC65_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC65_IN_SEL: u32 = 63;
pub const GPIO_FUNC65_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC65_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC66_IN_SEL_CFG_REG: u32 = 1072972344;
pub const GPIO_SIG66_IN_SEL_V: u32 = 1;
pub const GPIO_SIG66_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC66_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC66_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC66_IN_SEL: u32 = 63;
pub const GPIO_FUNC66_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC66_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC67_IN_SEL_CFG_REG: u32 = 1072972348;
pub const GPIO_SIG67_IN_SEL_V: u32 = 1;
pub const GPIO_SIG67_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC67_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC67_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC67_IN_SEL: u32 = 63;
pub const GPIO_FUNC67_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC67_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC68_IN_SEL_CFG_REG: u32 = 1072972352;
pub const GPIO_SIG68_IN_SEL_V: u32 = 1;
pub const GPIO_SIG68_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC68_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC68_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC68_IN_SEL: u32 = 63;
pub const GPIO_FUNC68_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC68_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC69_IN_SEL_CFG_REG: u32 = 1072972356;
pub const GPIO_SIG69_IN_SEL_V: u32 = 1;
pub const GPIO_SIG69_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC69_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC69_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC69_IN_SEL: u32 = 63;
pub const GPIO_FUNC69_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC69_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC70_IN_SEL_CFG_REG: u32 = 1072972360;
pub const GPIO_SIG70_IN_SEL_V: u32 = 1;
pub const GPIO_SIG70_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC70_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC70_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC70_IN_SEL: u32 = 63;
pub const GPIO_FUNC70_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC70_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC71_IN_SEL_CFG_REG: u32 = 1072972364;
pub const GPIO_SIG71_IN_SEL_V: u32 = 1;
pub const GPIO_SIG71_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC71_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC71_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC71_IN_SEL: u32 = 63;
pub const GPIO_FUNC71_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC71_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC72_IN_SEL_CFG_REG: u32 = 1072972368;
pub const GPIO_SIG72_IN_SEL_V: u32 = 1;
pub const GPIO_SIG72_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC72_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC72_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC72_IN_SEL: u32 = 63;
pub const GPIO_FUNC72_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC72_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC73_IN_SEL_CFG_REG: u32 = 1072972372;
pub const GPIO_SIG73_IN_SEL_V: u32 = 1;
pub const GPIO_SIG73_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC73_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC73_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC73_IN_SEL: u32 = 63;
pub const GPIO_FUNC73_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC73_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC74_IN_SEL_CFG_REG: u32 = 1072972376;
pub const GPIO_SIG74_IN_SEL_V: u32 = 1;
pub const GPIO_SIG74_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC74_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC74_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC74_IN_SEL: u32 = 63;
pub const GPIO_FUNC74_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC74_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC75_IN_SEL_CFG_REG: u32 = 1072972380;
pub const GPIO_SIG75_IN_SEL_V: u32 = 1;
pub const GPIO_SIG75_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC75_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC75_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC75_IN_SEL: u32 = 63;
pub const GPIO_FUNC75_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC75_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC76_IN_SEL_CFG_REG: u32 = 1072972384;
pub const GPIO_SIG76_IN_SEL_V: u32 = 1;
pub const GPIO_SIG76_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC76_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC76_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC76_IN_SEL: u32 = 63;
pub const GPIO_FUNC76_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC76_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC77_IN_SEL_CFG_REG: u32 = 1072972388;
pub const GPIO_SIG77_IN_SEL_V: u32 = 1;
pub const GPIO_SIG77_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC77_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC77_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC77_IN_SEL: u32 = 63;
pub const GPIO_FUNC77_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC77_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC78_IN_SEL_CFG_REG: u32 = 1072972392;
pub const GPIO_SIG78_IN_SEL_V: u32 = 1;
pub const GPIO_SIG78_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC78_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC78_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC78_IN_SEL: u32 = 63;
pub const GPIO_FUNC78_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC78_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC79_IN_SEL_CFG_REG: u32 = 1072972396;
pub const GPIO_SIG79_IN_SEL_V: u32 = 1;
pub const GPIO_SIG79_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC79_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC79_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC79_IN_SEL: u32 = 63;
pub const GPIO_FUNC79_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC79_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC80_IN_SEL_CFG_REG: u32 = 1072972400;
pub const GPIO_SIG80_IN_SEL_V: u32 = 1;
pub const GPIO_SIG80_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC80_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC80_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC80_IN_SEL: u32 = 63;
pub const GPIO_FUNC80_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC80_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC81_IN_SEL_CFG_REG: u32 = 1072972404;
pub const GPIO_SIG81_IN_SEL_V: u32 = 1;
pub const GPIO_SIG81_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC81_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC81_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC81_IN_SEL: u32 = 63;
pub const GPIO_FUNC81_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC81_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC82_IN_SEL_CFG_REG: u32 = 1072972408;
pub const GPIO_SIG82_IN_SEL_V: u32 = 1;
pub const GPIO_SIG82_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC82_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC82_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC82_IN_SEL: u32 = 63;
pub const GPIO_FUNC82_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC82_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC83_IN_SEL_CFG_REG: u32 = 1072972412;
pub const GPIO_SIG83_IN_SEL_V: u32 = 1;
pub const GPIO_SIG83_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC83_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC83_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC83_IN_SEL: u32 = 63;
pub const GPIO_FUNC83_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC83_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC84_IN_SEL_CFG_REG: u32 = 1072972416;
pub const GPIO_SIG84_IN_SEL_V: u32 = 1;
pub const GPIO_SIG84_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC84_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC84_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC84_IN_SEL: u32 = 63;
pub const GPIO_FUNC84_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC84_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC85_IN_SEL_CFG_REG: u32 = 1072972420;
pub const GPIO_SIG85_IN_SEL_V: u32 = 1;
pub const GPIO_SIG85_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC85_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC85_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC85_IN_SEL: u32 = 63;
pub const GPIO_FUNC85_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC85_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC86_IN_SEL_CFG_REG: u32 = 1072972424;
pub const GPIO_SIG86_IN_SEL_V: u32 = 1;
pub const GPIO_SIG86_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC86_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC86_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC86_IN_SEL: u32 = 63;
pub const GPIO_FUNC86_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC86_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC87_IN_SEL_CFG_REG: u32 = 1072972428;
pub const GPIO_SIG87_IN_SEL_V: u32 = 1;
pub const GPIO_SIG87_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC87_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC87_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC87_IN_SEL: u32 = 63;
pub const GPIO_FUNC87_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC87_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC88_IN_SEL_CFG_REG: u32 = 1072972432;
pub const GPIO_SIG88_IN_SEL_V: u32 = 1;
pub const GPIO_SIG88_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC88_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC88_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC88_IN_SEL: u32 = 63;
pub const GPIO_FUNC88_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC88_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC89_IN_SEL_CFG_REG: u32 = 1072972436;
pub const GPIO_SIG89_IN_SEL_V: u32 = 1;
pub const GPIO_SIG89_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC89_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC89_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC89_IN_SEL: u32 = 63;
pub const GPIO_FUNC89_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC89_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC90_IN_SEL_CFG_REG: u32 = 1072972440;
pub const GPIO_SIG90_IN_SEL_V: u32 = 1;
pub const GPIO_SIG90_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC90_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC90_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC90_IN_SEL: u32 = 63;
pub const GPIO_FUNC90_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC90_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC91_IN_SEL_CFG_REG: u32 = 1072972444;
pub const GPIO_SIG91_IN_SEL_V: u32 = 1;
pub const GPIO_SIG91_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC91_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC91_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC91_IN_SEL: u32 = 63;
pub const GPIO_FUNC91_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC91_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC92_IN_SEL_CFG_REG: u32 = 1072972448;
pub const GPIO_SIG92_IN_SEL_V: u32 = 1;
pub const GPIO_SIG92_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC92_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC92_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC92_IN_SEL: u32 = 63;
pub const GPIO_FUNC92_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC92_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC93_IN_SEL_CFG_REG: u32 = 1072972452;
pub const GPIO_SIG93_IN_SEL_V: u32 = 1;
pub const GPIO_SIG93_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC93_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC93_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC93_IN_SEL: u32 = 63;
pub const GPIO_FUNC93_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC93_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC94_IN_SEL_CFG_REG: u32 = 1072972456;
pub const GPIO_SIG94_IN_SEL_V: u32 = 1;
pub const GPIO_SIG94_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC94_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC94_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC94_IN_SEL: u32 = 63;
pub const GPIO_FUNC94_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC94_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC95_IN_SEL_CFG_REG: u32 = 1072972460;
pub const GPIO_SIG95_IN_SEL_V: u32 = 1;
pub const GPIO_SIG95_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC95_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC95_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC95_IN_SEL: u32 = 63;
pub const GPIO_FUNC95_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC95_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC96_IN_SEL_CFG_REG: u32 = 1072972464;
pub const GPIO_SIG96_IN_SEL_V: u32 = 1;
pub const GPIO_SIG96_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC96_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC96_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC96_IN_SEL: u32 = 63;
pub const GPIO_FUNC96_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC96_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC97_IN_SEL_CFG_REG: u32 = 1072972468;
pub const GPIO_SIG97_IN_SEL_V: u32 = 1;
pub const GPIO_SIG97_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC97_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC97_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC97_IN_SEL: u32 = 63;
pub const GPIO_FUNC97_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC97_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC98_IN_SEL_CFG_REG: u32 = 1072972472;
pub const GPIO_SIG98_IN_SEL_V: u32 = 1;
pub const GPIO_SIG98_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC98_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC98_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC98_IN_SEL: u32 = 63;
pub const GPIO_FUNC98_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC98_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC99_IN_SEL_CFG_REG: u32 = 1072972476;
pub const GPIO_SIG99_IN_SEL_V: u32 = 1;
pub const GPIO_SIG99_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC99_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC99_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC99_IN_SEL: u32 = 63;
pub const GPIO_FUNC99_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC99_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC100_IN_SEL_CFG_REG: u32 = 1072972480;
pub const GPIO_SIG100_IN_SEL_V: u32 = 1;
pub const GPIO_SIG100_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC100_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC100_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC100_IN_SEL: u32 = 63;
pub const GPIO_FUNC100_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC100_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC101_IN_SEL_CFG_REG: u32 = 1072972484;
pub const GPIO_SIG101_IN_SEL_V: u32 = 1;
pub const GPIO_SIG101_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC101_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC101_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC101_IN_SEL: u32 = 63;
pub const GPIO_FUNC101_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC101_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC102_IN_SEL_CFG_REG: u32 = 1072972488;
pub const GPIO_SIG102_IN_SEL_V: u32 = 1;
pub const GPIO_SIG102_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC102_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC102_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC102_IN_SEL: u32 = 63;
pub const GPIO_FUNC102_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC102_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC103_IN_SEL_CFG_REG: u32 = 1072972492;
pub const GPIO_SIG103_IN_SEL_V: u32 = 1;
pub const GPIO_SIG103_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC103_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC103_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC103_IN_SEL: u32 = 63;
pub const GPIO_FUNC103_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC103_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC104_IN_SEL_CFG_REG: u32 = 1072972496;
pub const GPIO_SIG104_IN_SEL_V: u32 = 1;
pub const GPIO_SIG104_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC104_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC104_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC104_IN_SEL: u32 = 63;
pub const GPIO_FUNC104_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC104_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC105_IN_SEL_CFG_REG: u32 = 1072972500;
pub const GPIO_SIG105_IN_SEL_V: u32 = 1;
pub const GPIO_SIG105_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC105_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC105_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC105_IN_SEL: u32 = 63;
pub const GPIO_FUNC105_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC105_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC106_IN_SEL_CFG_REG: u32 = 1072972504;
pub const GPIO_SIG106_IN_SEL_V: u32 = 1;
pub const GPIO_SIG106_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC106_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC106_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC106_IN_SEL: u32 = 63;
pub const GPIO_FUNC106_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC106_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC107_IN_SEL_CFG_REG: u32 = 1072972508;
pub const GPIO_SIG107_IN_SEL_V: u32 = 1;
pub const GPIO_SIG107_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC107_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC107_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC107_IN_SEL: u32 = 63;
pub const GPIO_FUNC107_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC107_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC108_IN_SEL_CFG_REG: u32 = 1072972512;
pub const GPIO_SIG108_IN_SEL_V: u32 = 1;
pub const GPIO_SIG108_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC108_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC108_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC108_IN_SEL: u32 = 63;
pub const GPIO_FUNC108_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC108_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC109_IN_SEL_CFG_REG: u32 = 1072972516;
pub const GPIO_SIG109_IN_SEL_V: u32 = 1;
pub const GPIO_SIG109_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC109_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC109_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC109_IN_SEL: u32 = 63;
pub const GPIO_FUNC109_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC109_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC110_IN_SEL_CFG_REG: u32 = 1072972520;
pub const GPIO_SIG110_IN_SEL_V: u32 = 1;
pub const GPIO_SIG110_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC110_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC110_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC110_IN_SEL: u32 = 63;
pub const GPIO_FUNC110_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC110_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC111_IN_SEL_CFG_REG: u32 = 1072972524;
pub const GPIO_SIG111_IN_SEL_V: u32 = 1;
pub const GPIO_SIG111_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC111_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC111_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC111_IN_SEL: u32 = 63;
pub const GPIO_FUNC111_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC111_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC112_IN_SEL_CFG_REG: u32 = 1072972528;
pub const GPIO_SIG112_IN_SEL_V: u32 = 1;
pub const GPIO_SIG112_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC112_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC112_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC112_IN_SEL: u32 = 63;
pub const GPIO_FUNC112_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC112_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC113_IN_SEL_CFG_REG: u32 = 1072972532;
pub const GPIO_SIG113_IN_SEL_V: u32 = 1;
pub const GPIO_SIG113_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC113_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC113_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC113_IN_SEL: u32 = 63;
pub const GPIO_FUNC113_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC113_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC114_IN_SEL_CFG_REG: u32 = 1072972536;
pub const GPIO_SIG114_IN_SEL_V: u32 = 1;
pub const GPIO_SIG114_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC114_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC114_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC114_IN_SEL: u32 = 63;
pub const GPIO_FUNC114_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC114_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC115_IN_SEL_CFG_REG: u32 = 1072972540;
pub const GPIO_SIG115_IN_SEL_V: u32 = 1;
pub const GPIO_SIG115_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC115_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC115_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC115_IN_SEL: u32 = 63;
pub const GPIO_FUNC115_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC115_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC116_IN_SEL_CFG_REG: u32 = 1072972544;
pub const GPIO_SIG116_IN_SEL_V: u32 = 1;
pub const GPIO_SIG116_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC116_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC116_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC116_IN_SEL: u32 = 63;
pub const GPIO_FUNC116_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC116_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC117_IN_SEL_CFG_REG: u32 = 1072972548;
pub const GPIO_SIG117_IN_SEL_V: u32 = 1;
pub const GPIO_SIG117_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC117_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC117_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC117_IN_SEL: u32 = 63;
pub const GPIO_FUNC117_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC117_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC118_IN_SEL_CFG_REG: u32 = 1072972552;
pub const GPIO_SIG118_IN_SEL_V: u32 = 1;
pub const GPIO_SIG118_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC118_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC118_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC118_IN_SEL: u32 = 63;
pub const GPIO_FUNC118_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC118_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC119_IN_SEL_CFG_REG: u32 = 1072972556;
pub const GPIO_SIG119_IN_SEL_V: u32 = 1;
pub const GPIO_SIG119_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC119_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC119_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC119_IN_SEL: u32 = 63;
pub const GPIO_FUNC119_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC119_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC120_IN_SEL_CFG_REG: u32 = 1072972560;
pub const GPIO_SIG120_IN_SEL_V: u32 = 1;
pub const GPIO_SIG120_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC120_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC120_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC120_IN_SEL: u32 = 63;
pub const GPIO_FUNC120_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC120_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC121_IN_SEL_CFG_REG: u32 = 1072972564;
pub const GPIO_SIG121_IN_SEL_V: u32 = 1;
pub const GPIO_SIG121_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC121_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC121_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC121_IN_SEL: u32 = 63;
pub const GPIO_FUNC121_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC121_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC122_IN_SEL_CFG_REG: u32 = 1072972568;
pub const GPIO_SIG122_IN_SEL_V: u32 = 1;
pub const GPIO_SIG122_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC122_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC122_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC122_IN_SEL: u32 = 63;
pub const GPIO_FUNC122_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC122_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC123_IN_SEL_CFG_REG: u32 = 1072972572;
pub const GPIO_SIG123_IN_SEL_V: u32 = 1;
pub const GPIO_SIG123_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC123_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC123_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC123_IN_SEL: u32 = 63;
pub const GPIO_FUNC123_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC123_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC124_IN_SEL_CFG_REG: u32 = 1072972576;
pub const GPIO_SIG124_IN_SEL_V: u32 = 1;
pub const GPIO_SIG124_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC124_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC124_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC124_IN_SEL: u32 = 63;
pub const GPIO_FUNC124_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC124_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC125_IN_SEL_CFG_REG: u32 = 1072972580;
pub const GPIO_SIG125_IN_SEL_V: u32 = 1;
pub const GPIO_SIG125_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC125_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC125_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC125_IN_SEL: u32 = 63;
pub const GPIO_FUNC125_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC125_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC126_IN_SEL_CFG_REG: u32 = 1072972584;
pub const GPIO_SIG126_IN_SEL_V: u32 = 1;
pub const GPIO_SIG126_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC126_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC126_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC126_IN_SEL: u32 = 63;
pub const GPIO_FUNC126_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC126_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC127_IN_SEL_CFG_REG: u32 = 1072972588;
pub const GPIO_SIG127_IN_SEL_V: u32 = 1;
pub const GPIO_SIG127_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC127_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC127_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC127_IN_SEL: u32 = 63;
pub const GPIO_FUNC127_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC127_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC128_IN_SEL_CFG_REG: u32 = 1072972592;
pub const GPIO_SIG128_IN_SEL_V: u32 = 1;
pub const GPIO_SIG128_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC128_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC128_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC128_IN_SEL: u32 = 63;
pub const GPIO_FUNC128_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC128_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC129_IN_SEL_CFG_REG: u32 = 1072972596;
pub const GPIO_SIG129_IN_SEL_V: u32 = 1;
pub const GPIO_SIG129_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC129_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC129_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC129_IN_SEL: u32 = 63;
pub const GPIO_FUNC129_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC129_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC130_IN_SEL_CFG_REG: u32 = 1072972600;
pub const GPIO_SIG130_IN_SEL_V: u32 = 1;
pub const GPIO_SIG130_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC130_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC130_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC130_IN_SEL: u32 = 63;
pub const GPIO_FUNC130_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC130_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC131_IN_SEL_CFG_REG: u32 = 1072972604;
pub const GPIO_SIG131_IN_SEL_V: u32 = 1;
pub const GPIO_SIG131_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC131_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC131_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC131_IN_SEL: u32 = 63;
pub const GPIO_FUNC131_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC131_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC132_IN_SEL_CFG_REG: u32 = 1072972608;
pub const GPIO_SIG132_IN_SEL_V: u32 = 1;
pub const GPIO_SIG132_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC132_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC132_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC132_IN_SEL: u32 = 63;
pub const GPIO_FUNC132_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC132_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC133_IN_SEL_CFG_REG: u32 = 1072972612;
pub const GPIO_SIG133_IN_SEL_V: u32 = 1;
pub const GPIO_SIG133_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC133_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC133_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC133_IN_SEL: u32 = 63;
pub const GPIO_FUNC133_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC133_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC134_IN_SEL_CFG_REG: u32 = 1072972616;
pub const GPIO_SIG134_IN_SEL_V: u32 = 1;
pub const GPIO_SIG134_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC134_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC134_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC134_IN_SEL: u32 = 63;
pub const GPIO_FUNC134_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC134_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC135_IN_SEL_CFG_REG: u32 = 1072972620;
pub const GPIO_SIG135_IN_SEL_V: u32 = 1;
pub const GPIO_SIG135_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC135_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC135_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC135_IN_SEL: u32 = 63;
pub const GPIO_FUNC135_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC135_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC136_IN_SEL_CFG_REG: u32 = 1072972624;
pub const GPIO_SIG136_IN_SEL_V: u32 = 1;
pub const GPIO_SIG136_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC136_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC136_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC136_IN_SEL: u32 = 63;
pub const GPIO_FUNC136_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC136_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC137_IN_SEL_CFG_REG: u32 = 1072972628;
pub const GPIO_SIG137_IN_SEL_V: u32 = 1;
pub const GPIO_SIG137_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC137_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC137_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC137_IN_SEL: u32 = 63;
pub const GPIO_FUNC137_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC137_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC138_IN_SEL_CFG_REG: u32 = 1072972632;
pub const GPIO_SIG138_IN_SEL_V: u32 = 1;
pub const GPIO_SIG138_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC138_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC138_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC138_IN_SEL: u32 = 63;
pub const GPIO_FUNC138_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC138_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC139_IN_SEL_CFG_REG: u32 = 1072972636;
pub const GPIO_SIG139_IN_SEL_V: u32 = 1;
pub const GPIO_SIG139_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC139_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC139_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC139_IN_SEL: u32 = 63;
pub const GPIO_FUNC139_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC139_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC140_IN_SEL_CFG_REG: u32 = 1072972640;
pub const GPIO_SIG140_IN_SEL_V: u32 = 1;
pub const GPIO_SIG140_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC140_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC140_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC140_IN_SEL: u32 = 63;
pub const GPIO_FUNC140_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC140_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC141_IN_SEL_CFG_REG: u32 = 1072972644;
pub const GPIO_SIG141_IN_SEL_V: u32 = 1;
pub const GPIO_SIG141_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC141_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC141_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC141_IN_SEL: u32 = 63;
pub const GPIO_FUNC141_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC141_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC142_IN_SEL_CFG_REG: u32 = 1072972648;
pub const GPIO_SIG142_IN_SEL_V: u32 = 1;
pub const GPIO_SIG142_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC142_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC142_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC142_IN_SEL: u32 = 63;
pub const GPIO_FUNC142_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC142_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC143_IN_SEL_CFG_REG: u32 = 1072972652;
pub const GPIO_SIG143_IN_SEL_V: u32 = 1;
pub const GPIO_SIG143_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC143_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC143_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC143_IN_SEL: u32 = 63;
pub const GPIO_FUNC143_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC143_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC144_IN_SEL_CFG_REG: u32 = 1072972656;
pub const GPIO_SIG144_IN_SEL_V: u32 = 1;
pub const GPIO_SIG144_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC144_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC144_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC144_IN_SEL: u32 = 63;
pub const GPIO_FUNC144_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC144_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC145_IN_SEL_CFG_REG: u32 = 1072972660;
pub const GPIO_SIG145_IN_SEL_V: u32 = 1;
pub const GPIO_SIG145_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC145_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC145_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC145_IN_SEL: u32 = 63;
pub const GPIO_FUNC145_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC145_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC146_IN_SEL_CFG_REG: u32 = 1072972664;
pub const GPIO_SIG146_IN_SEL_V: u32 = 1;
pub const GPIO_SIG146_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC146_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC146_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC146_IN_SEL: u32 = 63;
pub const GPIO_FUNC146_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC146_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC147_IN_SEL_CFG_REG: u32 = 1072972668;
pub const GPIO_SIG147_IN_SEL_V: u32 = 1;
pub const GPIO_SIG147_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC147_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC147_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC147_IN_SEL: u32 = 63;
pub const GPIO_FUNC147_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC147_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC148_IN_SEL_CFG_REG: u32 = 1072972672;
pub const GPIO_SIG148_IN_SEL_V: u32 = 1;
pub const GPIO_SIG148_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC148_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC148_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC148_IN_SEL: u32 = 63;
pub const GPIO_FUNC148_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC148_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC149_IN_SEL_CFG_REG: u32 = 1072972676;
pub const GPIO_SIG149_IN_SEL_V: u32 = 1;
pub const GPIO_SIG149_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC149_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC149_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC149_IN_SEL: u32 = 63;
pub const GPIO_FUNC149_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC149_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC150_IN_SEL_CFG_REG: u32 = 1072972680;
pub const GPIO_SIG150_IN_SEL_V: u32 = 1;
pub const GPIO_SIG150_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC150_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC150_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC150_IN_SEL: u32 = 63;
pub const GPIO_FUNC150_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC150_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC151_IN_SEL_CFG_REG: u32 = 1072972684;
pub const GPIO_SIG151_IN_SEL_V: u32 = 1;
pub const GPIO_SIG151_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC151_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC151_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC151_IN_SEL: u32 = 63;
pub const GPIO_FUNC151_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC151_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC152_IN_SEL_CFG_REG: u32 = 1072972688;
pub const GPIO_SIG152_IN_SEL_V: u32 = 1;
pub const GPIO_SIG152_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC152_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC152_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC152_IN_SEL: u32 = 63;
pub const GPIO_FUNC152_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC152_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC153_IN_SEL_CFG_REG: u32 = 1072972692;
pub const GPIO_SIG153_IN_SEL_V: u32 = 1;
pub const GPIO_SIG153_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC153_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC153_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC153_IN_SEL: u32 = 63;
pub const GPIO_FUNC153_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC153_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC154_IN_SEL_CFG_REG: u32 = 1072972696;
pub const GPIO_SIG154_IN_SEL_V: u32 = 1;
pub const GPIO_SIG154_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC154_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC154_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC154_IN_SEL: u32 = 63;
pub const GPIO_FUNC154_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC154_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC155_IN_SEL_CFG_REG: u32 = 1072972700;
pub const GPIO_SIG155_IN_SEL_V: u32 = 1;
pub const GPIO_SIG155_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC155_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC155_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC155_IN_SEL: u32 = 63;
pub const GPIO_FUNC155_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC155_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC156_IN_SEL_CFG_REG: u32 = 1072972704;
pub const GPIO_SIG156_IN_SEL_V: u32 = 1;
pub const GPIO_SIG156_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC156_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC156_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC156_IN_SEL: u32 = 63;
pub const GPIO_FUNC156_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC156_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC157_IN_SEL_CFG_REG: u32 = 1072972708;
pub const GPIO_SIG157_IN_SEL_V: u32 = 1;
pub const GPIO_SIG157_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC157_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC157_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC157_IN_SEL: u32 = 63;
pub const GPIO_FUNC157_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC157_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC158_IN_SEL_CFG_REG: u32 = 1072972712;
pub const GPIO_SIG158_IN_SEL_V: u32 = 1;
pub const GPIO_SIG158_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC158_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC158_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC158_IN_SEL: u32 = 63;
pub const GPIO_FUNC158_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC158_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC159_IN_SEL_CFG_REG: u32 = 1072972716;
pub const GPIO_SIG159_IN_SEL_V: u32 = 1;
pub const GPIO_SIG159_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC159_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC159_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC159_IN_SEL: u32 = 63;
pub const GPIO_FUNC159_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC159_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC160_IN_SEL_CFG_REG: u32 = 1072972720;
pub const GPIO_SIG160_IN_SEL_V: u32 = 1;
pub const GPIO_SIG160_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC160_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC160_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC160_IN_SEL: u32 = 63;
pub const GPIO_FUNC160_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC160_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC161_IN_SEL_CFG_REG: u32 = 1072972724;
pub const GPIO_SIG161_IN_SEL_V: u32 = 1;
pub const GPIO_SIG161_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC161_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC161_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC161_IN_SEL: u32 = 63;
pub const GPIO_FUNC161_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC161_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC162_IN_SEL_CFG_REG: u32 = 1072972728;
pub const GPIO_SIG162_IN_SEL_V: u32 = 1;
pub const GPIO_SIG162_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC162_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC162_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC162_IN_SEL: u32 = 63;
pub const GPIO_FUNC162_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC162_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC163_IN_SEL_CFG_REG: u32 = 1072972732;
pub const GPIO_SIG163_IN_SEL_V: u32 = 1;
pub const GPIO_SIG163_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC163_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC163_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC163_IN_SEL: u32 = 63;
pub const GPIO_FUNC163_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC163_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC164_IN_SEL_CFG_REG: u32 = 1072972736;
pub const GPIO_SIG164_IN_SEL_V: u32 = 1;
pub const GPIO_SIG164_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC164_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC164_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC164_IN_SEL: u32 = 63;
pub const GPIO_FUNC164_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC164_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC165_IN_SEL_CFG_REG: u32 = 1072972740;
pub const GPIO_SIG165_IN_SEL_V: u32 = 1;
pub const GPIO_SIG165_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC165_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC165_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC165_IN_SEL: u32 = 63;
pub const GPIO_FUNC165_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC165_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC166_IN_SEL_CFG_REG: u32 = 1072972744;
pub const GPIO_SIG166_IN_SEL_V: u32 = 1;
pub const GPIO_SIG166_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC166_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC166_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC166_IN_SEL: u32 = 63;
pub const GPIO_FUNC166_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC166_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC167_IN_SEL_CFG_REG: u32 = 1072972748;
pub const GPIO_SIG167_IN_SEL_V: u32 = 1;
pub const GPIO_SIG167_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC167_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC167_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC167_IN_SEL: u32 = 63;
pub const GPIO_FUNC167_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC167_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC168_IN_SEL_CFG_REG: u32 = 1072972752;
pub const GPIO_SIG168_IN_SEL_V: u32 = 1;
pub const GPIO_SIG168_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC168_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC168_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC168_IN_SEL: u32 = 63;
pub const GPIO_FUNC168_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC168_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC169_IN_SEL_CFG_REG: u32 = 1072972756;
pub const GPIO_SIG169_IN_SEL_V: u32 = 1;
pub const GPIO_SIG169_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC169_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC169_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC169_IN_SEL: u32 = 63;
pub const GPIO_FUNC169_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC169_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC170_IN_SEL_CFG_REG: u32 = 1072972760;
pub const GPIO_SIG170_IN_SEL_V: u32 = 1;
pub const GPIO_SIG170_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC170_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC170_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC170_IN_SEL: u32 = 63;
pub const GPIO_FUNC170_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC170_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC171_IN_SEL_CFG_REG: u32 = 1072972764;
pub const GPIO_SIG171_IN_SEL_V: u32 = 1;
pub const GPIO_SIG171_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC171_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC171_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC171_IN_SEL: u32 = 63;
pub const GPIO_FUNC171_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC171_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC172_IN_SEL_CFG_REG: u32 = 1072972768;
pub const GPIO_SIG172_IN_SEL_V: u32 = 1;
pub const GPIO_SIG172_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC172_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC172_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC172_IN_SEL: u32 = 63;
pub const GPIO_FUNC172_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC172_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC173_IN_SEL_CFG_REG: u32 = 1072972772;
pub const GPIO_SIG173_IN_SEL_V: u32 = 1;
pub const GPIO_SIG173_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC173_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC173_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC173_IN_SEL: u32 = 63;
pub const GPIO_FUNC173_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC173_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC174_IN_SEL_CFG_REG: u32 = 1072972776;
pub const GPIO_SIG174_IN_SEL_V: u32 = 1;
pub const GPIO_SIG174_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC174_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC174_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC174_IN_SEL: u32 = 63;
pub const GPIO_FUNC174_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC174_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC175_IN_SEL_CFG_REG: u32 = 1072972780;
pub const GPIO_SIG175_IN_SEL_V: u32 = 1;
pub const GPIO_SIG175_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC175_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC175_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC175_IN_SEL: u32 = 63;
pub const GPIO_FUNC175_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC175_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC176_IN_SEL_CFG_REG: u32 = 1072972784;
pub const GPIO_SIG176_IN_SEL_V: u32 = 1;
pub const GPIO_SIG176_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC176_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC176_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC176_IN_SEL: u32 = 63;
pub const GPIO_FUNC176_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC176_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC177_IN_SEL_CFG_REG: u32 = 1072972788;
pub const GPIO_SIG177_IN_SEL_V: u32 = 1;
pub const GPIO_SIG177_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC177_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC177_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC177_IN_SEL: u32 = 63;
pub const GPIO_FUNC177_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC177_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC178_IN_SEL_CFG_REG: u32 = 1072972792;
pub const GPIO_SIG178_IN_SEL_V: u32 = 1;
pub const GPIO_SIG178_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC178_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC178_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC178_IN_SEL: u32 = 63;
pub const GPIO_FUNC178_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC178_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC179_IN_SEL_CFG_REG: u32 = 1072972796;
pub const GPIO_SIG179_IN_SEL_V: u32 = 1;
pub const GPIO_SIG179_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC179_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC179_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC179_IN_SEL: u32 = 63;
pub const GPIO_FUNC179_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC179_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC180_IN_SEL_CFG_REG: u32 = 1072972800;
pub const GPIO_SIG180_IN_SEL_V: u32 = 1;
pub const GPIO_SIG180_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC180_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC180_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC180_IN_SEL: u32 = 63;
pub const GPIO_FUNC180_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC180_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC181_IN_SEL_CFG_REG: u32 = 1072972804;
pub const GPIO_SIG181_IN_SEL_V: u32 = 1;
pub const GPIO_SIG181_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC181_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC181_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC181_IN_SEL: u32 = 63;
pub const GPIO_FUNC181_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC181_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC182_IN_SEL_CFG_REG: u32 = 1072972808;
pub const GPIO_SIG182_IN_SEL_V: u32 = 1;
pub const GPIO_SIG182_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC182_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC182_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC182_IN_SEL: u32 = 63;
pub const GPIO_FUNC182_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC182_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC183_IN_SEL_CFG_REG: u32 = 1072972812;
pub const GPIO_SIG183_IN_SEL_V: u32 = 1;
pub const GPIO_SIG183_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC183_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC183_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC183_IN_SEL: u32 = 63;
pub const GPIO_FUNC183_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC183_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC184_IN_SEL_CFG_REG: u32 = 1072972816;
pub const GPIO_SIG184_IN_SEL_V: u32 = 1;
pub const GPIO_SIG184_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC184_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC184_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC184_IN_SEL: u32 = 63;
pub const GPIO_FUNC184_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC184_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC185_IN_SEL_CFG_REG: u32 = 1072972820;
pub const GPIO_SIG185_IN_SEL_V: u32 = 1;
pub const GPIO_SIG185_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC185_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC185_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC185_IN_SEL: u32 = 63;
pub const GPIO_FUNC185_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC185_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC186_IN_SEL_CFG_REG: u32 = 1072972824;
pub const GPIO_SIG186_IN_SEL_V: u32 = 1;
pub const GPIO_SIG186_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC186_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC186_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC186_IN_SEL: u32 = 63;
pub const GPIO_FUNC186_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC186_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC187_IN_SEL_CFG_REG: u32 = 1072972828;
pub const GPIO_SIG187_IN_SEL_V: u32 = 1;
pub const GPIO_SIG187_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC187_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC187_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC187_IN_SEL: u32 = 63;
pub const GPIO_FUNC187_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC187_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC188_IN_SEL_CFG_REG: u32 = 1072972832;
pub const GPIO_SIG188_IN_SEL_V: u32 = 1;
pub const GPIO_SIG188_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC188_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC188_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC188_IN_SEL: u32 = 63;
pub const GPIO_FUNC188_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC188_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC189_IN_SEL_CFG_REG: u32 = 1072972836;
pub const GPIO_SIG189_IN_SEL_V: u32 = 1;
pub const GPIO_SIG189_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC189_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC189_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC189_IN_SEL: u32 = 63;
pub const GPIO_FUNC189_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC189_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC190_IN_SEL_CFG_REG: u32 = 1072972840;
pub const GPIO_SIG190_IN_SEL_V: u32 = 1;
pub const GPIO_SIG190_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC190_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC190_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC190_IN_SEL: u32 = 63;
pub const GPIO_FUNC190_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC190_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC191_IN_SEL_CFG_REG: u32 = 1072972844;
pub const GPIO_SIG191_IN_SEL_V: u32 = 1;
pub const GPIO_SIG191_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC191_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC191_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC191_IN_SEL: u32 = 63;
pub const GPIO_FUNC191_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC191_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC192_IN_SEL_CFG_REG: u32 = 1072972848;
pub const GPIO_SIG192_IN_SEL_V: u32 = 1;
pub const GPIO_SIG192_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC192_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC192_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC192_IN_SEL: u32 = 63;
pub const GPIO_FUNC192_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC192_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC193_IN_SEL_CFG_REG: u32 = 1072972852;
pub const GPIO_SIG193_IN_SEL_V: u32 = 1;
pub const GPIO_SIG193_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC193_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC193_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC193_IN_SEL: u32 = 63;
pub const GPIO_FUNC193_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC193_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC194_IN_SEL_CFG_REG: u32 = 1072972856;
pub const GPIO_SIG194_IN_SEL_V: u32 = 1;
pub const GPIO_SIG194_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC194_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC194_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC194_IN_SEL: u32 = 63;
pub const GPIO_FUNC194_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC194_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC195_IN_SEL_CFG_REG: u32 = 1072972860;
pub const GPIO_SIG195_IN_SEL_V: u32 = 1;
pub const GPIO_SIG195_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC195_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC195_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC195_IN_SEL: u32 = 63;
pub const GPIO_FUNC195_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC195_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC196_IN_SEL_CFG_REG: u32 = 1072972864;
pub const GPIO_SIG196_IN_SEL_V: u32 = 1;
pub const GPIO_SIG196_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC196_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC196_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC196_IN_SEL: u32 = 63;
pub const GPIO_FUNC196_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC196_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC197_IN_SEL_CFG_REG: u32 = 1072972868;
pub const GPIO_SIG197_IN_SEL_V: u32 = 1;
pub const GPIO_SIG197_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC197_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC197_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC197_IN_SEL: u32 = 63;
pub const GPIO_FUNC197_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC197_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC198_IN_SEL_CFG_REG: u32 = 1072972872;
pub const GPIO_SIG198_IN_SEL_V: u32 = 1;
pub const GPIO_SIG198_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC198_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC198_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC198_IN_SEL: u32 = 63;
pub const GPIO_FUNC198_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC198_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC199_IN_SEL_CFG_REG: u32 = 1072972876;
pub const GPIO_SIG199_IN_SEL_V: u32 = 1;
pub const GPIO_SIG199_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC199_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC199_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC199_IN_SEL: u32 = 63;
pub const GPIO_FUNC199_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC199_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC200_IN_SEL_CFG_REG: u32 = 1072972880;
pub const GPIO_SIG200_IN_SEL_V: u32 = 1;
pub const GPIO_SIG200_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC200_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC200_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC200_IN_SEL: u32 = 63;
pub const GPIO_FUNC200_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC200_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC201_IN_SEL_CFG_REG: u32 = 1072972884;
pub const GPIO_SIG201_IN_SEL_V: u32 = 1;
pub const GPIO_SIG201_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC201_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC201_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC201_IN_SEL: u32 = 63;
pub const GPIO_FUNC201_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC201_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC202_IN_SEL_CFG_REG: u32 = 1072972888;
pub const GPIO_SIG202_IN_SEL_V: u32 = 1;
pub const GPIO_SIG202_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC202_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC202_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC202_IN_SEL: u32 = 63;
pub const GPIO_FUNC202_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC202_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC203_IN_SEL_CFG_REG: u32 = 1072972892;
pub const GPIO_SIG203_IN_SEL_V: u32 = 1;
pub const GPIO_SIG203_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC203_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC203_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC203_IN_SEL: u32 = 63;
pub const GPIO_FUNC203_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC203_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC204_IN_SEL_CFG_REG: u32 = 1072972896;
pub const GPIO_SIG204_IN_SEL_V: u32 = 1;
pub const GPIO_SIG204_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC204_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC204_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC204_IN_SEL: u32 = 63;
pub const GPIO_FUNC204_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC204_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC205_IN_SEL_CFG_REG: u32 = 1072972900;
pub const GPIO_SIG205_IN_SEL_V: u32 = 1;
pub const GPIO_SIG205_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC205_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC205_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC205_IN_SEL: u32 = 63;
pub const GPIO_FUNC205_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC205_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC206_IN_SEL_CFG_REG: u32 = 1072972904;
pub const GPIO_SIG206_IN_SEL_V: u32 = 1;
pub const GPIO_SIG206_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC206_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC206_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC206_IN_SEL: u32 = 63;
pub const GPIO_FUNC206_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC206_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC207_IN_SEL_CFG_REG: u32 = 1072972908;
pub const GPIO_SIG207_IN_SEL_V: u32 = 1;
pub const GPIO_SIG207_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC207_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC207_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC207_IN_SEL: u32 = 63;
pub const GPIO_FUNC207_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC207_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC208_IN_SEL_CFG_REG: u32 = 1072972912;
pub const GPIO_SIG208_IN_SEL_V: u32 = 1;
pub const GPIO_SIG208_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC208_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC208_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC208_IN_SEL: u32 = 63;
pub const GPIO_FUNC208_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC208_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC209_IN_SEL_CFG_REG: u32 = 1072972916;
pub const GPIO_SIG209_IN_SEL_V: u32 = 1;
pub const GPIO_SIG209_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC209_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC209_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC209_IN_SEL: u32 = 63;
pub const GPIO_FUNC209_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC209_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC210_IN_SEL_CFG_REG: u32 = 1072972920;
pub const GPIO_SIG210_IN_SEL_V: u32 = 1;
pub const GPIO_SIG210_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC210_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC210_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC210_IN_SEL: u32 = 63;
pub const GPIO_FUNC210_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC210_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC211_IN_SEL_CFG_REG: u32 = 1072972924;
pub const GPIO_SIG211_IN_SEL_V: u32 = 1;
pub const GPIO_SIG211_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC211_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC211_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC211_IN_SEL: u32 = 63;
pub const GPIO_FUNC211_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC211_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC212_IN_SEL_CFG_REG: u32 = 1072972928;
pub const GPIO_SIG212_IN_SEL_V: u32 = 1;
pub const GPIO_SIG212_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC212_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC212_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC212_IN_SEL: u32 = 63;
pub const GPIO_FUNC212_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC212_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC213_IN_SEL_CFG_REG: u32 = 1072972932;
pub const GPIO_SIG213_IN_SEL_V: u32 = 1;
pub const GPIO_SIG213_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC213_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC213_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC213_IN_SEL: u32 = 63;
pub const GPIO_FUNC213_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC213_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC214_IN_SEL_CFG_REG: u32 = 1072972936;
pub const GPIO_SIG214_IN_SEL_V: u32 = 1;
pub const GPIO_SIG214_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC214_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC214_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC214_IN_SEL: u32 = 63;
pub const GPIO_FUNC214_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC214_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC215_IN_SEL_CFG_REG: u32 = 1072972940;
pub const GPIO_SIG215_IN_SEL_V: u32 = 1;
pub const GPIO_SIG215_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC215_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC215_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC215_IN_SEL: u32 = 63;
pub const GPIO_FUNC215_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC215_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC216_IN_SEL_CFG_REG: u32 = 1072972944;
pub const GPIO_SIG216_IN_SEL_V: u32 = 1;
pub const GPIO_SIG216_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC216_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC216_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC216_IN_SEL: u32 = 63;
pub const GPIO_FUNC216_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC216_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC217_IN_SEL_CFG_REG: u32 = 1072972948;
pub const GPIO_SIG217_IN_SEL_V: u32 = 1;
pub const GPIO_SIG217_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC217_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC217_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC217_IN_SEL: u32 = 63;
pub const GPIO_FUNC217_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC217_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC218_IN_SEL_CFG_REG: u32 = 1072972952;
pub const GPIO_SIG218_IN_SEL_V: u32 = 1;
pub const GPIO_SIG218_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC218_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC218_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC218_IN_SEL: u32 = 63;
pub const GPIO_FUNC218_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC218_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC219_IN_SEL_CFG_REG: u32 = 1072972956;
pub const GPIO_SIG219_IN_SEL_V: u32 = 1;
pub const GPIO_SIG219_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC219_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC219_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC219_IN_SEL: u32 = 63;
pub const GPIO_FUNC219_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC219_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC220_IN_SEL_CFG_REG: u32 = 1072972960;
pub const GPIO_SIG220_IN_SEL_V: u32 = 1;
pub const GPIO_SIG220_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC220_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC220_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC220_IN_SEL: u32 = 63;
pub const GPIO_FUNC220_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC220_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC221_IN_SEL_CFG_REG: u32 = 1072972964;
pub const GPIO_SIG221_IN_SEL_V: u32 = 1;
pub const GPIO_SIG221_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC221_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC221_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC221_IN_SEL: u32 = 63;
pub const GPIO_FUNC221_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC221_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC222_IN_SEL_CFG_REG: u32 = 1072972968;
pub const GPIO_SIG222_IN_SEL_V: u32 = 1;
pub const GPIO_SIG222_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC222_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC222_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC222_IN_SEL: u32 = 63;
pub const GPIO_FUNC222_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC222_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC223_IN_SEL_CFG_REG: u32 = 1072972972;
pub const GPIO_SIG223_IN_SEL_V: u32 = 1;
pub const GPIO_SIG223_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC223_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC223_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC223_IN_SEL: u32 = 63;
pub const GPIO_FUNC223_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC223_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC224_IN_SEL_CFG_REG: u32 = 1072972976;
pub const GPIO_SIG224_IN_SEL_V: u32 = 1;
pub const GPIO_SIG224_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC224_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC224_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC224_IN_SEL: u32 = 63;
pub const GPIO_FUNC224_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC224_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC225_IN_SEL_CFG_REG: u32 = 1072972980;
pub const GPIO_SIG225_IN_SEL_V: u32 = 1;
pub const GPIO_SIG225_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC225_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC225_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC225_IN_SEL: u32 = 63;
pub const GPIO_FUNC225_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC225_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC226_IN_SEL_CFG_REG: u32 = 1072972984;
pub const GPIO_SIG226_IN_SEL_V: u32 = 1;
pub const GPIO_SIG226_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC226_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC226_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC226_IN_SEL: u32 = 63;
pub const GPIO_FUNC226_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC226_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC227_IN_SEL_CFG_REG: u32 = 1072972988;
pub const GPIO_SIG227_IN_SEL_V: u32 = 1;
pub const GPIO_SIG227_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC227_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC227_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC227_IN_SEL: u32 = 63;
pub const GPIO_FUNC227_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC227_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC228_IN_SEL_CFG_REG: u32 = 1072972992;
pub const GPIO_SIG228_IN_SEL_V: u32 = 1;
pub const GPIO_SIG228_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC228_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC228_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC228_IN_SEL: u32 = 63;
pub const GPIO_FUNC228_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC228_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC229_IN_SEL_CFG_REG: u32 = 1072972996;
pub const GPIO_SIG229_IN_SEL_V: u32 = 1;
pub const GPIO_SIG229_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC229_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC229_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC229_IN_SEL: u32 = 63;
pub const GPIO_FUNC229_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC229_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC230_IN_SEL_CFG_REG: u32 = 1072973000;
pub const GPIO_SIG230_IN_SEL_V: u32 = 1;
pub const GPIO_SIG230_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC230_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC230_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC230_IN_SEL: u32 = 63;
pub const GPIO_FUNC230_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC230_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC231_IN_SEL_CFG_REG: u32 = 1072973004;
pub const GPIO_SIG231_IN_SEL_V: u32 = 1;
pub const GPIO_SIG231_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC231_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC231_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC231_IN_SEL: u32 = 63;
pub const GPIO_FUNC231_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC231_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC232_IN_SEL_CFG_REG: u32 = 1072973008;
pub const GPIO_SIG232_IN_SEL_V: u32 = 1;
pub const GPIO_SIG232_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC232_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC232_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC232_IN_SEL: u32 = 63;
pub const GPIO_FUNC232_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC232_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC233_IN_SEL_CFG_REG: u32 = 1072973012;
pub const GPIO_SIG233_IN_SEL_V: u32 = 1;
pub const GPIO_SIG233_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC233_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC233_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC233_IN_SEL: u32 = 63;
pub const GPIO_FUNC233_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC233_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC234_IN_SEL_CFG_REG: u32 = 1072973016;
pub const GPIO_SIG234_IN_SEL_V: u32 = 1;
pub const GPIO_SIG234_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC234_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC234_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC234_IN_SEL: u32 = 63;
pub const GPIO_FUNC234_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC234_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC235_IN_SEL_CFG_REG: u32 = 1072973020;
pub const GPIO_SIG235_IN_SEL_V: u32 = 1;
pub const GPIO_SIG235_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC235_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC235_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC235_IN_SEL: u32 = 63;
pub const GPIO_FUNC235_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC235_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC236_IN_SEL_CFG_REG: u32 = 1072973024;
pub const GPIO_SIG236_IN_SEL_V: u32 = 1;
pub const GPIO_SIG236_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC236_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC236_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC236_IN_SEL: u32 = 63;
pub const GPIO_FUNC236_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC236_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC237_IN_SEL_CFG_REG: u32 = 1072973028;
pub const GPIO_SIG237_IN_SEL_V: u32 = 1;
pub const GPIO_SIG237_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC237_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC237_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC237_IN_SEL: u32 = 63;
pub const GPIO_FUNC237_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC237_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC238_IN_SEL_CFG_REG: u32 = 1072973032;
pub const GPIO_SIG238_IN_SEL_V: u32 = 1;
pub const GPIO_SIG238_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC238_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC238_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC238_IN_SEL: u32 = 63;
pub const GPIO_FUNC238_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC238_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC239_IN_SEL_CFG_REG: u32 = 1072973036;
pub const GPIO_SIG239_IN_SEL_V: u32 = 1;
pub const GPIO_SIG239_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC239_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC239_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC239_IN_SEL: u32 = 63;
pub const GPIO_FUNC239_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC239_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC240_IN_SEL_CFG_REG: u32 = 1072973040;
pub const GPIO_SIG240_IN_SEL_V: u32 = 1;
pub const GPIO_SIG240_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC240_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC240_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC240_IN_SEL: u32 = 63;
pub const GPIO_FUNC240_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC240_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC241_IN_SEL_CFG_REG: u32 = 1072973044;
pub const GPIO_SIG241_IN_SEL_V: u32 = 1;
pub const GPIO_SIG241_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC241_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC241_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC241_IN_SEL: u32 = 63;
pub const GPIO_FUNC241_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC241_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC242_IN_SEL_CFG_REG: u32 = 1072973048;
pub const GPIO_SIG242_IN_SEL_V: u32 = 1;
pub const GPIO_SIG242_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC242_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC242_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC242_IN_SEL: u32 = 63;
pub const GPIO_FUNC242_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC242_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC243_IN_SEL_CFG_REG: u32 = 1072973052;
pub const GPIO_SIG243_IN_SEL_V: u32 = 1;
pub const GPIO_SIG243_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC243_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC243_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC243_IN_SEL: u32 = 63;
pub const GPIO_FUNC243_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC243_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC244_IN_SEL_CFG_REG: u32 = 1072973056;
pub const GPIO_SIG244_IN_SEL_V: u32 = 1;
pub const GPIO_SIG244_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC244_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC244_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC244_IN_SEL: u32 = 63;
pub const GPIO_FUNC244_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC244_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC245_IN_SEL_CFG_REG: u32 = 1072973060;
pub const GPIO_SIG245_IN_SEL_V: u32 = 1;
pub const GPIO_SIG245_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC245_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC245_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC245_IN_SEL: u32 = 63;
pub const GPIO_FUNC245_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC245_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC246_IN_SEL_CFG_REG: u32 = 1072973064;
pub const GPIO_SIG246_IN_SEL_V: u32 = 1;
pub const GPIO_SIG246_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC246_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC246_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC246_IN_SEL: u32 = 63;
pub const GPIO_FUNC246_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC246_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC247_IN_SEL_CFG_REG: u32 = 1072973068;
pub const GPIO_SIG247_IN_SEL_V: u32 = 1;
pub const GPIO_SIG247_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC247_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC247_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC247_IN_SEL: u32 = 63;
pub const GPIO_FUNC247_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC247_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC248_IN_SEL_CFG_REG: u32 = 1072973072;
pub const GPIO_SIG248_IN_SEL_V: u32 = 1;
pub const GPIO_SIG248_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC248_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC248_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC248_IN_SEL: u32 = 63;
pub const GPIO_FUNC248_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC248_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC249_IN_SEL_CFG_REG: u32 = 1072973076;
pub const GPIO_SIG249_IN_SEL_V: u32 = 1;
pub const GPIO_SIG249_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC249_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC249_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC249_IN_SEL: u32 = 63;
pub const GPIO_FUNC249_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC249_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC250_IN_SEL_CFG_REG: u32 = 1072973080;
pub const GPIO_SIG250_IN_SEL_V: u32 = 1;
pub const GPIO_SIG250_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC250_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC250_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC250_IN_SEL: u32 = 63;
pub const GPIO_FUNC250_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC250_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC251_IN_SEL_CFG_REG: u32 = 1072973084;
pub const GPIO_SIG251_IN_SEL_V: u32 = 1;
pub const GPIO_SIG251_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC251_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC251_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC251_IN_SEL: u32 = 63;
pub const GPIO_FUNC251_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC251_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC252_IN_SEL_CFG_REG: u32 = 1072973088;
pub const GPIO_SIG252_IN_SEL_V: u32 = 1;
pub const GPIO_SIG252_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC252_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC252_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC252_IN_SEL: u32 = 63;
pub const GPIO_FUNC252_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC252_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC253_IN_SEL_CFG_REG: u32 = 1072973092;
pub const GPIO_SIG253_IN_SEL_V: u32 = 1;
pub const GPIO_SIG253_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC253_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC253_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC253_IN_SEL: u32 = 63;
pub const GPIO_FUNC253_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC253_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC254_IN_SEL_CFG_REG: u32 = 1072973096;
pub const GPIO_SIG254_IN_SEL_V: u32 = 1;
pub const GPIO_SIG254_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC254_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC254_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC254_IN_SEL: u32 = 63;
pub const GPIO_FUNC254_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC254_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC255_IN_SEL_CFG_REG: u32 = 1072973100;
pub const GPIO_SIG255_IN_SEL_V: u32 = 1;
pub const GPIO_SIG255_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC255_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC255_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC255_IN_SEL: u32 = 63;
pub const GPIO_FUNC255_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC255_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC0_OUT_SEL_CFG_REG: u32 = 1072973104;
pub const GPIO_FUNC0_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC0_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC0_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC0_OUT_SEL: u32 = 511;
pub const GPIO_FUNC0_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC0_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC1_OUT_SEL_CFG_REG: u32 = 1072973108;
pub const GPIO_FUNC1_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC1_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC1_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC1_OUT_SEL: u32 = 511;
pub const GPIO_FUNC1_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC1_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC2_OUT_SEL_CFG_REG: u32 = 1072973112;
pub const GPIO_FUNC2_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC2_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC2_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC2_OUT_SEL: u32 = 511;
pub const GPIO_FUNC2_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC2_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC3_OUT_SEL_CFG_REG: u32 = 1072973116;
pub const GPIO_FUNC3_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC3_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC3_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC3_OUT_SEL: u32 = 511;
pub const GPIO_FUNC3_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC3_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC4_OUT_SEL_CFG_REG: u32 = 1072973120;
pub const GPIO_FUNC4_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC4_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC4_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC4_OUT_SEL: u32 = 511;
pub const GPIO_FUNC4_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC4_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC5_OUT_SEL_CFG_REG: u32 = 1072973124;
pub const GPIO_FUNC5_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC5_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC5_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC5_OUT_SEL: u32 = 511;
pub const GPIO_FUNC5_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC5_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC6_OUT_SEL_CFG_REG: u32 = 1072973128;
pub const GPIO_FUNC6_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC6_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC6_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC6_OUT_SEL: u32 = 511;
pub const GPIO_FUNC6_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC6_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC7_OUT_SEL_CFG_REG: u32 = 1072973132;
pub const GPIO_FUNC7_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC7_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC7_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC7_OUT_SEL: u32 = 511;
pub const GPIO_FUNC7_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC7_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC8_OUT_SEL_CFG_REG: u32 = 1072973136;
pub const GPIO_FUNC8_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC8_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC8_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC8_OUT_SEL: u32 = 511;
pub const GPIO_FUNC8_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC8_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC9_OUT_SEL_CFG_REG: u32 = 1072973140;
pub const GPIO_FUNC9_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC9_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC9_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC9_OUT_SEL: u32 = 511;
pub const GPIO_FUNC9_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC9_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC10_OUT_SEL_CFG_REG: u32 = 1072973144;
pub const GPIO_FUNC10_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC10_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC10_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC10_OUT_SEL: u32 = 511;
pub const GPIO_FUNC10_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC10_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC11_OUT_SEL_CFG_REG: u32 = 1072973148;
pub const GPIO_FUNC11_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC11_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC11_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC11_OUT_SEL: u32 = 511;
pub const GPIO_FUNC11_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC11_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC12_OUT_SEL_CFG_REG: u32 = 1072973152;
pub const GPIO_FUNC12_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC12_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC12_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC12_OUT_SEL: u32 = 511;
pub const GPIO_FUNC12_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC12_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC13_OUT_SEL_CFG_REG: u32 = 1072973156;
pub const GPIO_FUNC13_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC13_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC13_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC13_OUT_SEL: u32 = 511;
pub const GPIO_FUNC13_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC13_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC14_OUT_SEL_CFG_REG: u32 = 1072973160;
pub const GPIO_FUNC14_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC14_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC14_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC14_OUT_SEL: u32 = 511;
pub const GPIO_FUNC14_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC14_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC15_OUT_SEL_CFG_REG: u32 = 1072973164;
pub const GPIO_FUNC15_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC15_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC15_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC15_OUT_SEL: u32 = 511;
pub const GPIO_FUNC15_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC15_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC16_OUT_SEL_CFG_REG: u32 = 1072973168;
pub const GPIO_FUNC16_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC16_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC16_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC16_OUT_SEL: u32 = 511;
pub const GPIO_FUNC16_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC16_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC17_OUT_SEL_CFG_REG: u32 = 1072973172;
pub const GPIO_FUNC17_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC17_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC17_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC17_OUT_SEL: u32 = 511;
pub const GPIO_FUNC17_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC17_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC18_OUT_SEL_CFG_REG: u32 = 1072973176;
pub const GPIO_FUNC18_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC18_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC18_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC18_OUT_SEL: u32 = 511;
pub const GPIO_FUNC18_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC18_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC19_OUT_SEL_CFG_REG: u32 = 1072973180;
pub const GPIO_FUNC19_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC19_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC19_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC19_OUT_SEL: u32 = 511;
pub const GPIO_FUNC19_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC19_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC20_OUT_SEL_CFG_REG: u32 = 1072973184;
pub const GPIO_FUNC20_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC20_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC20_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC20_OUT_SEL: u32 = 511;
pub const GPIO_FUNC20_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC20_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC21_OUT_SEL_CFG_REG: u32 = 1072973188;
pub const GPIO_FUNC21_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC21_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC21_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC21_OUT_SEL: u32 = 511;
pub const GPIO_FUNC21_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC21_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC22_OUT_SEL_CFG_REG: u32 = 1072973192;
pub const GPIO_FUNC22_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC22_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC22_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC22_OUT_SEL: u32 = 511;
pub const GPIO_FUNC22_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC22_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC23_OUT_SEL_CFG_REG: u32 = 1072973196;
pub const GPIO_FUNC23_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC23_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC23_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC23_OUT_SEL: u32 = 511;
pub const GPIO_FUNC23_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC23_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC24_OUT_SEL_CFG_REG: u32 = 1072973200;
pub const GPIO_FUNC24_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC24_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC24_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC24_OUT_SEL: u32 = 511;
pub const GPIO_FUNC24_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC24_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC25_OUT_SEL_CFG_REG: u32 = 1072973204;
pub const GPIO_FUNC25_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC25_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC25_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC25_OUT_SEL: u32 = 511;
pub const GPIO_FUNC25_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC25_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC26_OUT_SEL_CFG_REG: u32 = 1072973208;
pub const GPIO_FUNC26_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC26_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC26_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC26_OUT_SEL: u32 = 511;
pub const GPIO_FUNC26_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC26_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC27_OUT_SEL_CFG_REG: u32 = 1072973212;
pub const GPIO_FUNC27_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC27_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC27_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC27_OUT_SEL: u32 = 511;
pub const GPIO_FUNC27_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC27_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC28_OUT_SEL_CFG_REG: u32 = 1072973216;
pub const GPIO_FUNC28_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC28_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC28_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC28_OUT_SEL: u32 = 511;
pub const GPIO_FUNC28_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC28_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC29_OUT_SEL_CFG_REG: u32 = 1072973220;
pub const GPIO_FUNC29_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC29_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC29_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC29_OUT_SEL: u32 = 511;
pub const GPIO_FUNC29_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC29_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC30_OUT_SEL_CFG_REG: u32 = 1072973224;
pub const GPIO_FUNC30_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC30_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC30_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC30_OUT_SEL: u32 = 511;
pub const GPIO_FUNC30_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC30_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC31_OUT_SEL_CFG_REG: u32 = 1072973228;
pub const GPIO_FUNC31_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC31_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC31_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC31_OUT_SEL: u32 = 511;
pub const GPIO_FUNC31_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC31_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC32_OUT_SEL_CFG_REG: u32 = 1072973232;
pub const GPIO_FUNC32_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC32_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC32_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC32_OUT_SEL: u32 = 511;
pub const GPIO_FUNC32_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC32_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC33_OUT_SEL_CFG_REG: u32 = 1072973236;
pub const GPIO_FUNC33_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC33_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC33_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC33_OUT_SEL: u32 = 511;
pub const GPIO_FUNC33_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC33_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC34_OUT_SEL_CFG_REG: u32 = 1072973240;
pub const GPIO_FUNC34_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC34_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC34_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC34_OUT_SEL: u32 = 511;
pub const GPIO_FUNC34_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC34_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC35_OUT_SEL_CFG_REG: u32 = 1072973244;
pub const GPIO_FUNC35_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC35_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC35_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC35_OUT_SEL: u32 = 511;
pub const GPIO_FUNC35_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC35_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC36_OUT_SEL_CFG_REG: u32 = 1072973248;
pub const GPIO_FUNC36_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC36_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC36_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC36_OUT_SEL: u32 = 511;
pub const GPIO_FUNC36_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC36_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC37_OUT_SEL_CFG_REG: u32 = 1072973252;
pub const GPIO_FUNC37_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC37_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC37_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC37_OUT_SEL: u32 = 511;
pub const GPIO_FUNC37_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC37_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC38_OUT_SEL_CFG_REG: u32 = 1072973256;
pub const GPIO_FUNC38_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC38_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC38_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC38_OUT_SEL: u32 = 511;
pub const GPIO_FUNC38_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC38_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC39_OUT_SEL_CFG_REG: u32 = 1072973260;
pub const GPIO_FUNC39_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC39_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC39_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC39_OUT_SEL: u32 = 511;
pub const GPIO_FUNC39_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC39_OUT_SEL_S: u32 = 0;
pub const SPICLK_IN_IDX: u32 = 0;
pub const SPICLK_OUT_IDX: u32 = 0;
pub const SPIQ_IN_IDX: u32 = 1;
pub const SPIQ_OUT_IDX: u32 = 1;
pub const SPID_IN_IDX: u32 = 2;
pub const SPID_OUT_IDX: u32 = 2;
pub const SPIHD_IN_IDX: u32 = 3;
pub const SPIHD_OUT_IDX: u32 = 3;
pub const SPIWP_IN_IDX: u32 = 4;
pub const SPIWP_OUT_IDX: u32 = 4;
pub const SPICS0_IN_IDX: u32 = 5;
pub const SPICS0_OUT_IDX: u32 = 5;
pub const SPICS1_IN_IDX: u32 = 6;
pub const SPICS1_OUT_IDX: u32 = 6;
pub const SPICS2_IN_IDX: u32 = 7;
pub const SPICS2_OUT_IDX: u32 = 7;
pub const HSPICLK_IN_IDX: u32 = 8;
pub const HSPICLK_OUT_IDX: u32 = 8;
pub const HSPIQ_IN_IDX: u32 = 9;
pub const HSPIQ_OUT_IDX: u32 = 9;
pub const HSPID_IN_IDX: u32 = 10;
pub const HSPID_OUT_IDX: u32 = 10;
pub const HSPICS0_IN_IDX: u32 = 11;
pub const HSPICS0_OUT_IDX: u32 = 11;
pub const HSPIHD_IN_IDX: u32 = 12;
pub const HSPIHD_OUT_IDX: u32 = 12;
pub const HSPIWP_IN_IDX: u32 = 13;
pub const HSPIWP_OUT_IDX: u32 = 13;
pub const U0RXD_IN_IDX: u32 = 14;
pub const U0TXD_OUT_IDX: u32 = 14;
pub const U0CTS_IN_IDX: u32 = 15;
pub const U0RTS_OUT_IDX: u32 = 15;
pub const U0DSR_IN_IDX: u32 = 16;
pub const U0DTR_OUT_IDX: u32 = 16;
pub const U1RXD_IN_IDX: u32 = 17;
pub const U1TXD_OUT_IDX: u32 = 17;
pub const U1CTS_IN_IDX: u32 = 18;
pub const U1RTS_OUT_IDX: u32 = 18;
pub const I2CM_SCL_O_IDX: u32 = 19;
pub const I2CM_SDA_I_IDX: u32 = 20;
pub const I2CM_SDA_O_IDX: u32 = 20;
pub const EXT_I2C_SCL_O_IDX: u32 = 21;
pub const EXT_I2C_SDA_O_IDX: u32 = 22;
pub const EXT_I2C_SDA_I_IDX: u32 = 22;
pub const I2S0O_BCK_IN_IDX: u32 = 23;
pub const I2S0O_BCK_OUT_IDX: u32 = 23;
pub const I2S1O_BCK_IN_IDX: u32 = 24;
pub const I2S1O_BCK_OUT_IDX: u32 = 24;
pub const I2S0O_WS_IN_IDX: u32 = 25;
pub const I2S0O_WS_OUT_IDX: u32 = 25;
pub const I2S1O_WS_IN_IDX: u32 = 26;
pub const I2S1O_WS_OUT_IDX: u32 = 26;
pub const I2S0I_BCK_IN_IDX: u32 = 27;
pub const I2S0I_BCK_OUT_IDX: u32 = 27;
pub const I2S0I_WS_IN_IDX: u32 = 28;
pub const I2S0I_WS_OUT_IDX: u32 = 28;
pub const I2CEXT0_SCL_IN_IDX: u32 = 29;
pub const I2CEXT0_SCL_OUT_IDX: u32 = 29;
pub const I2CEXT0_SDA_IN_IDX: u32 = 30;
pub const I2CEXT0_SDA_OUT_IDX: u32 = 30;
pub const PWM0_SYNC0_IN_IDX: u32 = 31;
pub const SDIO_TOHOST_INT_OUT_IDX: u32 = 31;
pub const PWM0_SYNC1_IN_IDX: u32 = 32;
pub const PWM0_OUT0A_IDX: u32 = 32;
pub const PWM0_SYNC2_IN_IDX: u32 = 33;
pub const PWM0_OUT0B_IDX: u32 = 33;
pub const PWM0_F0_IN_IDX: u32 = 34;
pub const PWM0_OUT1A_IDX: u32 = 34;
pub const PWM0_F1_IN_IDX: u32 = 35;
pub const PWM0_OUT1B_IDX: u32 = 35;
pub const PWM0_F2_IN_IDX: u32 = 36;
pub const PWM0_OUT2A_IDX: u32 = 36;
pub const GPIO_BT_ACTIVE_IDX: u32 = 37;
pub const PWM0_OUT2B_IDX: u32 = 37;
pub const GPIO_BT_PRIORITY_IDX: u32 = 38;
pub const PCNT_SIG_CH0_IN0_IDX: u32 = 39;
pub const PCNT_SIG_CH1_IN0_IDX: u32 = 40;
pub const GPIO_WLAN_ACTIVE_IDX: u32 = 40;
pub const PCNT_CTRL_CH0_IN0_IDX: u32 = 41;
pub const BB_DIAG0_IDX: u32 = 41;
pub const PCNT_CTRL_CH1_IN0_IDX: u32 = 42;
pub const BB_DIAG1_IDX: u32 = 42;
pub const PCNT_SIG_CH0_IN1_IDX: u32 = 43;
pub const BB_DIAG2_IDX: u32 = 43;
pub const PCNT_SIG_CH1_IN1_IDX: u32 = 44;
pub const BB_DIAG3_IDX: u32 = 44;
pub const PCNT_CTRL_CH0_IN1_IDX: u32 = 45;
pub const BB_DIAG4_IDX: u32 = 45;
pub const PCNT_CTRL_CH1_IN1_IDX: u32 = 46;
pub const BB_DIAG5_IDX: u32 = 46;
pub const PCNT_SIG_CH0_IN2_IDX: u32 = 47;
pub const BB_DIAG6_IDX: u32 = 47;
pub const PCNT_SIG_CH1_IN2_IDX: u32 = 48;
pub const BB_DIAG7_IDX: u32 = 48;
pub const PCNT_CTRL_CH0_IN2_IDX: u32 = 49;
pub const BB_DIAG8_IDX: u32 = 49;
pub const PCNT_CTRL_CH1_IN2_IDX: u32 = 50;
pub const BB_DIAG9_IDX: u32 = 50;
pub const PCNT_SIG_CH0_IN3_IDX: u32 = 51;
pub const BB_DIAG10_IDX: u32 = 51;
pub const PCNT_SIG_CH1_IN3_IDX: u32 = 52;
pub const BB_DIAG11_IDX: u32 = 52;
pub const PCNT_CTRL_CH0_IN3_IDX: u32 = 53;
pub const BB_DIAG12_IDX: u32 = 53;
pub const PCNT_CTRL_CH1_IN3_IDX: u32 = 54;
pub const BB_DIAG13_IDX: u32 = 54;
pub const PCNT_SIG_CH0_IN4_IDX: u32 = 55;
pub const BB_DIAG14_IDX: u32 = 55;
pub const PCNT_SIG_CH1_IN4_IDX: u32 = 56;
pub const BB_DIAG15_IDX: u32 = 56;
pub const PCNT_CTRL_CH0_IN4_IDX: u32 = 57;
pub const BB_DIAG16_IDX: u32 = 57;
pub const PCNT_CTRL_CH1_IN4_IDX: u32 = 58;
pub const BB_DIAG17_IDX: u32 = 58;
pub const BB_DIAG18_IDX: u32 = 59;
pub const BB_DIAG19_IDX: u32 = 60;
pub const HSPICS1_IN_IDX: u32 = 61;
pub const HSPICS1_OUT_IDX: u32 = 61;
pub const HSPICS2_IN_IDX: u32 = 62;
pub const HSPICS2_OUT_IDX: u32 = 62;
pub const VSPICLK_IN_IDX: u32 = 63;
pub const VSPICLK_OUT_IDX: u32 = 63;
pub const VSPIQ_IN_IDX: u32 = 64;
pub const VSPIQ_OUT_IDX: u32 = 64;
pub const VSPID_IN_IDX: u32 = 65;
pub const VSPID_OUT_IDX: u32 = 65;
pub const VSPIHD_IN_IDX: u32 = 66;
pub const VSPIHD_OUT_IDX: u32 = 66;
pub const VSPIWP_IN_IDX: u32 = 67;
pub const VSPIWP_OUT_IDX: u32 = 67;
pub const VSPICS0_IN_IDX: u32 = 68;
pub const VSPICS0_OUT_IDX: u32 = 68;
pub const VSPICS1_IN_IDX: u32 = 69;
pub const VSPICS1_OUT_IDX: u32 = 69;
pub const VSPICS2_IN_IDX: u32 = 70;
pub const VSPICS2_OUT_IDX: u32 = 70;
pub const PCNT_SIG_CH0_IN5_IDX: u32 = 71;
pub const LEDC_HS_SIG_OUT0_IDX: u32 = 71;
pub const PCNT_SIG_CH1_IN5_IDX: u32 = 72;
pub const LEDC_HS_SIG_OUT1_IDX: u32 = 72;
pub const PCNT_CTRL_CH0_IN5_IDX: u32 = 73;
pub const LEDC_HS_SIG_OUT2_IDX: u32 = 73;
pub const PCNT_CTRL_CH1_IN5_IDX: u32 = 74;
pub const LEDC_HS_SIG_OUT3_IDX: u32 = 74;
pub const PCNT_SIG_CH0_IN6_IDX: u32 = 75;
pub const LEDC_HS_SIG_OUT4_IDX: u32 = 75;
pub const PCNT_SIG_CH1_IN6_IDX: u32 = 76;
pub const LEDC_HS_SIG_OUT5_IDX: u32 = 76;
pub const PCNT_CTRL_CH0_IN6_IDX: u32 = 77;
pub const LEDC_HS_SIG_OUT6_IDX: u32 = 77;
pub const PCNT_CTRL_CH1_IN6_IDX: u32 = 78;
pub const LEDC_HS_SIG_OUT7_IDX: u32 = 78;
pub const PCNT_SIG_CH0_IN7_IDX: u32 = 79;
pub const LEDC_LS_SIG_OUT0_IDX: u32 = 79;
pub const PCNT_SIG_CH1_IN7_IDX: u32 = 80;
pub const LEDC_LS_SIG_OUT1_IDX: u32 = 80;
pub const PCNT_CTRL_CH0_IN7_IDX: u32 = 81;
pub const LEDC_LS_SIG_OUT2_IDX: u32 = 81;
pub const PCNT_CTRL_CH1_IN7_IDX: u32 = 82;
pub const LEDC_LS_SIG_OUT3_IDX: u32 = 82;
pub const RMT_SIG_IN0_IDX: u32 = 83;
pub const LEDC_LS_SIG_OUT4_IDX: u32 = 83;
pub const RMT_SIG_IN1_IDX: u32 = 84;
pub const LEDC_LS_SIG_OUT5_IDX: u32 = 84;
pub const RMT_SIG_IN2_IDX: u32 = 85;
pub const LEDC_LS_SIG_OUT6_IDX: u32 = 85;
pub const RMT_SIG_IN3_IDX: u32 = 86;
pub const LEDC_LS_SIG_OUT7_IDX: u32 = 86;
pub const RMT_SIG_IN4_IDX: u32 = 87;
pub const RMT_SIG_OUT0_IDX: u32 = 87;
pub const RMT_SIG_IN5_IDX: u32 = 88;
pub const RMT_SIG_OUT1_IDX: u32 = 88;
pub const RMT_SIG_IN6_IDX: u32 = 89;
pub const RMT_SIG_OUT2_IDX: u32 = 89;
pub const RMT_SIG_IN7_IDX: u32 = 90;
pub const RMT_SIG_OUT3_IDX: u32 = 90;
pub const RMT_SIG_OUT4_IDX: u32 = 91;
pub const RMT_SIG_OUT5_IDX: u32 = 92;
pub const EXT_ADC_START_IDX: u32 = 93;
pub const RMT_SIG_OUT6_IDX: u32 = 93;
pub const CAN_RX_IDX: u32 = 94;
pub const RMT_SIG_OUT7_IDX: u32 = 94;
pub const I2CEXT1_SCL_IN_IDX: u32 = 95;
pub const I2CEXT1_SCL_OUT_IDX: u32 = 95;
pub const I2CEXT1_SDA_IN_IDX: u32 = 96;
pub const I2CEXT1_SDA_OUT_IDX: u32 = 96;
pub const HOST_CARD_DETECT_N_1_IDX: u32 = 97;
pub const HOST_CCMD_OD_PULLUP_EN_N_IDX: u32 = 97;
pub const HOST_CARD_DETECT_N_2_IDX: u32 = 98;
pub const HOST_RST_N_1_IDX: u32 = 98;
pub const HOST_CARD_WRITE_PRT_1_IDX: u32 = 99;
pub const HOST_RST_N_2_IDX: u32 = 99;
pub const HOST_CARD_WRITE_PRT_2_IDX: u32 = 100;
pub const GPIO_SD0_OUT_IDX: u32 = 100;
pub const HOST_CARD_INT_N_1_IDX: u32 = 101;
pub const GPIO_SD1_OUT_IDX: u32 = 101;
pub const HOST_CARD_INT_N_2_IDX: u32 = 102;
pub const GPIO_SD2_OUT_IDX: u32 = 102;
pub const PWM1_SYNC0_IN_IDX: u32 = 103;
pub const GPIO_SD3_OUT_IDX: u32 = 103;
pub const PWM1_SYNC1_IN_IDX: u32 = 104;
pub const GPIO_SD4_OUT_IDX: u32 = 104;
pub const PWM1_SYNC2_IN_IDX: u32 = 105;
pub const GPIO_SD5_OUT_IDX: u32 = 105;
pub const PWM1_F0_IN_IDX: u32 = 106;
pub const GPIO_SD6_OUT_IDX: u32 = 106;
pub const PWM1_F1_IN_IDX: u32 = 107;
pub const GPIO_SD7_OUT_IDX: u32 = 107;
pub const PWM1_F2_IN_IDX: u32 = 108;
pub const PWM1_OUT0A_IDX: u32 = 108;
pub const PWM0_CAP0_IN_IDX: u32 = 109;
pub const PWM1_OUT0B_IDX: u32 = 109;
pub const PWM0_CAP1_IN_IDX: u32 = 110;
pub const PWM1_OUT1A_IDX: u32 = 110;
pub const PWM0_CAP2_IN_IDX: u32 = 111;
pub const PWM1_OUT1B_IDX: u32 = 111;
pub const PWM1_CAP0_IN_IDX: u32 = 112;
pub const PWM1_OUT2A_IDX: u32 = 112;
pub const PWM1_CAP1_IN_IDX: u32 = 113;
pub const PWM1_OUT2B_IDX: u32 = 113;
pub const PWM1_CAP2_IN_IDX: u32 = 114;
pub const PWM2_OUT1H_IDX: u32 = 114;
pub const PWM2_FLTA_IDX: u32 = 115;
pub const PWM2_OUT1L_IDX: u32 = 115;
pub const PWM2_FLTB_IDX: u32 = 116;
pub const PWM2_OUT2H_IDX: u32 = 116;
pub const PWM2_CAP1_IN_IDX: u32 = 117;
pub const PWM2_OUT2L_IDX: u32 = 117;
pub const PWM2_CAP2_IN_IDX: u32 = 118;
pub const PWM2_OUT3H_IDX: u32 = 118;
pub const PWM2_CAP3_IN_IDX: u32 = 119;
pub const PWM2_OUT3L_IDX: u32 = 119;
pub const PWM3_FLTA_IDX: u32 = 120;
pub const PWM2_OUT4H_IDX: u32 = 120;
pub const PWM3_FLTB_IDX: u32 = 121;
pub const PWM2_OUT4L_IDX: u32 = 121;
pub const PWM3_CAP1_IN_IDX: u32 = 122;
pub const PWM3_CAP2_IN_IDX: u32 = 123;
pub const CAN_TX_IDX: u32 = 123;
pub const PWM3_CAP3_IN_IDX: u32 = 124;
pub const CAN_BUS_OFF_ON_IDX: u32 = 124;
pub const CAN_CLKOUT_IDX: u32 = 125;
pub const SPID4_IN_IDX: u32 = 128;
pub const SPID4_OUT_IDX: u32 = 128;
pub const SPID5_IN_IDX: u32 = 129;
pub const SPID5_OUT_IDX: u32 = 129;
pub const SPID6_IN_IDX: u32 = 130;
pub const SPID6_OUT_IDX: u32 = 130;
pub const SPID7_IN_IDX: u32 = 131;
pub const SPID7_OUT_IDX: u32 = 131;
pub const HSPID4_IN_IDX: u32 = 132;
pub const HSPID4_OUT_IDX: u32 = 132;
pub const HSPID5_IN_IDX: u32 = 133;
pub const HSPID5_OUT_IDX: u32 = 133;
pub const HSPID6_IN_IDX: u32 = 134;
pub const HSPID6_OUT_IDX: u32 = 134;
pub const HSPID7_IN_IDX: u32 = 135;
pub const HSPID7_OUT_IDX: u32 = 135;
pub const VSPID4_IN_IDX: u32 = 136;
pub const VSPID4_OUT_IDX: u32 = 136;
pub const VSPID5_IN_IDX: u32 = 137;
pub const VSPID5_OUT_IDX: u32 = 137;
pub const VSPID6_IN_IDX: u32 = 138;
pub const VSPID6_OUT_IDX: u32 = 138;
pub const VSPID7_IN_IDX: u32 = 139;
pub const VSPID7_OUT_IDX: u32 = 139;
pub const I2S0I_DATA_IN0_IDX: u32 = 140;
pub const I2S0O_DATA_OUT0_IDX: u32 = 140;
pub const I2S0I_DATA_IN1_IDX: u32 = 141;
pub const I2S0O_DATA_OUT1_IDX: u32 = 141;
pub const I2S0I_DATA_IN2_IDX: u32 = 142;
pub const I2S0O_DATA_OUT2_IDX: u32 = 142;
pub const I2S0I_DATA_IN3_IDX: u32 = 143;
pub const I2S0O_DATA_OUT3_IDX: u32 = 143;
pub const I2S0I_DATA_IN4_IDX: u32 = 144;
pub const I2S0O_DATA_OUT4_IDX: u32 = 144;
pub const I2S0I_DATA_IN5_IDX: u32 = 145;
pub const I2S0O_DATA_OUT5_IDX: u32 = 145;
pub const I2S0I_DATA_IN6_IDX: u32 = 146;
pub const I2S0O_DATA_OUT6_IDX: u32 = 146;
pub const I2S0I_DATA_IN7_IDX: u32 = 147;
pub const I2S0O_DATA_OUT7_IDX: u32 = 147;
pub const I2S0I_DATA_IN8_IDX: u32 = 148;
pub const I2S0O_DATA_OUT8_IDX: u32 = 148;
pub const I2S0I_DATA_IN9_IDX: u32 = 149;
pub const I2S0O_DATA_OUT9_IDX: u32 = 149;
pub const I2S0I_DATA_IN10_IDX: u32 = 150;
pub const I2S0O_DATA_OUT10_IDX: u32 = 150;
pub const I2S0I_DATA_IN11_IDX: u32 = 151;
pub const I2S0O_DATA_OUT11_IDX: u32 = 151;
pub const I2S0I_DATA_IN12_IDX: u32 = 152;
pub const I2S0O_DATA_OUT12_IDX: u32 = 152;
pub const I2S0I_DATA_IN13_IDX: u32 = 153;
pub const I2S0O_DATA_OUT13_IDX: u32 = 153;
pub const I2S0I_DATA_IN14_IDX: u32 = 154;
pub const I2S0O_DATA_OUT14_IDX: u32 = 154;
pub const I2S0I_DATA_IN15_IDX: u32 = 155;
pub const I2S0O_DATA_OUT15_IDX: u32 = 155;
pub const I2S0O_DATA_OUT16_IDX: u32 = 156;
pub const I2S0O_DATA_OUT17_IDX: u32 = 157;
pub const I2S0O_DATA_OUT18_IDX: u32 = 158;
pub const I2S0O_DATA_OUT19_IDX: u32 = 159;
pub const I2S0O_DATA_OUT20_IDX: u32 = 160;
pub const I2S0O_DATA_OUT21_IDX: u32 = 161;
pub const I2S0O_DATA_OUT22_IDX: u32 = 162;
pub const I2S0O_DATA_OUT23_IDX: u32 = 163;
pub const I2S1I_BCK_IN_IDX: u32 = 164;
pub const I2S1I_BCK_OUT_IDX: u32 = 164;
pub const I2S1I_WS_IN_IDX: u32 = 165;
pub const I2S1I_WS_OUT_IDX: u32 = 165;
pub const I2S1I_DATA_IN0_IDX: u32 = 166;
pub const I2S1O_DATA_OUT0_IDX: u32 = 166;
pub const I2S1I_DATA_IN1_IDX: u32 = 167;
pub const I2S1O_DATA_OUT1_IDX: u32 = 167;
pub const I2S1I_DATA_IN2_IDX: u32 = 168;
pub const I2S1O_DATA_OUT2_IDX: u32 = 168;
pub const I2S1I_DATA_IN3_IDX: u32 = 169;
pub const I2S1O_DATA_OUT3_IDX: u32 = 169;
pub const I2S1I_DATA_IN4_IDX: u32 = 170;
pub const I2S1O_DATA_OUT4_IDX: u32 = 170;
pub const I2S1I_DATA_IN5_IDX: u32 = 171;
pub const I2S1O_DATA_OUT5_IDX: u32 = 171;
pub const I2S1I_DATA_IN6_IDX: u32 = 172;
pub const I2S1O_DATA_OUT6_IDX: u32 = 172;
pub const I2S1I_DATA_IN7_IDX: u32 = 173;
pub const I2S1O_DATA_OUT7_IDX: u32 = 173;
pub const I2S1I_DATA_IN8_IDX: u32 = 174;
pub const I2S1O_DATA_OUT8_IDX: u32 = 174;
pub const I2S1I_DATA_IN9_IDX: u32 = 175;
pub const I2S1O_DATA_OUT9_IDX: u32 = 175;
pub const I2S1I_DATA_IN10_IDX: u32 = 176;
pub const I2S1O_DATA_OUT10_IDX: u32 = 176;
pub const I2S1I_DATA_IN11_IDX: u32 = 177;
pub const I2S1O_DATA_OUT11_IDX: u32 = 177;
pub const I2S1I_DATA_IN12_IDX: u32 = 178;
pub const I2S1O_DATA_OUT12_IDX: u32 = 178;
pub const I2S1I_DATA_IN13_IDX: u32 = 179;
pub const I2S1O_DATA_OUT13_IDX: u32 = 179;
pub const I2S1I_DATA_IN14_IDX: u32 = 180;
pub const I2S1O_DATA_OUT14_IDX: u32 = 180;
pub const I2S1I_DATA_IN15_IDX: u32 = 181;
pub const I2S1O_DATA_OUT15_IDX: u32 = 181;
pub const I2S1O_DATA_OUT16_IDX: u32 = 182;
pub const I2S1O_DATA_OUT17_IDX: u32 = 183;
pub const I2S1O_DATA_OUT18_IDX: u32 = 184;
pub const I2S1O_DATA_OUT19_IDX: u32 = 185;
pub const I2S1O_DATA_OUT20_IDX: u32 = 186;
pub const I2S1O_DATA_OUT21_IDX: u32 = 187;
pub const I2S1O_DATA_OUT22_IDX: u32 = 188;
pub const I2S1O_DATA_OUT23_IDX: u32 = 189;
pub const I2S0I_H_SYNC_IDX: u32 = 190;
pub const PWM3_OUT1H_IDX: u32 = 190;
pub const I2S0I_V_SYNC_IDX: u32 = 191;
pub const PWM3_OUT1L_IDX: u32 = 191;
pub const I2S0I_H_ENABLE_IDX: u32 = 192;
pub const PWM3_OUT2H_IDX: u32 = 192;
pub const I2S1I_H_SYNC_IDX: u32 = 193;
pub const PWM3_OUT2L_IDX: u32 = 193;
pub const I2S1I_V_SYNC_IDX: u32 = 194;
pub const PWM3_OUT3H_IDX: u32 = 194;
pub const I2S1I_H_ENABLE_IDX: u32 = 195;
pub const PWM3_OUT3L_IDX: u32 = 195;
pub const PWM3_OUT4H_IDX: u32 = 196;
pub const PWM3_OUT4L_IDX: u32 = 197;
pub const U2RXD_IN_IDX: u32 = 198;
pub const U2TXD_OUT_IDX: u32 = 198;
pub const U2CTS_IN_IDX: u32 = 199;
pub const U2RTS_OUT_IDX: u32 = 199;
pub const EMAC_MDC_I_IDX: u32 = 200;
pub const EMAC_MDC_O_IDX: u32 = 200;
pub const EMAC_MDI_I_IDX: u32 = 201;
pub const EMAC_MDO_O_IDX: u32 = 201;
pub const EMAC_CRS_I_IDX: u32 = 202;
pub const EMAC_CRS_O_IDX: u32 = 202;
pub const EMAC_COL_I_IDX: u32 = 203;
pub const EMAC_COL_O_IDX: u32 = 203;
pub const PCMFSYNC_IN_IDX: u32 = 204;
pub const BT_AUDIO0_IRQ_IDX: u32 = 204;
pub const PCMCLK_IN_IDX: u32 = 205;
pub const BT_AUDIO1_IRQ_IDX: u32 = 205;
pub const PCMDIN_IDX: u32 = 206;
pub const BT_AUDIO2_IRQ_IDX: u32 = 206;
pub const BLE_AUDIO0_IRQ_IDX: u32 = 207;
pub const BLE_AUDIO1_IRQ_IDX: u32 = 208;
pub const BLE_AUDIO2_IRQ_IDX: u32 = 209;
pub const PCMFSYNC_OUT_IDX: u32 = 210;
pub const PCMCLK_OUT_IDX: u32 = 211;
pub const PCMDOUT_IDX: u32 = 212;
pub const BLE_AUDIO_SYNC0_P_IDX: u32 = 213;
pub const BLE_AUDIO_SYNC1_P_IDX: u32 = 214;
pub const BLE_AUDIO_SYNC2_P_IDX: u32 = 215;
pub const ANT_SEL0_IDX: u32 = 216;
pub const ANT_SEL1_IDX: u32 = 217;
pub const ANT_SEL2_IDX: u32 = 218;
pub const ANT_SEL3_IDX: u32 = 219;
pub const ANT_SEL4_IDX: u32 = 220;
pub const ANT_SEL5_IDX: u32 = 221;
pub const ANT_SEL6_IDX: u32 = 222;
pub const ANT_SEL7_IDX: u32 = 223;
pub const SIG_IN_FUNC224_IDX: u32 = 224;
pub const SIG_IN_FUNC225_IDX: u32 = 225;
pub const SIG_IN_FUNC226_IDX: u32 = 226;
pub const SIG_IN_FUNC227_IDX: u32 = 227;
pub const SIG_IN_FUNC228_IDX: u32 = 228;
pub const SIG_GPIO_OUT_IDX: u32 = 256;
pub const GPIO_PIN_REG_0: u32 = 1072992324;
pub const GPIO_PIN_REG_1: u32 = 1072992392;
pub const GPIO_PIN_REG_2: u32 = 1072992320;
pub const GPIO_PIN_REG_3: u32 = 1072992388;
pub const GPIO_PIN_REG_4: u32 = 1072992328;
pub const GPIO_PIN_REG_5: u32 = 1072992364;
pub const GPIO_PIN_REG_6: u32 = 1072992352;
pub const GPIO_PIN_REG_7: u32 = 1072992356;
pub const GPIO_PIN_REG_8: u32 = 1072992360;
pub const GPIO_PIN_REG_9: u32 = 1072992340;
pub const GPIO_PIN_REG_10: u32 = 1072992344;
pub const GPIO_PIN_REG_11: u32 = 1072992348;
pub const GPIO_PIN_REG_12: u32 = 1072992308;
pub const GPIO_PIN_REG_13: u32 = 1072992312;
pub const GPIO_PIN_REG_14: u32 = 1072992304;
pub const GPIO_PIN_REG_15: u32 = 1072992316;
pub const GPIO_PIN_REG_16: u32 = 1072992332;
pub const GPIO_PIN_REG_17: u32 = 1072992336;
pub const GPIO_PIN_REG_18: u32 = 1072992368;
pub const GPIO_PIN_REG_19: u32 = 1072992372;
pub const GPIO_PIN_REG_20: u32 = 1072992376;
pub const GPIO_PIN_REG_21: u32 = 1072992380;
pub const GPIO_PIN_REG_22: u32 = 1072992384;
pub const GPIO_PIN_REG_23: u32 = 1072992396;
pub const GPIO_PIN_REG_25: u32 = 1072992292;
pub const GPIO_PIN_REG_26: u32 = 1072992296;
pub const GPIO_PIN_REG_27: u32 = 1072992300;
pub const GPIO_PIN_REG_32: u32 = 1072992284;
pub const GPIO_PIN_REG_33: u32 = 1072992288;
pub const GPIO_PIN_REG_34: u32 = 1072992276;
pub const GPIO_PIN_REG_35: u32 = 1072992280;
pub const GPIO_PIN_REG_36: u32 = 1072992260;
pub const GPIO_PIN_REG_37: u32 = 1072992264;
pub const GPIO_PIN_REG_38: u32 = 1072992268;
pub const GPIO_PIN_REG_39: u32 = 1072992272;
pub const GPIO_MODE_DEF_DISABLE: u32 = 0;
pub const GPIO_MODE_DEF_INPUT: u32 = 1;
pub const GPIO_MODE_DEF_OUTPUT: u32 = 2;
pub const GPIO_MODE_DEF_OD: u32 = 4;
pub const ADC1_CHANNEL_0_GPIO_NUM: u32 = 36;
pub const ADC1_CHANNEL_1_GPIO_NUM: u32 = 37;
pub const ADC1_CHANNEL_2_GPIO_NUM: u32 = 38;
pub const ADC1_CHANNEL_3_GPIO_NUM: u32 = 39;
pub const ADC1_CHANNEL_4_GPIO_NUM: u32 = 32;
pub const ADC1_CHANNEL_5_GPIO_NUM: u32 = 33;
pub const ADC1_CHANNEL_6_GPIO_NUM: u32 = 34;
pub const ADC1_CHANNEL_7_GPIO_NUM: u32 = 35;
pub const ADC2_CHANNEL_0_GPIO_NUM: u32 = 4;
pub const ADC2_CHANNEL_1_GPIO_NUM: u32 = 0;
pub const ADC2_CHANNEL_2_GPIO_NUM: u32 = 2;
pub const ADC2_CHANNEL_3_GPIO_NUM: u32 = 15;
pub const ADC2_CHANNEL_4_GPIO_NUM: u32 = 13;
pub const ADC2_CHANNEL_5_GPIO_NUM: u32 = 12;
pub const ADC2_CHANNEL_6_GPIO_NUM: u32 = 14;
pub const ADC2_CHANNEL_7_GPIO_NUM: u32 = 27;
pub const ADC2_CHANNEL_8_GPIO_NUM: u32 = 25;
pub const ADC2_CHANNEL_9_GPIO_NUM: u32 = 26;
pub const DAC_CHANNEL_1_GPIO_NUM: u32 = 25;
pub const DAC_CHANNEL_2_GPIO_NUM: u32 = 26;
pub const I2C_APB_CLK_FREQ: u32 = 80000000;
pub const I2C_FIFO_LEN: u32 = 32;
pub const I2S_SIG_LOOPBACK_V: u32 = 1;
pub const I2S_SIG_LOOPBACK_S: u32 = 18;
pub const I2S_RX_MSB_RIGHT_V: u32 = 1;
pub const I2S_RX_MSB_RIGHT_S: u32 = 17;
pub const I2S_TX_MSB_RIGHT_V: u32 = 1;
pub const I2S_TX_MSB_RIGHT_S: u32 = 16;
pub const I2S_RX_MONO_V: u32 = 1;
pub const I2S_RX_MONO_S: u32 = 15;
pub const I2S_TX_MONO_V: u32 = 1;
pub const I2S_TX_MONO_S: u32 = 14;
pub const I2S_RX_SHORT_SYNC_V: u32 = 1;
pub const I2S_RX_SHORT_SYNC_S: u32 = 13;
pub const I2S_TX_SHORT_SYNC_V: u32 = 1;
pub const I2S_TX_SHORT_SYNC_S: u32 = 12;
pub const I2S_RX_MSB_SHIFT_V: u32 = 1;
pub const I2S_RX_MSB_SHIFT_S: u32 = 11;
pub const I2S_TX_MSB_SHIFT_V: u32 = 1;
pub const I2S_TX_MSB_SHIFT_S: u32 = 10;
pub const I2S_RX_RIGHT_FIRST_V: u32 = 1;
pub const I2S_RX_RIGHT_FIRST_S: u32 = 9;
pub const I2S_TX_RIGHT_FIRST_V: u32 = 1;
pub const I2S_TX_RIGHT_FIRST_S: u32 = 8;
pub const I2S_RX_SLAVE_MOD_V: u32 = 1;
pub const I2S_RX_SLAVE_MOD_S: u32 = 7;
pub const I2S_TX_SLAVE_MOD_V: u32 = 1;
pub const I2S_TX_SLAVE_MOD_S: u32 = 6;
pub const I2S_RX_START_V: u32 = 1;
pub const I2S_RX_START_S: u32 = 5;
pub const I2S_TX_START_V: u32 = 1;
pub const I2S_TX_START_S: u32 = 4;
pub const I2S_RX_FIFO_RESET_V: u32 = 1;
pub const I2S_RX_FIFO_RESET_S: u32 = 3;
pub const I2S_TX_FIFO_RESET_V: u32 = 1;
pub const I2S_TX_FIFO_RESET_S: u32 = 2;
pub const I2S_RX_RESET_V: u32 = 1;
pub const I2S_RX_RESET_S: u32 = 1;
pub const I2S_TX_RESET_V: u32 = 1;
pub const I2S_TX_RESET_S: u32 = 0;
pub const I2S_OUT_TOTAL_EOF_INT_RAW_V: u32 = 1;
pub const I2S_OUT_TOTAL_EOF_INT_RAW_S: u32 = 16;
pub const I2S_IN_DSCR_EMPTY_INT_RAW_V: u32 = 1;
pub const I2S_IN_DSCR_EMPTY_INT_RAW_S: u32 = 15;
pub const I2S_OUT_DSCR_ERR_INT_RAW_V: u32 = 1;
pub const I2S_OUT_DSCR_ERR_INT_RAW_S: u32 = 14;
pub const I2S_IN_DSCR_ERR_INT_RAW_V: u32 = 1;
pub const I2S_IN_DSCR_ERR_INT_RAW_S: u32 = 13;
pub const I2S_OUT_EOF_INT_RAW_V: u32 = 1;
pub const I2S_OUT_EOF_INT_RAW_S: u32 = 12;
pub const I2S_OUT_DONE_INT_RAW_V: u32 = 1;
pub const I2S_OUT_DONE_INT_RAW_S: u32 = 11;
pub const I2S_IN_ERR_EOF_INT_RAW_V: u32 = 1;
pub const I2S_IN_ERR_EOF_INT_RAW_S: u32 = 10;
pub const I2S_IN_SUC_EOF_INT_RAW_V: u32 = 1;
pub const I2S_IN_SUC_EOF_INT_RAW_S: u32 = 9;
pub const I2S_IN_DONE_INT_RAW_V: u32 = 1;
pub const I2S_IN_DONE_INT_RAW_S: u32 = 8;
pub const I2S_TX_HUNG_INT_RAW_V: u32 = 1;
pub const I2S_TX_HUNG_INT_RAW_S: u32 = 7;
pub const I2S_RX_HUNG_INT_RAW_V: u32 = 1;
pub const I2S_RX_HUNG_INT_RAW_S: u32 = 6;
pub const I2S_TX_REMPTY_INT_RAW_V: u32 = 1;
pub const I2S_TX_REMPTY_INT_RAW_S: u32 = 5;
pub const I2S_TX_WFULL_INT_RAW_V: u32 = 1;
pub const I2S_TX_WFULL_INT_RAW_S: u32 = 4;
pub const I2S_RX_REMPTY_INT_RAW_V: u32 = 1;
pub const I2S_RX_REMPTY_INT_RAW_S: u32 = 3;
pub const I2S_RX_WFULL_INT_RAW_V: u32 = 1;
pub const I2S_RX_WFULL_INT_RAW_S: u32 = 2;
pub const I2S_TX_PUT_DATA_INT_RAW_V: u32 = 1;
pub const I2S_TX_PUT_DATA_INT_RAW_S: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_RAW_V: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_RAW_S: u32 = 0;
pub const I2S_OUT_TOTAL_EOF_INT_ST_V: u32 = 1;
pub const I2S_OUT_TOTAL_EOF_INT_ST_S: u32 = 16;
pub const I2S_IN_DSCR_EMPTY_INT_ST_V: u32 = 1;
pub const I2S_IN_DSCR_EMPTY_INT_ST_S: u32 = 15;
pub const I2S_OUT_DSCR_ERR_INT_ST_V: u32 = 1;
pub const I2S_OUT_DSCR_ERR_INT_ST_S: u32 = 14;
pub const I2S_IN_DSCR_ERR_INT_ST_V: u32 = 1;
pub const I2S_IN_DSCR_ERR_INT_ST_S: u32 = 13;
pub const I2S_OUT_EOF_INT_ST_V: u32 = 1;
pub const I2S_OUT_EOF_INT_ST_S: u32 = 12;
pub const I2S_OUT_DONE_INT_ST_V: u32 = 1;
pub const I2S_OUT_DONE_INT_ST_S: u32 = 11;
pub const I2S_IN_ERR_EOF_INT_ST_V: u32 = 1;
pub const I2S_IN_ERR_EOF_INT_ST_S: u32 = 10;
pub const I2S_IN_SUC_EOF_INT_ST_V: u32 = 1;
pub const I2S_IN_SUC_EOF_INT_ST_S: u32 = 9;
pub const I2S_IN_DONE_INT_ST_V: u32 = 1;
pub const I2S_IN_DONE_INT_ST_S: u32 = 8;
pub const I2S_TX_HUNG_INT_ST_V: u32 = 1;
pub const I2S_TX_HUNG_INT_ST_S: u32 = 7;
pub const I2S_RX_HUNG_INT_ST_V: u32 = 1;
pub const I2S_RX_HUNG_INT_ST_S: u32 = 6;
pub const I2S_TX_REMPTY_INT_ST_V: u32 = 1;
pub const I2S_TX_REMPTY_INT_ST_S: u32 = 5;
pub const I2S_TX_WFULL_INT_ST_V: u32 = 1;
pub const I2S_TX_WFULL_INT_ST_S: u32 = 4;
pub const I2S_RX_REMPTY_INT_ST_V: u32 = 1;
pub const I2S_RX_REMPTY_INT_ST_S: u32 = 3;
pub const I2S_RX_WFULL_INT_ST_V: u32 = 1;
pub const I2S_RX_WFULL_INT_ST_S: u32 = 2;
pub const I2S_TX_PUT_DATA_INT_ST_V: u32 = 1;
pub const I2S_TX_PUT_DATA_INT_ST_S: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_ST_V: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_ST_S: u32 = 0;
pub const I2S_OUT_TOTAL_EOF_INT_ENA_V: u32 = 1;
pub const I2S_OUT_TOTAL_EOF_INT_ENA_S: u32 = 16;
pub const I2S_IN_DSCR_EMPTY_INT_ENA_V: u32 = 1;
pub const I2S_IN_DSCR_EMPTY_INT_ENA_S: u32 = 15;
pub const I2S_OUT_DSCR_ERR_INT_ENA_V: u32 = 1;
pub const I2S_OUT_DSCR_ERR_INT_ENA_S: u32 = 14;
pub const I2S_IN_DSCR_ERR_INT_ENA_V: u32 = 1;
pub const I2S_IN_DSCR_ERR_INT_ENA_S: u32 = 13;
pub const I2S_OUT_EOF_INT_ENA_V: u32 = 1;
pub const I2S_OUT_EOF_INT_ENA_S: u32 = 12;
pub const I2S_OUT_DONE_INT_ENA_V: u32 = 1;
pub const I2S_OUT_DONE_INT_ENA_S: u32 = 11;
pub const I2S_IN_ERR_EOF_INT_ENA_V: u32 = 1;
pub const I2S_IN_ERR_EOF_INT_ENA_S: u32 = 10;
pub const I2S_IN_SUC_EOF_INT_ENA_V: u32 = 1;
pub const I2S_IN_SUC_EOF_INT_ENA_S: u32 = 9;
pub const I2S_IN_DONE_INT_ENA_V: u32 = 1;
pub const I2S_IN_DONE_INT_ENA_S: u32 = 8;
pub const I2S_TX_HUNG_INT_ENA_V: u32 = 1;
pub const I2S_TX_HUNG_INT_ENA_S: u32 = 7;
pub const I2S_RX_HUNG_INT_ENA_V: u32 = 1;
pub const I2S_RX_HUNG_INT_ENA_S: u32 = 6;
pub const I2S_TX_REMPTY_INT_ENA_V: u32 = 1;
pub const I2S_TX_REMPTY_INT_ENA_S: u32 = 5;
pub const I2S_TX_WFULL_INT_ENA_V: u32 = 1;
pub const I2S_TX_WFULL_INT_ENA_S: u32 = 4;
pub const I2S_RX_REMPTY_INT_ENA_V: u32 = 1;
pub const I2S_RX_REMPTY_INT_ENA_S: u32 = 3;
pub const I2S_RX_WFULL_INT_ENA_V: u32 = 1;
pub const I2S_RX_WFULL_INT_ENA_S: u32 = 2;
pub const I2S_TX_PUT_DATA_INT_ENA_V: u32 = 1;
pub const I2S_TX_PUT_DATA_INT_ENA_S: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_ENA_V: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_ENA_S: u32 = 0;
pub const I2S_OUT_TOTAL_EOF_INT_CLR_V: u32 = 1;
pub const I2S_OUT_TOTAL_EOF_INT_CLR_S: u32 = 16;
pub const I2S_IN_DSCR_EMPTY_INT_CLR_V: u32 = 1;
pub const I2S_IN_DSCR_EMPTY_INT_CLR_S: u32 = 15;
pub const I2S_OUT_DSCR_ERR_INT_CLR_V: u32 = 1;
pub const I2S_OUT_DSCR_ERR_INT_CLR_S: u32 = 14;
pub const I2S_IN_DSCR_ERR_INT_CLR_V: u32 = 1;
pub const I2S_IN_DSCR_ERR_INT_CLR_S: u32 = 13;
pub const I2S_OUT_EOF_INT_CLR_V: u32 = 1;
pub const I2S_OUT_EOF_INT_CLR_S: u32 = 12;
pub const I2S_OUT_DONE_INT_CLR_V: u32 = 1;
pub const I2S_OUT_DONE_INT_CLR_S: u32 = 11;
pub const I2S_IN_ERR_EOF_INT_CLR_V: u32 = 1;
pub const I2S_IN_ERR_EOF_INT_CLR_S: u32 = 10;
pub const I2S_IN_SUC_EOF_INT_CLR_V: u32 = 1;
pub const I2S_IN_SUC_EOF_INT_CLR_S: u32 = 9;
pub const I2S_IN_DONE_INT_CLR_V: u32 = 1;
pub const I2S_IN_DONE_INT_CLR_S: u32 = 8;
pub const I2S_TX_HUNG_INT_CLR_V: u32 = 1;
pub const I2S_TX_HUNG_INT_CLR_S: u32 = 7;
pub const I2S_RX_HUNG_INT_CLR_V: u32 = 1;
pub const I2S_RX_HUNG_INT_CLR_S: u32 = 6;
pub const I2S_TX_REMPTY_INT_CLR_V: u32 = 1;
pub const I2S_TX_REMPTY_INT_CLR_S: u32 = 5;
pub const I2S_TX_WFULL_INT_CLR_V: u32 = 1;
pub const I2S_TX_WFULL_INT_CLR_S: u32 = 4;
pub const I2S_RX_REMPTY_INT_CLR_V: u32 = 1;
pub const I2S_RX_REMPTY_INT_CLR_S: u32 = 3;
pub const I2S_RX_WFULL_INT_CLR_V: u32 = 1;
pub const I2S_RX_WFULL_INT_CLR_S: u32 = 2;
pub const I2S_PUT_DATA_INT_CLR_V: u32 = 1;
pub const I2S_PUT_DATA_INT_CLR_S: u32 = 1;
pub const I2S_TAKE_DATA_INT_CLR_V: u32 = 1;
pub const I2S_TAKE_DATA_INT_CLR_S: u32 = 0;
pub const I2S_TX_BCK_IN_INV_V: u32 = 1;
pub const I2S_TX_BCK_IN_INV_S: u32 = 24;
pub const I2S_DATA_ENABLE_DELAY: u32 = 3;
pub const I2S_DATA_ENABLE_DELAY_V: u32 = 3;
pub const I2S_DATA_ENABLE_DELAY_S: u32 = 22;
pub const I2S_RX_DSYNC_SW_V: u32 = 1;
pub const I2S_RX_DSYNC_SW_S: u32 = 21;
pub const I2S_TX_DSYNC_SW_V: u32 = 1;
pub const I2S_TX_DSYNC_SW_S: u32 = 20;
pub const I2S_RX_BCK_OUT_DELAY: u32 = 3;
pub const I2S_RX_BCK_OUT_DELAY_V: u32 = 3;
pub const I2S_RX_BCK_OUT_DELAY_S: u32 = 18;
pub const I2S_RX_WS_OUT_DELAY: u32 = 3;
pub const I2S_RX_WS_OUT_DELAY_V: u32 = 3;
pub const I2S_RX_WS_OUT_DELAY_S: u32 = 16;
pub const I2S_TX_SD_OUT_DELAY: u32 = 3;
pub const I2S_TX_SD_OUT_DELAY_V: u32 = 3;
pub const I2S_TX_SD_OUT_DELAY_S: u32 = 14;
pub const I2S_TX_WS_OUT_DELAY: u32 = 3;
pub const I2S_TX_WS_OUT_DELAY_V: u32 = 3;
pub const I2S_TX_WS_OUT_DELAY_S: u32 = 12;
pub const I2S_TX_BCK_OUT_DELAY: u32 = 3;
pub const I2S_TX_BCK_OUT_DELAY_V: u32 = 3;
pub const I2S_TX_BCK_OUT_DELAY_S: u32 = 10;
pub const I2S_RX_SD_IN_DELAY: u32 = 3;
pub const I2S_RX_SD_IN_DELAY_V: u32 = 3;
pub const I2S_RX_SD_IN_DELAY_S: u32 = 8;
pub const I2S_RX_WS_IN_DELAY: u32 = 3;
pub const I2S_RX_WS_IN_DELAY_V: u32 = 3;
pub const I2S_RX_WS_IN_DELAY_S: u32 = 6;
pub const I2S_RX_BCK_IN_DELAY: u32 = 3;
pub const I2S_RX_BCK_IN_DELAY_V: u32 = 3;
pub const I2S_RX_BCK_IN_DELAY_S: u32 = 4;
pub const I2S_TX_WS_IN_DELAY: u32 = 3;
pub const I2S_TX_WS_IN_DELAY_V: u32 = 3;
pub const I2S_TX_WS_IN_DELAY_S: u32 = 2;
pub const I2S_TX_BCK_IN_DELAY: u32 = 3;
pub const I2S_TX_BCK_IN_DELAY_V: u32 = 3;
pub const I2S_TX_BCK_IN_DELAY_S: u32 = 0;
pub const I2S_RX_FIFO_MOD_FORCE_EN_V: u32 = 1;
pub const I2S_RX_FIFO_MOD_FORCE_EN_S: u32 = 20;
pub const I2S_TX_FIFO_MOD_FORCE_EN_V: u32 = 1;
pub const I2S_TX_FIFO_MOD_FORCE_EN_S: u32 = 19;
pub const I2S_RX_FIFO_MOD: u32 = 7;
pub const I2S_RX_FIFO_MOD_V: u32 = 7;
pub const I2S_RX_FIFO_MOD_S: u32 = 16;
pub const I2S_TX_FIFO_MOD: u32 = 7;
pub const I2S_TX_FIFO_MOD_V: u32 = 7;
pub const I2S_TX_FIFO_MOD_S: u32 = 13;
pub const I2S_DSCR_EN_V: u32 = 1;
pub const I2S_DSCR_EN_S: u32 = 12;
pub const I2S_TX_DATA_NUM: u32 = 63;
pub const I2S_TX_DATA_NUM_V: u32 = 63;
pub const I2S_TX_DATA_NUM_S: u32 = 6;
pub const I2S_RX_DATA_NUM: u32 = 63;
pub const I2S_RX_DATA_NUM_V: u32 = 63;
pub const I2S_RX_DATA_NUM_S: u32 = 0;
pub const I2S_RX_EOF_NUM: u32 = 4294967295;
pub const I2S_RX_EOF_NUM_V: u32 = 4294967295;
pub const I2S_RX_EOF_NUM_S: u32 = 0;
pub const I2S_SIGLE_DATA: u32 = 4294967295;
pub const I2S_SIGLE_DATA_V: u32 = 4294967295;
pub const I2S_SIGLE_DATA_S: u32 = 0;
pub const I2S_RX_CHAN_MOD: u32 = 3;
pub const I2S_RX_CHAN_MOD_V: u32 = 3;
pub const I2S_RX_CHAN_MOD_S: u32 = 3;
pub const I2S_TX_CHAN_MOD: u32 = 7;
pub const I2S_TX_CHAN_MOD_V: u32 = 7;
pub const I2S_TX_CHAN_MOD_S: u32 = 0;
pub const I2S_OUTLINK_PARK_V: u32 = 1;
pub const I2S_OUTLINK_PARK_S: u32 = 31;
pub const I2S_OUTLINK_RESTART_V: u32 = 1;
pub const I2S_OUTLINK_RESTART_S: u32 = 30;
pub const I2S_OUTLINK_START_V: u32 = 1;
pub const I2S_OUTLINK_START_S: u32 = 29;
pub const I2S_OUTLINK_STOP_V: u32 = 1;
pub const I2S_OUTLINK_STOP_S: u32 = 28;
pub const I2S_OUTLINK_ADDR: u32 = 1048575;
pub const I2S_OUTLINK_ADDR_V: u32 = 1048575;
pub const I2S_OUTLINK_ADDR_S: u32 = 0;
pub const I2S_INLINK_PARK_V: u32 = 1;
pub const I2S_INLINK_PARK_S: u32 = 31;
pub const I2S_INLINK_RESTART_V: u32 = 1;
pub const I2S_INLINK_RESTART_S: u32 = 30;
pub const I2S_INLINK_START_V: u32 = 1;
pub const I2S_INLINK_START_S: u32 = 29;
pub const I2S_INLINK_STOP_V: u32 = 1;
pub const I2S_INLINK_STOP_S: u32 = 28;
pub const I2S_INLINK_ADDR: u32 = 1048575;
pub const I2S_INLINK_ADDR_V: u32 = 1048575;
pub const I2S_INLINK_ADDR_S: u32 = 0;
pub const I2S_OUT_EOF_DES_ADDR: u32 = 4294967295;
pub const I2S_OUT_EOF_DES_ADDR_V: u32 = 4294967295;
pub const I2S_OUT_EOF_DES_ADDR_S: u32 = 0;
pub const I2S_IN_SUC_EOF_DES_ADDR: u32 = 4294967295;
pub const I2S_IN_SUC_EOF_DES_ADDR_V: u32 = 4294967295;
pub const I2S_IN_SUC_EOF_DES_ADDR_S: u32 = 0;
pub const I2S_OUT_EOF_BFR_DES_ADDR: u32 = 4294967295;
pub const I2S_OUT_EOF_BFR_DES_ADDR_V: u32 = 4294967295;
pub const I2S_OUT_EOF_BFR_DES_ADDR_S: u32 = 0;
pub const I2S_AHB_TESTADDR: u32 = 3;
pub const I2S_AHB_TESTADDR_V: u32 = 3;
pub const I2S_AHB_TESTADDR_S: u32 = 4;
pub const I2S_AHB_TESTMODE: u32 = 7;
pub const I2S_AHB_TESTMODE_V: u32 = 7;
pub const I2S_AHB_TESTMODE_S: u32 = 0;
pub const I2S_INLINK_DSCR: u32 = 4294967295;
pub const I2S_INLINK_DSCR_V: u32 = 4294967295;
pub const I2S_INLINK_DSCR_S: u32 = 0;
pub const I2S_INLINK_DSCR_BF0: u32 = 4294967295;
pub const I2S_INLINK_DSCR_BF0_V: u32 = 4294967295;
pub const I2S_INLINK_DSCR_BF0_S: u32 = 0;
pub const I2S_INLINK_DSCR_BF1: u32 = 4294967295;
pub const I2S_INLINK_DSCR_BF1_V: u32 = 4294967295;
pub const I2S_INLINK_DSCR_BF1_S: u32 = 0;
pub const I2S_OUTLINK_DSCR: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_V: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_S: u32 = 0;
pub const I2S_OUTLINK_DSCR_BF0: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_BF0_V: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_BF0_S: u32 = 0;
pub const I2S_OUTLINK_DSCR_BF1: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_BF1_V: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_BF1_S: u32 = 0;
pub const I2S_MEM_TRANS_EN_V: u32 = 1;
pub const I2S_MEM_TRANS_EN_S: u32 = 13;
pub const I2S_CHECK_OWNER_V: u32 = 1;
pub const I2S_CHECK_OWNER_S: u32 = 12;
pub const I2S_OUT_DATA_BURST_EN_V: u32 = 1;
pub const I2S_OUT_DATA_BURST_EN_S: u32 = 11;
pub const I2S_INDSCR_BURST_EN_V: u32 = 1;
pub const I2S_INDSCR_BURST_EN_S: u32 = 10;
pub const I2S_OUTDSCR_BURST_EN_V: u32 = 1;
pub const I2S_OUTDSCR_BURST_EN_S: u32 = 9;
pub const I2S_OUT_EOF_MODE_V: u32 = 1;
pub const I2S_OUT_EOF_MODE_S: u32 = 8;
pub const I2S_OUT_NO_RESTART_CLR_V: u32 = 1;
pub const I2S_OUT_NO_RESTART_CLR_S: u32 = 7;
pub const I2S_OUT_AUTO_WRBACK_V: u32 = 1;
pub const I2S_OUT_AUTO_WRBACK_S: u32 = 6;
pub const I2S_IN_LOOP_TEST_V: u32 = 1;
pub const I2S_IN_LOOP_TEST_S: u32 = 5;
pub const I2S_OUT_LOOP_TEST_V: u32 = 1;
pub const I2S_OUT_LOOP_TEST_S: u32 = 4;
pub const I2S_AHBM_RST_V: u32 = 1;
pub const I2S_AHBM_RST_S: u32 = 3;
pub const I2S_AHBM_FIFO_RST_V: u32 = 1;
pub const I2S_AHBM_FIFO_RST_S: u32 = 2;
pub const I2S_OUT_RST_V: u32 = 1;
pub const I2S_OUT_RST_S: u32 = 1;
pub const I2S_IN_RST_V: u32 = 1;
pub const I2S_IN_RST_S: u32 = 0;
pub const I2S_OUTFIFO_PUSH_V: u32 = 1;
pub const I2S_OUTFIFO_PUSH_S: u32 = 16;
pub const I2S_OUTFIFO_WDATA: u32 = 511;
pub const I2S_OUTFIFO_WDATA_V: u32 = 511;
pub const I2S_OUTFIFO_WDATA_S: u32 = 0;
pub const I2S_INFIFO_POP_V: u32 = 1;
pub const I2S_INFIFO_POP_S: u32 = 16;
pub const I2S_INFIFO_RDATA: u32 = 4095;
pub const I2S_INFIFO_RDATA_V: u32 = 4095;
pub const I2S_INFIFO_RDATA_S: u32 = 0;
pub const I2S_LC_STATE0: u32 = 4294967295;
pub const I2S_LC_STATE0_V: u32 = 4294967295;
pub const I2S_LC_STATE0_S: u32 = 0;
pub const I2S_LC_STATE1: u32 = 4294967295;
pub const I2S_LC_STATE1_V: u32 = 4294967295;
pub const I2S_LC_STATE1_S: u32 = 0;
pub const I2S_LC_FIFO_TIMEOUT_ENA_V: u32 = 1;
pub const I2S_LC_FIFO_TIMEOUT_ENA_S: u32 = 11;
pub const I2S_LC_FIFO_TIMEOUT_SHIFT: u32 = 7;
pub const I2S_LC_FIFO_TIMEOUT_SHIFT_V: u32 = 7;
pub const I2S_LC_FIFO_TIMEOUT_SHIFT_S: u32 = 8;
pub const I2S_LC_FIFO_TIMEOUT: u32 = 255;
pub const I2S_LC_FIFO_TIMEOUT_V: u32 = 255;
pub const I2S_LC_FIFO_TIMEOUT_S: u32 = 0;
pub const I2S_CVSD_Y_MIN: u32 = 65535;
pub const I2S_CVSD_Y_MIN_V: u32 = 65535;
pub const I2S_CVSD_Y_MIN_S: u32 = 16;
pub const I2S_CVSD_Y_MAX: u32 = 65535;
pub const I2S_CVSD_Y_MAX_V: u32 = 65535;
pub const I2S_CVSD_Y_MAX_S: u32 = 0;
pub const I2S_CVSD_SIGMA_MIN: u32 = 65535;
pub const I2S_CVSD_SIGMA_MIN_V: u32 = 65535;
pub const I2S_CVSD_SIGMA_MIN_S: u32 = 16;
pub const I2S_CVSD_SIGMA_MAX: u32 = 65535;
pub const I2S_CVSD_SIGMA_MAX_V: u32 = 65535;
pub const I2S_CVSD_SIGMA_MAX_S: u32 = 0;
pub const I2S_CVSD_H: u32 = 7;
pub const I2S_CVSD_H_V: u32 = 7;
pub const I2S_CVSD_H_S: u32 = 16;
pub const I2S_CVSD_BETA: u32 = 1023;
pub const I2S_CVSD_BETA_V: u32 = 1023;
pub const I2S_CVSD_BETA_S: u32 = 6;
pub const I2S_CVSD_J: u32 = 7;
pub const I2S_CVSD_J_V: u32 = 7;
pub const I2S_CVSD_J_S: u32 = 3;
pub const I2S_CVSD_K: u32 = 7;
pub const I2S_CVSD_K_V: u32 = 7;
pub const I2S_CVSD_K_S: u32 = 0;
pub const I2S_N_MIN_ERR: u32 = 7;
pub const I2S_N_MIN_ERR_V: u32 = 7;
pub const I2S_N_MIN_ERR_S: u32 = 25;
pub const I2S_PACK_LEN_8K: u32 = 31;
pub const I2S_PACK_LEN_8K_V: u32 = 31;
pub const I2S_PACK_LEN_8K_S: u32 = 20;
pub const I2S_MAX_SLIDE_SAMPLE: u32 = 255;
pub const I2S_MAX_SLIDE_SAMPLE_V: u32 = 255;
pub const I2S_MAX_SLIDE_SAMPLE_S: u32 = 12;
pub const I2S_SHIFT_RATE: u32 = 7;
pub const I2S_SHIFT_RATE_V: u32 = 7;
pub const I2S_SHIFT_RATE_S: u32 = 9;
pub const I2S_N_ERR_SEG: u32 = 7;
pub const I2S_N_ERR_SEG_V: u32 = 7;
pub const I2S_N_ERR_SEG_S: u32 = 6;
pub const I2S_GOOD_PACK_MAX: u32 = 63;
pub const I2S_GOOD_PACK_MAX_V: u32 = 63;
pub const I2S_GOOD_PACK_MAX_S: u32 = 0;
pub const I2S_SLIDE_WIN_LEN: u32 = 255;
pub const I2S_SLIDE_WIN_LEN_V: u32 = 255;
pub const I2S_SLIDE_WIN_LEN_S: u32 = 24;
pub const I2S_BAD_OLA_WIN2_PARA: u32 = 255;
pub const I2S_BAD_OLA_WIN2_PARA_V: u32 = 255;
pub const I2S_BAD_OLA_WIN2_PARA_S: u32 = 16;
pub const I2S_BAD_OLA_WIN2_PARA_SHIFT: u32 = 15;
pub const I2S_BAD_OLA_WIN2_PARA_SHIFT_V: u32 = 15;
pub const I2S_BAD_OLA_WIN2_PARA_SHIFT_S: u32 = 12;
pub const I2S_BAD_CEF_ATTEN_PARA_SHIFT: u32 = 15;
pub const I2S_BAD_CEF_ATTEN_PARA_SHIFT_V: u32 = 15;
pub const I2S_BAD_CEF_ATTEN_PARA_SHIFT_S: u32 = 8;
pub const I2S_BAD_CEF_ATTEN_PARA: u32 = 255;
pub const I2S_BAD_CEF_ATTEN_PARA_V: u32 = 255;
pub const I2S_BAD_CEF_ATTEN_PARA_S: u32 = 0;
pub const I2S_MIN_PERIOD: u32 = 31;
pub const I2S_MIN_PERIOD_V: u32 = 31;
pub const I2S_MIN_PERIOD_S: u32 = 2;
pub const I2S_CVSD_SEG_MOD: u32 = 3;
pub const I2S_CVSD_SEG_MOD_V: u32 = 3;
pub const I2S_CVSD_SEG_MOD_S: u32 = 0;
pub const I2S_PLC2DMA_EN_V: u32 = 1;
pub const I2S_PLC2DMA_EN_S: u32 = 12;
pub const I2S_PLC_EN_V: u32 = 1;
pub const I2S_PLC_EN_S: u32 = 11;
pub const I2S_CVSD_DEC_RESET_V: u32 = 1;
pub const I2S_CVSD_DEC_RESET_S: u32 = 10;
pub const I2S_CVSD_DEC_START_V: u32 = 1;
pub const I2S_CVSD_DEC_START_S: u32 = 9;
pub const I2S_ESCO_CVSD_INF_EN_V: u32 = 1;
pub const I2S_ESCO_CVSD_INF_EN_S: u32 = 8;
pub const I2S_ESCO_CVSD_PACK_LEN_8K: u32 = 31;
pub const I2S_ESCO_CVSD_PACK_LEN_8K_V: u32 = 31;
pub const I2S_ESCO_CVSD_PACK_LEN_8K_S: u32 = 3;
pub const I2S_ESCO_CVSD_DEC_PACK_ERR_V: u32 = 1;
pub const I2S_ESCO_CVSD_DEC_PACK_ERR_S: u32 = 2;
pub const I2S_ESCO_CHAN_MOD_V: u32 = 1;
pub const I2S_ESCO_CHAN_MOD_S: u32 = 1;
pub const I2S_ESCO_EN_V: u32 = 1;
pub const I2S_ESCO_EN_S: u32 = 0;
pub const I2S_CVSD_ENC_RESET_V: u32 = 1;
pub const I2S_CVSD_ENC_RESET_S: u32 = 3;
pub const I2S_CVSD_ENC_START_V: u32 = 1;
pub const I2S_CVSD_ENC_START_S: u32 = 2;
pub const I2S_SCO_NO_I2S_EN_V: u32 = 1;
pub const I2S_SCO_NO_I2S_EN_S: u32 = 1;
pub const I2S_SCO_WITH_I2S_EN_V: u32 = 1;
pub const I2S_SCO_WITH_I2S_EN_S: u32 = 0;
pub const I2S_TX_ZEROS_RM_EN_V: u32 = 1;
pub const I2S_TX_ZEROS_RM_EN_S: u32 = 9;
pub const I2S_TX_STOP_EN_V: u32 = 1;
pub const I2S_TX_STOP_EN_S: u32 = 8;
pub const I2S_RX_PCM_BYPASS_V: u32 = 1;
pub const I2S_RX_PCM_BYPASS_S: u32 = 7;
pub const I2S_RX_PCM_CONF: u32 = 7;
pub const I2S_RX_PCM_CONF_V: u32 = 7;
pub const I2S_RX_PCM_CONF_S: u32 = 4;
pub const I2S_TX_PCM_BYPASS_V: u32 = 1;
pub const I2S_TX_PCM_BYPASS_S: u32 = 3;
pub const I2S_TX_PCM_CONF: u32 = 7;
pub const I2S_TX_PCM_CONF_V: u32 = 7;
pub const I2S_TX_PCM_CONF_S: u32 = 0;
pub const I2S_PLC_MEM_FORCE_PU_V: u32 = 1;
pub const I2S_PLC_MEM_FORCE_PU_S: u32 = 3;
pub const I2S_PLC_MEM_FORCE_PD_V: u32 = 1;
pub const I2S_PLC_MEM_FORCE_PD_S: u32 = 2;
pub const I2S_FIFO_FORCE_PU_V: u32 = 1;
pub const I2S_FIFO_FORCE_PU_S: u32 = 1;
pub const I2S_FIFO_FORCE_PD_V: u32 = 1;
pub const I2S_FIFO_FORCE_PD_S: u32 = 0;
pub const I2S_INTER_VALID_EN_V: u32 = 1;
pub const I2S_INTER_VALID_EN_S: u32 = 7;
pub const I2S_EXT_ADC_START_EN_V: u32 = 1;
pub const I2S_EXT_ADC_START_EN_S: u32 = 6;
pub const I2S_LCD_EN_V: u32 = 1;
pub const I2S_LCD_EN_S: u32 = 5;
pub const I2S_DATA_ENABLE_V: u32 = 1;
pub const I2S_DATA_ENABLE_S: u32 = 4;
pub const I2S_DATA_ENABLE_TEST_EN_V: u32 = 1;
pub const I2S_DATA_ENABLE_TEST_EN_S: u32 = 3;
pub const I2S_LCD_TX_SDX2_EN_V: u32 = 1;
pub const I2S_LCD_TX_SDX2_EN_S: u32 = 2;
pub const I2S_LCD_TX_WRX2_EN_V: u32 = 1;
pub const I2S_LCD_TX_WRX2_EN_S: u32 = 1;
pub const I2S_CAMERA_EN_V: u32 = 1;
pub const I2S_CAMERA_EN_S: u32 = 0;
pub const I2S_CLKA_ENA_V: u32 = 1;
pub const I2S_CLKA_ENA_S: u32 = 21;
pub const I2S_CLK_EN_V: u32 = 1;
pub const I2S_CLK_EN_S: u32 = 20;
pub const I2S_CLKM_DIV_A: u32 = 63;
pub const I2S_CLKM_DIV_A_V: u32 = 63;
pub const I2S_CLKM_DIV_A_S: u32 = 14;
pub const I2S_CLKM_DIV_B: u32 = 63;
pub const I2S_CLKM_DIV_B_V: u32 = 63;
pub const I2S_CLKM_DIV_B_S: u32 = 8;
pub const I2S_CLKM_DIV_NUM: u32 = 255;
pub const I2S_CLKM_DIV_NUM_V: u32 = 255;
pub const I2S_CLKM_DIV_NUM_S: u32 = 0;
pub const I2S_RX_BITS_MOD: u32 = 63;
pub const I2S_RX_BITS_MOD_V: u32 = 63;
pub const I2S_RX_BITS_MOD_S: u32 = 18;
pub const I2S_TX_BITS_MOD: u32 = 63;
pub const I2S_TX_BITS_MOD_V: u32 = 63;
pub const I2S_TX_BITS_MOD_S: u32 = 12;
pub const I2S_RX_BCK_DIV_NUM: u32 = 63;
pub const I2S_RX_BCK_DIV_NUM_V: u32 = 63;
pub const I2S_RX_BCK_DIV_NUM_S: u32 = 6;
pub const I2S_TX_BCK_DIV_NUM: u32 = 63;
pub const I2S_TX_BCK_DIV_NUM_V: u32 = 63;
pub const I2S_TX_BCK_DIV_NUM_S: u32 = 0;
pub const I2S_TX_PDM_HP_BYPASS_V: u32 = 1;
pub const I2S_TX_PDM_HP_BYPASS_S: u32 = 25;
pub const I2S_RX_PDM_SINC_DSR_16_EN_V: u32 = 1;
pub const I2S_RX_PDM_SINC_DSR_16_EN_S: u32 = 24;
pub const I2S_TX_PDM_SIGMADELTA_IN_SHIFT: u32 = 3;
pub const I2S_TX_PDM_SIGMADELTA_IN_SHIFT_V: u32 = 3;
pub const I2S_TX_PDM_SIGMADELTA_IN_SHIFT_S: u32 = 22;
pub const I2S_TX_PDM_SINC_IN_SHIFT: u32 = 3;
pub const I2S_TX_PDM_SINC_IN_SHIFT_V: u32 = 3;
pub const I2S_TX_PDM_SINC_IN_SHIFT_S: u32 = 20;
pub const I2S_TX_PDM_LP_IN_SHIFT: u32 = 3;
pub const I2S_TX_PDM_LP_IN_SHIFT_V: u32 = 3;
pub const I2S_TX_PDM_LP_IN_SHIFT_S: u32 = 18;
pub const I2S_TX_PDM_HP_IN_SHIFT: u32 = 3;
pub const I2S_TX_PDM_HP_IN_SHIFT_V: u32 = 3;
pub const I2S_TX_PDM_HP_IN_SHIFT_S: u32 = 16;
pub const I2S_TX_PDM_PRESCALE: u32 = 255;
pub const I2S_TX_PDM_PRESCALE_V: u32 = 255;
pub const I2S_TX_PDM_PRESCALE_S: u32 = 8;
pub const I2S_TX_PDM_SINC_OSR2: u32 = 15;
pub const I2S_TX_PDM_SINC_OSR2_V: u32 = 15;
pub const I2S_TX_PDM_SINC_OSR2_S: u32 = 4;
pub const I2S_PDM2PCM_CONV_EN_V: u32 = 1;
pub const I2S_PDM2PCM_CONV_EN_S: u32 = 3;
pub const I2S_PCM2PDM_CONV_EN_V: u32 = 1;
pub const I2S_PCM2PDM_CONV_EN_S: u32 = 2;
pub const I2S_RX_PDM_EN_V: u32 = 1;
pub const I2S_RX_PDM_EN_S: u32 = 1;
pub const I2S_TX_PDM_EN_V: u32 = 1;
pub const I2S_TX_PDM_EN_S: u32 = 0;
pub const I2S_TX_PDM_FP: u32 = 1023;
pub const I2S_TX_PDM_FP_V: u32 = 1023;
pub const I2S_TX_PDM_FP_S: u32 = 10;
pub const I2S_TX_PDM_FS: u32 = 1023;
pub const I2S_TX_PDM_FS_V: u32 = 1023;
pub const I2S_TX_PDM_FS_S: u32 = 0;
pub const I2S_RX_FIFO_RESET_BACK_V: u32 = 1;
pub const I2S_RX_FIFO_RESET_BACK_S: u32 = 2;
pub const I2S_TX_FIFO_RESET_BACK_V: u32 = 1;
pub const I2S_TX_FIFO_RESET_BACK_S: u32 = 1;
pub const I2S_TX_IDLE_V: u32 = 1;
pub const I2S_TX_IDLE_S: u32 = 0;
pub const I2S_I2SDATE: u32 = 4294967295;
pub const I2S_I2SDATE_V: u32 = 4294967295;
pub const I2S_I2SDATE_S: u32 = 0;
pub const RTC_GPIO_OUT_REG: u32 = 1072989184;
pub const RTC_GPIO_OUT_DATA: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_V: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_S: u32 = 14;
pub const RTC_GPIO_OUT_W1TS_REG: u32 = 1072989188;
pub const RTC_GPIO_OUT_DATA_W1TS: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TS_V: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TS_S: u32 = 14;
pub const RTC_GPIO_OUT_W1TC_REG: u32 = 1072989192;
pub const RTC_GPIO_OUT_DATA_W1TC: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TC_V: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TC_S: u32 = 14;
pub const RTC_GPIO_ENABLE_REG: u32 = 1072989196;
pub const RTC_GPIO_ENABLE: u32 = 262143;
pub const RTC_GPIO_ENABLE_V: u32 = 262143;
pub const RTC_GPIO_ENABLE_S: u32 = 14;
pub const RTC_GPIO_ENABLE_W1TS_REG: u32 = 1072989200;
pub const RTC_GPIO_ENABLE_W1TS: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TS_V: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TS_S: u32 = 14;
pub const RTC_GPIO_ENABLE_W1TC_REG: u32 = 1072989204;
pub const RTC_GPIO_ENABLE_W1TC: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TC_V: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TC_S: u32 = 14;
pub const RTC_GPIO_STATUS_REG: u32 = 1072989208;
pub const RTC_GPIO_STATUS_INT: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_V: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_S: u32 = 14;
pub const RTC_GPIO_STATUS_W1TS_REG: u32 = 1072989212;
pub const RTC_GPIO_STATUS_INT_W1TS: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TS_V: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TS_S: u32 = 14;
pub const RTC_GPIO_STATUS_W1TC_REG: u32 = 1072989216;
pub const RTC_GPIO_STATUS_INT_W1TC: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TC_V: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TC_S: u32 = 14;
pub const RTC_GPIO_IN_REG: u32 = 1072989220;
pub const RTC_GPIO_IN_NEXT: u32 = 262143;
pub const RTC_GPIO_IN_NEXT_V: u32 = 262143;
pub const RTC_GPIO_IN_NEXT_S: u32 = 14;
pub const RTC_GPIO_PIN0_REG: u32 = 1072989224;
pub const RTC_GPIO_PIN0_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN0_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN0_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN0_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN0_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN0_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN1_REG: u32 = 1072989228;
pub const RTC_GPIO_PIN1_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN1_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN1_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN1_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN1_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN1_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN2_REG: u32 = 1072989232;
pub const RTC_GPIO_PIN2_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN2_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN2_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN2_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN2_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN2_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN3_REG: u32 = 1072989236;
pub const RTC_GPIO_PIN3_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN3_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN3_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN3_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN3_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN3_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN4_REG: u32 = 1072989240;
pub const RTC_GPIO_PIN4_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN4_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN4_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN4_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN4_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN4_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN5_REG: u32 = 1072989244;
pub const RTC_GPIO_PIN5_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN5_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN5_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN5_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN5_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN5_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN6_REG: u32 = 1072989248;
pub const RTC_GPIO_PIN6_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN6_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN6_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN6_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN6_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN6_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN6_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN7_REG: u32 = 1072989252;
pub const RTC_GPIO_PIN7_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN7_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN7_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN7_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN7_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN7_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN7_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN8_REG: u32 = 1072989256;
pub const RTC_GPIO_PIN8_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN8_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN8_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN8_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN8_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN8_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN8_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN9_REG: u32 = 1072989260;
pub const RTC_GPIO_PIN9_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN9_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN9_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN9_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN9_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN9_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN9_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN10_REG: u32 = 1072989264;
pub const RTC_GPIO_PIN10_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN10_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN10_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN10_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN10_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN10_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN10_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN11_REG: u32 = 1072989268;
pub const RTC_GPIO_PIN11_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN11_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN11_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN11_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN11_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN11_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN11_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN12_REG: u32 = 1072989272;
pub const RTC_GPIO_PIN12_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN12_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN12_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN12_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN12_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN12_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN12_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN13_REG: u32 = 1072989276;
pub const RTC_GPIO_PIN13_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN13_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN13_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN13_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN13_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN13_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN13_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN14_REG: u32 = 1072989280;
pub const RTC_GPIO_PIN14_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN14_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN14_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN14_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN14_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN14_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN14_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN15_REG: u32 = 1072989284;
pub const RTC_GPIO_PIN15_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN15_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN15_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN15_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN15_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN15_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN15_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN16_REG: u32 = 1072989288;
pub const RTC_GPIO_PIN16_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN16_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN16_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN16_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN16_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN16_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN16_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN17_REG: u32 = 1072989292;
pub const RTC_GPIO_PIN17_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN17_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN17_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN17_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN17_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN17_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN17_PAD_DRIVER_S: u32 = 2;
pub const RTC_IO_RTC_DEBUG_SEL_REG: u32 = 1072989296;
pub const RTC_IO_DEBUG_12M_NO_GATING_V: u32 = 1;
pub const RTC_IO_DEBUG_12M_NO_GATING_S: u32 = 25;
pub const RTC_IO_DEBUG_SEL4: u32 = 31;
pub const RTC_IO_DEBUG_SEL4_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL4_S: u32 = 20;
pub const RTC_IO_DEBUG_SEL3: u32 = 31;
pub const RTC_IO_DEBUG_SEL3_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL3_S: u32 = 15;
pub const RTC_IO_DEBUG_SEL2: u32 = 31;
pub const RTC_IO_DEBUG_SEL2_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL2_S: u32 = 10;
pub const RTC_IO_DEBUG_SEL1: u32 = 31;
pub const RTC_IO_DEBUG_SEL1_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL1_S: u32 = 5;
pub const RTC_IO_DEBUG_SEL0: u32 = 31;
pub const RTC_IO_DEBUG_SEL0_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL0_S: u32 = 0;
pub const RTC_IO_DEBUG_SEL0_8M: u32 = 1;
pub const RTC_IO_DEBUG_SEL0_32K_XTAL: u32 = 4;
pub const RTC_IO_DEBUG_SEL0_150K_OSC: u32 = 5;
pub const RTC_IO_DIG_PAD_HOLD_REG: u32 = 1072989300;
pub const RTC_IO_DIG_PAD_HOLD: u32 = 4294967295;
pub const RTC_IO_DIG_PAD_HOLD_V: u32 = 4294967295;
pub const RTC_IO_DIG_PAD_HOLD_S: u32 = 0;
pub const RTC_IO_HALL_SENS_REG: u32 = 1072989304;
pub const RTC_IO_XPD_HALL_V: u32 = 1;
pub const RTC_IO_XPD_HALL_S: u32 = 31;
pub const RTC_IO_HALL_PHASE_V: u32 = 1;
pub const RTC_IO_HALL_PHASE_S: u32 = 30;
pub const RTC_IO_SENSOR_PADS_REG: u32 = 1072989308;
pub const RTC_IO_SENSE1_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE1_HOLD_S: u32 = 31;
pub const RTC_IO_SENSE2_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE2_HOLD_S: u32 = 30;
pub const RTC_IO_SENSE3_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE3_HOLD_S: u32 = 29;
pub const RTC_IO_SENSE4_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE4_HOLD_S: u32 = 28;
pub const RTC_IO_SENSE1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE1_MUX_SEL_S: u32 = 27;
pub const RTC_IO_SENSE2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE2_MUX_SEL_S: u32 = 26;
pub const RTC_IO_SENSE3_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE3_MUX_SEL_S: u32 = 25;
pub const RTC_IO_SENSE4_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE4_MUX_SEL_S: u32 = 24;
pub const RTC_IO_SENSE1_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE1_FUN_SEL_S: u32 = 22;
pub const RTC_IO_SENSE1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE1_SLP_SEL_S: u32 = 21;
pub const RTC_IO_SENSE1_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE1_SLP_IE_S: u32 = 20;
pub const RTC_IO_SENSE1_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE1_FUN_IE_S: u32 = 19;
pub const RTC_IO_SENSE2_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE2_FUN_SEL_S: u32 = 17;
pub const RTC_IO_SENSE2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE2_SLP_SEL_S: u32 = 16;
pub const RTC_IO_SENSE2_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE2_SLP_IE_S: u32 = 15;
pub const RTC_IO_SENSE2_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE2_FUN_IE_S: u32 = 14;
pub const RTC_IO_SENSE3_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE3_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE3_FUN_SEL_S: u32 = 12;
pub const RTC_IO_SENSE3_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE3_SLP_SEL_S: u32 = 11;
pub const RTC_IO_SENSE3_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE3_SLP_IE_S: u32 = 10;
pub const RTC_IO_SENSE3_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE3_FUN_IE_S: u32 = 9;
pub const RTC_IO_SENSE4_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE4_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE4_FUN_SEL_S: u32 = 7;
pub const RTC_IO_SENSE4_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE4_SLP_SEL_S: u32 = 6;
pub const RTC_IO_SENSE4_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE4_SLP_IE_S: u32 = 5;
pub const RTC_IO_SENSE4_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE4_FUN_IE_S: u32 = 4;
pub const RTC_IO_ADC_PAD_REG: u32 = 1072989312;
pub const RTC_IO_ADC1_HOLD_V: u32 = 1;
pub const RTC_IO_ADC1_HOLD_S: u32 = 31;
pub const RTC_IO_ADC2_HOLD_V: u32 = 1;
pub const RTC_IO_ADC2_HOLD_S: u32 = 30;
pub const RTC_IO_ADC1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_ADC1_MUX_SEL_S: u32 = 29;
pub const RTC_IO_ADC2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_ADC2_MUX_SEL_S: u32 = 28;
pub const RTC_IO_ADC1_FUN_SEL: u32 = 3;
pub const RTC_IO_ADC1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_ADC1_FUN_SEL_S: u32 = 26;
pub const RTC_IO_ADC1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_ADC1_SLP_SEL_S: u32 = 25;
pub const RTC_IO_ADC1_SLP_IE_V: u32 = 1;
pub const RTC_IO_ADC1_SLP_IE_S: u32 = 24;
pub const RTC_IO_ADC1_FUN_IE_V: u32 = 1;
pub const RTC_IO_ADC1_FUN_IE_S: u32 = 23;
pub const RTC_IO_ADC2_FUN_SEL: u32 = 3;
pub const RTC_IO_ADC2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_ADC2_FUN_SEL_S: u32 = 21;
pub const RTC_IO_ADC2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_ADC2_SLP_SEL_S: u32 = 20;
pub const RTC_IO_ADC2_SLP_IE_V: u32 = 1;
pub const RTC_IO_ADC2_SLP_IE_S: u32 = 19;
pub const RTC_IO_ADC2_FUN_IE_V: u32 = 1;
pub const RTC_IO_ADC2_FUN_IE_S: u32 = 18;
pub const RTC_IO_PAD_DAC1_REG: u32 = 1072989316;
pub const RTC_IO_PDAC1_DRV: u32 = 3;
pub const RTC_IO_PDAC1_DRV_V: u32 = 3;
pub const RTC_IO_PDAC1_DRV_S: u32 = 30;
pub const RTC_IO_PDAC1_HOLD_V: u32 = 1;
pub const RTC_IO_PDAC1_HOLD_S: u32 = 29;
pub const RTC_IO_PDAC1_RDE_V: u32 = 1;
pub const RTC_IO_PDAC1_RDE_S: u32 = 28;
pub const RTC_IO_PDAC1_RUE_V: u32 = 1;
pub const RTC_IO_PDAC1_RUE_S: u32 = 27;
pub const RTC_IO_PDAC1_DAC: u32 = 255;
pub const RTC_IO_PDAC1_DAC_V: u32 = 255;
pub const RTC_IO_PDAC1_DAC_S: u32 = 19;
pub const RTC_IO_PDAC1_XPD_DAC_V: u32 = 1;
pub const RTC_IO_PDAC1_XPD_DAC_S: u32 = 18;
pub const RTC_IO_PDAC1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_PDAC1_MUX_SEL_S: u32 = 17;
pub const RTC_IO_PDAC1_FUN_SEL: u32 = 3;
pub const RTC_IO_PDAC1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_PDAC1_FUN_SEL_S: u32 = 15;
pub const RTC_IO_PDAC1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_PDAC1_SLP_SEL_S: u32 = 14;
pub const RTC_IO_PDAC1_SLP_IE_V: u32 = 1;
pub const RTC_IO_PDAC1_SLP_IE_S: u32 = 13;
pub const RTC_IO_PDAC1_SLP_OE_V: u32 = 1;
pub const RTC_IO_PDAC1_SLP_OE_S: u32 = 12;
pub const RTC_IO_PDAC1_FUN_IE_V: u32 = 1;
pub const RTC_IO_PDAC1_FUN_IE_S: u32 = 11;
pub const RTC_IO_PDAC1_DAC_XPD_FORCE_V: u32 = 1;
pub const RTC_IO_PDAC1_DAC_XPD_FORCE_S: u32 = 10;
pub const RTC_IO_PAD_DAC2_REG: u32 = 1072989320;
pub const RTC_IO_PDAC2_DRV: u32 = 3;
pub const RTC_IO_PDAC2_DRV_V: u32 = 3;
pub const RTC_IO_PDAC2_DRV_S: u32 = 30;
pub const RTC_IO_PDAC2_HOLD_V: u32 = 1;
pub const RTC_IO_PDAC2_HOLD_S: u32 = 29;
pub const RTC_IO_PDAC2_RDE_V: u32 = 1;
pub const RTC_IO_PDAC2_RDE_S: u32 = 28;
pub const RTC_IO_PDAC2_RUE_V: u32 = 1;
pub const RTC_IO_PDAC2_RUE_S: u32 = 27;
pub const RTC_IO_PDAC2_DAC: u32 = 255;
pub const RTC_IO_PDAC2_DAC_V: u32 = 255;
pub const RTC_IO_PDAC2_DAC_S: u32 = 19;
pub const RTC_IO_PDAC2_XPD_DAC_V: u32 = 1;
pub const RTC_IO_PDAC2_XPD_DAC_S: u32 = 18;
pub const RTC_IO_PDAC2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_PDAC2_MUX_SEL_S: u32 = 17;
pub const RTC_IO_PDAC2_FUN_SEL: u32 = 3;
pub const RTC_IO_PDAC2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_PDAC2_FUN_SEL_S: u32 = 15;
pub const RTC_IO_PDAC2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_PDAC2_SLP_SEL_S: u32 = 14;
pub const RTC_IO_PDAC2_SLP_IE_V: u32 = 1;
pub const RTC_IO_PDAC2_SLP_IE_S: u32 = 13;
pub const RTC_IO_PDAC2_SLP_OE_V: u32 = 1;
pub const RTC_IO_PDAC2_SLP_OE_S: u32 = 12;
pub const RTC_IO_PDAC2_FUN_IE_V: u32 = 1;
pub const RTC_IO_PDAC2_FUN_IE_S: u32 = 11;
pub const RTC_IO_PDAC2_DAC_XPD_FORCE_V: u32 = 1;
pub const RTC_IO_PDAC2_DAC_XPD_FORCE_S: u32 = 10;
pub const RTC_IO_XTAL_32K_PAD_REG: u32 = 1072989324;
pub const RTC_IO_X32N_DRV: u32 = 3;
pub const RTC_IO_X32N_DRV_V: u32 = 3;
pub const RTC_IO_X32N_DRV_S: u32 = 30;
pub const RTC_IO_X32N_HOLD_V: u32 = 1;
pub const RTC_IO_X32N_HOLD_S: u32 = 29;
pub const RTC_IO_X32N_RDE_V: u32 = 1;
pub const RTC_IO_X32N_RDE_S: u32 = 28;
pub const RTC_IO_X32N_RUE_V: u32 = 1;
pub const RTC_IO_X32N_RUE_S: u32 = 27;
pub const RTC_IO_X32P_DRV: u32 = 3;
pub const RTC_IO_X32P_DRV_V: u32 = 3;
pub const RTC_IO_X32P_DRV_S: u32 = 25;
pub const RTC_IO_X32P_HOLD_V: u32 = 1;
pub const RTC_IO_X32P_HOLD_S: u32 = 24;
pub const RTC_IO_X32P_RDE_V: u32 = 1;
pub const RTC_IO_X32P_RDE_S: u32 = 23;
pub const RTC_IO_X32P_RUE_V: u32 = 1;
pub const RTC_IO_X32P_RUE_S: u32 = 22;
pub const RTC_IO_DAC_XTAL_32K: u32 = 3;
pub const RTC_IO_DAC_XTAL_32K_V: u32 = 3;
pub const RTC_IO_DAC_XTAL_32K_S: u32 = 20;
pub const RTC_IO_XPD_XTAL_32K_V: u32 = 1;
pub const RTC_IO_XPD_XTAL_32K_S: u32 = 19;
pub const RTC_IO_X32N_MUX_SEL_V: u32 = 1;
pub const RTC_IO_X32N_MUX_SEL_S: u32 = 18;
pub const RTC_IO_X32P_MUX_SEL_V: u32 = 1;
pub const RTC_IO_X32P_MUX_SEL_S: u32 = 17;
pub const RTC_IO_X32N_FUN_SEL: u32 = 3;
pub const RTC_IO_X32N_FUN_SEL_V: u32 = 3;
pub const RTC_IO_X32N_FUN_SEL_S: u32 = 15;
pub const RTC_IO_X32N_SLP_SEL_V: u32 = 1;
pub const RTC_IO_X32N_SLP_SEL_S: u32 = 14;
pub const RTC_IO_X32N_SLP_IE_V: u32 = 1;
pub const RTC_IO_X32N_SLP_IE_S: u32 = 13;
pub const RTC_IO_X32N_SLP_OE_V: u32 = 1;
pub const RTC_IO_X32N_SLP_OE_S: u32 = 12;
pub const RTC_IO_X32N_FUN_IE_V: u32 = 1;
pub const RTC_IO_X32N_FUN_IE_S: u32 = 11;
pub const RTC_IO_X32P_FUN_SEL: u32 = 3;
pub const RTC_IO_X32P_FUN_SEL_V: u32 = 3;
pub const RTC_IO_X32P_FUN_SEL_S: u32 = 9;
pub const RTC_IO_X32P_SLP_SEL_V: u32 = 1;
pub const RTC_IO_X32P_SLP_SEL_S: u32 = 8;
pub const RTC_IO_X32P_SLP_IE_V: u32 = 1;
pub const RTC_IO_X32P_SLP_IE_S: u32 = 7;
pub const RTC_IO_X32P_SLP_OE_V: u32 = 1;
pub const RTC_IO_X32P_SLP_OE_S: u32 = 6;
pub const RTC_IO_X32P_FUN_IE_V: u32 = 1;
pub const RTC_IO_X32P_FUN_IE_S: u32 = 5;
pub const RTC_IO_DRES_XTAL_32K: u32 = 3;
pub const RTC_IO_DRES_XTAL_32K_V: u32 = 3;
pub const RTC_IO_DRES_XTAL_32K_S: u32 = 3;
pub const RTC_IO_DBIAS_XTAL_32K: u32 = 3;
pub const RTC_IO_DBIAS_XTAL_32K_V: u32 = 3;
pub const RTC_IO_DBIAS_XTAL_32K_S: u32 = 1;
pub const RTC_IO_TOUCH_CFG_REG: u32 = 1072989328;
pub const RTC_IO_TOUCH_XPD_BIAS_V: u32 = 1;
pub const RTC_IO_TOUCH_XPD_BIAS_S: u32 = 31;
pub const RTC_IO_TOUCH_DREFH: u32 = 3;
pub const RTC_IO_TOUCH_DREFH_V: u32 = 3;
pub const RTC_IO_TOUCH_DREFH_S: u32 = 29;
pub const RTC_IO_TOUCH_DREFL: u32 = 3;
pub const RTC_IO_TOUCH_DREFL_V: u32 = 3;
pub const RTC_IO_TOUCH_DREFL_S: u32 = 27;
pub const RTC_IO_TOUCH_DRANGE: u32 = 3;
pub const RTC_IO_TOUCH_DRANGE_V: u32 = 3;
pub const RTC_IO_TOUCH_DRANGE_S: u32 = 25;
pub const RTC_IO_TOUCH_DCUR: u32 = 3;
pub const RTC_IO_TOUCH_DCUR_V: u32 = 3;
pub const RTC_IO_TOUCH_DCUR_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD0_REG: u32 = 1072989332;
pub const RTC_IO_TOUCH_PAD0_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD0_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD0_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD0_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD0_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD0_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD0_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD0_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD0_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD0_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD0_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD0_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD0_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD0_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD0_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD0_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD0_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD1_REG: u32 = 1072989336;
pub const RTC_IO_TOUCH_PAD1_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD1_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD1_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD1_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD1_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD1_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD1_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD1_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD1_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD1_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD1_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD1_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD1_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD1_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD1_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD2_REG: u32 = 1072989340;
pub const RTC_IO_TOUCH_PAD2_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD2_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD2_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD2_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD2_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD2_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD2_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD2_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD2_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD2_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD2_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD2_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD2_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD2_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD2_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD3_REG: u32 = 1072989344;
pub const RTC_IO_TOUCH_PAD3_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD3_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD3_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD3_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD3_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD3_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD3_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD3_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD3_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD3_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD3_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD3_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD3_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD3_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD3_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD3_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD3_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD4_REG: u32 = 1072989348;
pub const RTC_IO_TOUCH_PAD4_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD4_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD4_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD4_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD4_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD4_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD4_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD4_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD4_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD4_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD4_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD4_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD4_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD4_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD4_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD4_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD4_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD5_REG: u32 = 1072989352;
pub const RTC_IO_TOUCH_PAD5_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD5_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD5_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD5_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD5_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD5_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD5_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD5_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD5_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD5_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD5_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD5_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD5_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD5_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD5_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD5_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD5_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD6_REG: u32 = 1072989356;
pub const RTC_IO_TOUCH_PAD6_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD6_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD6_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD6_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD6_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD6_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD6_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD6_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD6_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD6_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD6_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD6_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD6_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD6_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD6_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD6_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD6_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD7_REG: u32 = 1072989360;
pub const RTC_IO_TOUCH_PAD7_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD7_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD7_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD7_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD7_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD7_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD7_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD7_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD7_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD7_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD7_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD7_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD7_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD7_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD7_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD7_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD7_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD8_REG: u32 = 1072989364;
pub const RTC_IO_TOUCH_PAD8_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD8_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD8_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD8_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD8_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD8_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD8_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_TO_GPIO_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD9_REG: u32 = 1072989368;
pub const RTC_IO_TOUCH_PAD9_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD9_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD9_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD9_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD9_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD9_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD9_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_TO_GPIO_S: u32 = 19;
pub const RTC_IO_EXT_WAKEUP0_REG: u32 = 1072989372;
pub const RTC_IO_EXT_WAKEUP0_SEL: u32 = 31;
pub const RTC_IO_EXT_WAKEUP0_SEL_V: u32 = 31;
pub const RTC_IO_EXT_WAKEUP0_SEL_S: u32 = 27;
pub const RTC_IO_XTL_EXT_CTR_REG: u32 = 1072989376;
pub const RTC_IO_XTL_EXT_CTR_SEL: u32 = 31;
pub const RTC_IO_XTL_EXT_CTR_SEL_V: u32 = 31;
pub const RTC_IO_XTL_EXT_CTR_SEL_S: u32 = 27;
pub const RTC_IO_SAR_I2C_IO_REG: u32 = 1072989380;
pub const RTC_IO_SAR_I2C_SDA_SEL: u32 = 3;
pub const RTC_IO_SAR_I2C_SDA_SEL_V: u32 = 3;
pub const RTC_IO_SAR_I2C_SDA_SEL_S: u32 = 30;
pub const RTC_IO_SAR_I2C_SCL_SEL: u32 = 3;
pub const RTC_IO_SAR_I2C_SCL_SEL_V: u32 = 3;
pub const RTC_IO_SAR_I2C_SCL_SEL_S: u32 = 28;
pub const RTC_IO_SAR_DEBUG_BIT_SEL: u32 = 31;
pub const RTC_IO_SAR_DEBUG_BIT_SEL_V: u32 = 31;
pub const RTC_IO_SAR_DEBUG_BIT_SEL_S: u32 = 23;
pub const RTC_IO_DATE_REG: u32 = 1072989384;
pub const RTC_IO_IO_DATE: u32 = 268435455;
pub const RTC_IO_IO_DATE_V: u32 = 268435455;
pub const RTC_IO_IO_DATE_S: u32 = 0;
pub const RTC_IO_RTC_IO_DATE_VERSION: u32 = 24129888;
pub const RTC_CNTL_WDT_WKEY_VALUE: u32 = 1356348065;
pub const RTC_CNTL_OPTIONS0_REG: u32 = 1072988160;
pub const RTC_CNTL_SW_SYS_RST_V: u32 = 1;
pub const RTC_CNTL_SW_SYS_RST_S: u32 = 31;
pub const RTC_CNTL_DG_WRAP_FORCE_NORST_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_NORST_S: u32 = 30;
pub const RTC_CNTL_DG_WRAP_FORCE_RST_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_RST_S: u32 = 29;
pub const RTC_CNTL_ANALOG_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_ANALOG_FORCE_NOISO_S: u32 = 28;
pub const RTC_CNTL_PLL_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_PLL_FORCE_NOISO_S: u32 = 27;
pub const RTC_CNTL_XTL_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_NOISO_S: u32 = 26;
pub const RTC_CNTL_ANALOG_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_ANALOG_FORCE_ISO_S: u32 = 25;
pub const RTC_CNTL_PLL_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_PLL_FORCE_ISO_S: u32 = 24;
pub const RTC_CNTL_XTL_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_ISO_S: u32 = 23;
pub const RTC_CNTL_BIAS_CORE_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BIAS_CORE_FORCE_PU_S: u32 = 22;
pub const RTC_CNTL_BIAS_CORE_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BIAS_CORE_FORCE_PD_S: u32 = 21;
pub const RTC_CNTL_BIAS_CORE_FOLW_8M_V: u32 = 1;
pub const RTC_CNTL_BIAS_CORE_FOLW_8M_S: u32 = 20;
pub const RTC_CNTL_BIAS_I2C_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BIAS_I2C_FORCE_PU_S: u32 = 19;
pub const RTC_CNTL_BIAS_I2C_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BIAS_I2C_FORCE_PD_S: u32 = 18;
pub const RTC_CNTL_BIAS_I2C_FOLW_8M_V: u32 = 1;
pub const RTC_CNTL_BIAS_I2C_FOLW_8M_S: u32 = 17;
pub const RTC_CNTL_BIAS_FORCE_NOSLEEP_V: u32 = 1;
pub const RTC_CNTL_BIAS_FORCE_NOSLEEP_S: u32 = 16;
pub const RTC_CNTL_BIAS_FORCE_SLEEP_V: u32 = 1;
pub const RTC_CNTL_BIAS_FORCE_SLEEP_S: u32 = 15;
pub const RTC_CNTL_BIAS_SLEEP_FOLW_8M_V: u32 = 1;
pub const RTC_CNTL_BIAS_SLEEP_FOLW_8M_S: u32 = 14;
pub const RTC_CNTL_XTL_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_PU_S: u32 = 13;
pub const RTC_CNTL_XTL_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_PD_S: u32 = 12;
pub const RTC_CNTL_BBPLL_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BBPLL_FORCE_PU_S: u32 = 11;
pub const RTC_CNTL_BBPLL_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BBPLL_FORCE_PD_S: u32 = 10;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PU_S: u32 = 9;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PD_S: u32 = 8;
pub const RTC_CNTL_BB_I2C_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BB_I2C_FORCE_PU_S: u32 = 7;
pub const RTC_CNTL_BB_I2C_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BB_I2C_FORCE_PD_S: u32 = 6;
pub const RTC_CNTL_SW_PROCPU_RST_V: u32 = 1;
pub const RTC_CNTL_SW_PROCPU_RST_S: u32 = 5;
pub const RTC_CNTL_SW_APPCPU_RST_V: u32 = 1;
pub const RTC_CNTL_SW_APPCPU_RST_S: u32 = 4;
pub const RTC_CNTL_SW_STALL_PROCPU_C0: u32 = 3;
pub const RTC_CNTL_SW_STALL_PROCPU_C0_V: u32 = 3;
pub const RTC_CNTL_SW_STALL_PROCPU_C0_S: u32 = 2;
pub const RTC_CNTL_SW_STALL_APPCPU_C0: u32 = 3;
pub const RTC_CNTL_SW_STALL_APPCPU_C0_V: u32 = 3;
pub const RTC_CNTL_SW_STALL_APPCPU_C0_S: u32 = 0;
pub const RTC_CNTL_SLP_TIMER0_REG: u32 = 1072988164;
pub const RTC_CNTL_SLP_VAL_LO: u32 = 4294967295;
pub const RTC_CNTL_SLP_VAL_LO_V: u32 = 4294967295;
pub const RTC_CNTL_SLP_VAL_LO_S: u32 = 0;
pub const RTC_CNTL_SLP_TIMER1_REG: u32 = 1072988168;
pub const RTC_CNTL_MAIN_TIMER_ALARM_EN_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_ALARM_EN_S: u32 = 16;
pub const RTC_CNTL_SLP_VAL_HI: u32 = 65535;
pub const RTC_CNTL_SLP_VAL_HI_V: u32 = 65535;
pub const RTC_CNTL_SLP_VAL_HI_S: u32 = 0;
pub const RTC_CNTL_TIME_UPDATE_REG: u32 = 1072988172;
pub const RTC_CNTL_TIME_UPDATE_V: u32 = 1;
pub const RTC_CNTL_TIME_UPDATE_S: u32 = 31;
pub const RTC_CNTL_TIME_VALID_V: u32 = 1;
pub const RTC_CNTL_TIME_VALID_S: u32 = 30;
pub const RTC_CNTL_TIME0_REG: u32 = 1072988176;
pub const RTC_CNTL_TIME_LO: u32 = 4294967295;
pub const RTC_CNTL_TIME_LO_V: u32 = 4294967295;
pub const RTC_CNTL_TIME_LO_S: u32 = 0;
pub const RTC_CNTL_TIME1_REG: u32 = 1072988180;
pub const RTC_CNTL_TIME_HI: u32 = 65535;
pub const RTC_CNTL_TIME_HI_V: u32 = 65535;
pub const RTC_CNTL_TIME_HI_S: u32 = 0;
pub const RTC_CNTL_STATE0_REG: u32 = 1072988184;
pub const RTC_CNTL_SLEEP_EN_V: u32 = 1;
pub const RTC_CNTL_SLEEP_EN_S: u32 = 31;
pub const RTC_CNTL_SLP_REJECT_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_S: u32 = 30;
pub const RTC_CNTL_SLP_WAKEUP_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_S: u32 = 29;
pub const RTC_CNTL_SDIO_ACTIVE_IND_V: u32 = 1;
pub const RTC_CNTL_SDIO_ACTIVE_IND_S: u32 = 28;
pub const RTC_CNTL_ULP_CP_SLP_TIMER_EN_V: u32 = 1;
pub const RTC_CNTL_ULP_CP_SLP_TIMER_EN_S: u32 = 24;
pub const RTC_CNTL_TOUCH_SLP_TIMER_EN_V: u32 = 1;
pub const RTC_CNTL_TOUCH_SLP_TIMER_EN_S: u32 = 23;
pub const RTC_CNTL_APB2RTC_BRIDGE_SEL_V: u32 = 1;
pub const RTC_CNTL_APB2RTC_BRIDGE_SEL_S: u32 = 22;
pub const RTC_CNTL_ULP_CP_WAKEUP_FORCE_EN_V: u32 = 1;
pub const RTC_CNTL_ULP_CP_WAKEUP_FORCE_EN_S: u32 = 21;
pub const RTC_CNTL_TOUCH_WAKEUP_FORCE_EN_V: u32 = 1;
pub const RTC_CNTL_TOUCH_WAKEUP_FORCE_EN_S: u32 = 20;
pub const RTC_CNTL_TIMER1_REG: u32 = 1072988188;
pub const RTC_CNTL_PLL_BUF_WAIT: u32 = 255;
pub const RTC_CNTL_PLL_BUF_WAIT_V: u32 = 255;
pub const RTC_CNTL_PLL_BUF_WAIT_S: u32 = 24;
pub const RTC_CNTL_PLL_BUF_WAIT_DEFAULT: u32 = 20;
pub const RTC_CNTL_XTL_BUF_WAIT: u32 = 1023;
pub const RTC_CNTL_XTL_BUF_WAIT_V: u32 = 1023;
pub const RTC_CNTL_XTL_BUF_WAIT_S: u32 = 14;
pub const RTC_CNTL_XTL_BUF_WAIT_DEFAULT: u32 = 20;
pub const RTC_CNTL_CK8M_WAIT: u32 = 255;
pub const RTC_CNTL_CK8M_WAIT_V: u32 = 255;
pub const RTC_CNTL_CK8M_WAIT_S: u32 = 6;
pub const RTC_CNTL_CK8M_WAIT_DEFAULT: u32 = 20;
pub const RTC_CNTL_CPU_STALL_WAIT: u32 = 31;
pub const RTC_CNTL_CPU_STALL_WAIT_V: u32 = 31;
pub const RTC_CNTL_CPU_STALL_WAIT_S: u32 = 1;
pub const RTC_CNTL_CPU_STALL_EN_V: u32 = 1;
pub const RTC_CNTL_CPU_STALL_EN_S: u32 = 0;
pub const RTC_CNTL_TIMER2_REG: u32 = 1072988192;
pub const RTC_CNTL_MIN_TIME_CK8M_OFF: u32 = 255;
pub const RTC_CNTL_MIN_TIME_CK8M_OFF_V: u32 = 255;
pub const RTC_CNTL_MIN_TIME_CK8M_OFF_S: u32 = 24;
pub const RTC_CNTL_ULPCP_TOUCH_START_WAIT: u32 = 511;
pub const RTC_CNTL_ULPCP_TOUCH_START_WAIT_V: u32 = 511;
pub const RTC_CNTL_ULPCP_TOUCH_START_WAIT_S: u32 = 15;
pub const RTC_CNTL_TIMER3_REG: u32 = 1072988196;
pub const RTC_CNTL_ROM_RAM_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_ROM_RAM_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_ROM_RAM_POWERUP_TIMER_S: u32 = 25;
pub const RTC_CNTL_ROM_RAM_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_ROM_RAM_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_ROM_RAM_WAIT_TIMER_S: u32 = 16;
pub const RTC_CNTL_WIFI_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_WIFI_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_WIFI_POWERUP_TIMER_S: u32 = 9;
pub const RTC_CNTL_WIFI_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_WIFI_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_WIFI_WAIT_TIMER_S: u32 = 0;
pub const RTC_CNTL_TIMER4_REG: u32 = 1072988200;
pub const RTC_CNTL_DG_WRAP_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_DG_WRAP_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_DG_WRAP_POWERUP_TIMER_S: u32 = 25;
pub const RTC_CNTL_DG_WRAP_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_DG_WRAP_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_DG_WRAP_WAIT_TIMER_S: u32 = 16;
pub const RTC_CNTL_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_POWERUP_TIMER_S: u32 = 9;
pub const RTC_CNTL_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_WAIT_TIMER_S: u32 = 0;
pub const RTC_CNTL_TIMER5_REG: u32 = 1072988204;
pub const RTC_CNTL_RTCMEM_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_RTCMEM_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_RTCMEM_POWERUP_TIMER_S: u32 = 25;
pub const RTC_CNTL_RTCMEM_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_RTCMEM_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_RTCMEM_WAIT_TIMER_S: u32 = 16;
pub const RTC_CNTL_MIN_SLP_VAL: u32 = 255;
pub const RTC_CNTL_MIN_SLP_VAL_V: u32 = 255;
pub const RTC_CNTL_MIN_SLP_VAL_S: u32 = 8;
pub const RTC_CNTL_MIN_SLP_VAL_MIN: u32 = 2;
pub const RTC_CNTL_ULP_CP_SUBTIMER_PREDIV: u32 = 255;
pub const RTC_CNTL_ULP_CP_SUBTIMER_PREDIV_V: u32 = 255;
pub const RTC_CNTL_ULP_CP_SUBTIMER_PREDIV_S: u32 = 0;
pub const RTC_CNTL_ANA_CONF_REG: u32 = 1072988208;
pub const RTC_CNTL_PLL_I2C_PU_V: u32 = 1;
pub const RTC_CNTL_PLL_I2C_PU_S: u32 = 31;
pub const RTC_CNTL_CKGEN_I2C_PU_V: u32 = 1;
pub const RTC_CNTL_CKGEN_I2C_PU_S: u32 = 30;
pub const RTC_CNTL_RFRX_PBUS_PU_V: u32 = 1;
pub const RTC_CNTL_RFRX_PBUS_PU_S: u32 = 28;
pub const RTC_CNTL_TXRF_I2C_PU_V: u32 = 1;
pub const RTC_CNTL_TXRF_I2C_PU_S: u32 = 27;
pub const RTC_CNTL_PVTMON_PU_V: u32 = 1;
pub const RTC_CNTL_PVTMON_PU_S: u32 = 26;
pub const RTC_CNTL_BBPLL_CAL_SLP_START_V: u32 = 1;
pub const RTC_CNTL_BBPLL_CAL_SLP_START_S: u32 = 25;
pub const RTC_CNTL_PLLA_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_PLLA_FORCE_PU_S: u32 = 24;
pub const RTC_CNTL_PLLA_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_PLLA_FORCE_PD_S: u32 = 23;
pub const RTC_CNTL_RESET_STATE_REG: u32 = 1072988212;
pub const RTC_CNTL_PROCPU_STAT_VECTOR_SEL_V: u32 = 1;
pub const RTC_CNTL_PROCPU_STAT_VECTOR_SEL_S: u32 = 13;
pub const RTC_CNTL_APPCPU_STAT_VECTOR_SEL_V: u32 = 1;
pub const RTC_CNTL_APPCPU_STAT_VECTOR_SEL_S: u32 = 12;
pub const RTC_CNTL_RESET_CAUSE_APPCPU: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_APPCPU_V: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_APPCPU_S: u32 = 6;
pub const RTC_CNTL_RESET_CAUSE_PROCPU: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_PROCPU_V: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_PROCPU_S: u32 = 0;
pub const RTC_CNTL_WAKEUP_STATE_REG: u32 = 1072988216;
pub const RTC_CNTL_GPIO_WAKEUP_FILTER_V: u32 = 1;
pub const RTC_CNTL_GPIO_WAKEUP_FILTER_S: u32 = 22;
pub const RTC_CNTL_WAKEUP_ENA: u32 = 2047;
pub const RTC_CNTL_WAKEUP_ENA_V: u32 = 2047;
pub const RTC_CNTL_WAKEUP_ENA_S: u32 = 11;
pub const RTC_CNTL_WAKEUP_CAUSE: u32 = 2047;
pub const RTC_CNTL_WAKEUP_CAUSE_V: u32 = 2047;
pub const RTC_CNTL_WAKEUP_CAUSE_S: u32 = 0;
pub const RTC_CNTL_INT_ENA_REG: u32 = 1072988220;
pub const RTC_CNTL_MAIN_TIMER_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_ENA_S: u32 = 8;
pub const RTC_CNTL_BROWN_OUT_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_ENA_S: u32 = 7;
pub const RTC_CNTL_TOUCH_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_TOUCH_INT_ENA_S: u32 = 6;
pub const RTC_CNTL_ULP_CP_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_ULP_CP_INT_ENA_S: u32 = 5;
pub const RTC_CNTL_TIME_VALID_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_TIME_VALID_INT_ENA_S: u32 = 4;
pub const RTC_CNTL_WDT_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_ENA_S: u32 = 3;
pub const RTC_CNTL_SDIO_IDLE_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_SDIO_IDLE_INT_ENA_S: u32 = 2;
pub const RTC_CNTL_SLP_REJECT_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_ENA_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ENA_S: u32 = 0;
pub const RTC_CNTL_INT_RAW_REG: u32 = 1072988224;
pub const RTC_CNTL_MAIN_TIMER_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_RAW_S: u32 = 8;
pub const RTC_CNTL_BROWN_OUT_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_RAW_S: u32 = 7;
pub const RTC_CNTL_TOUCH_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_TOUCH_INT_RAW_S: u32 = 6;
pub const RTC_CNTL_ULP_CP_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_ULP_CP_INT_RAW_S: u32 = 5;
pub const RTC_CNTL_TIME_VALID_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_TIME_VALID_INT_RAW_S: u32 = 4;
pub const RTC_CNTL_WDT_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_RAW_S: u32 = 3;
pub const RTC_CNTL_SDIO_IDLE_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_SDIO_IDLE_INT_RAW_S: u32 = 2;
pub const RTC_CNTL_SLP_REJECT_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_RAW_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_RAW_S: u32 = 0;
pub const RTC_CNTL_INT_ST_REG: u32 = 1072988228;
pub const RTC_CNTL_MAIN_TIMER_INT_ST_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_ST_S: u32 = 8;
pub const RTC_CNTL_BROWN_OUT_INT_ST_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_ST_S: u32 = 7;
pub const RTC_CNTL_TOUCH_INT_ST_V: u32 = 1;
pub const RTC_CNTL_TOUCH_INT_ST_S: u32 = 6;
pub const RTC_CNTL_SAR_INT_ST_V: u32 = 1;
pub const RTC_CNTL_SAR_INT_ST_S: u32 = 5;
pub const RTC_CNTL_TIME_VALID_INT_ST_V: u32 = 1;
pub const RTC_CNTL_TIME_VALID_INT_ST_S: u32 = 4;
pub const RTC_CNTL_WDT_INT_ST_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_ST_S: u32 = 3;
pub const RTC_CNTL_SDIO_IDLE_INT_ST_V: u32 = 1;
pub const RTC_CNTL_SDIO_IDLE_INT_ST_S: u32 = 2;
pub const RTC_CNTL_SLP_REJECT_INT_ST_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_ST_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ST_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ST_S: u32 = 0;
pub const RTC_CNTL_INT_CLR_REG: u32 = 1072988232;
pub const RTC_CNTL_MAIN_TIMER_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_CLR_S: u32 = 8;
pub const RTC_CNTL_BROWN_OUT_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_CLR_S: u32 = 7;
pub const RTC_CNTL_TOUCH_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_TOUCH_INT_CLR_S: u32 = 6;
pub const RTC_CNTL_SAR_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_SAR_INT_CLR_S: u32 = 5;
pub const RTC_CNTL_TIME_VALID_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_TIME_VALID_INT_CLR_S: u32 = 4;
pub const RTC_CNTL_WDT_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_CLR_S: u32 = 3;
pub const RTC_CNTL_SDIO_IDLE_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_SDIO_IDLE_INT_CLR_S: u32 = 2;
pub const RTC_CNTL_SLP_REJECT_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_CLR_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_CLR_S: u32 = 0;
pub const RTC_CNTL_STORE0_REG: u32 = 1072988236;
pub const RTC_CNTL_SCRATCH0: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH0_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH0_S: u32 = 0;
pub const RTC_CNTL_STORE1_REG: u32 = 1072988240;
pub const RTC_CNTL_SCRATCH1: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH1_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH1_S: u32 = 0;
pub const RTC_CNTL_STORE2_REG: u32 = 1072988244;
pub const RTC_CNTL_SCRATCH2: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH2_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH2_S: u32 = 0;
pub const RTC_CNTL_STORE3_REG: u32 = 1072988248;
pub const RTC_CNTL_SCRATCH3: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH3_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH3_S: u32 = 0;
pub const RTC_CNTL_EXT_XTL_CONF_REG: u32 = 1072988252;
pub const RTC_CNTL_XTL_EXT_CTR_EN_V: u32 = 1;
pub const RTC_CNTL_XTL_EXT_CTR_EN_S: u32 = 31;
pub const RTC_CNTL_XTL_EXT_CTR_LV_V: u32 = 1;
pub const RTC_CNTL_XTL_EXT_CTR_LV_S: u32 = 30;
pub const RTC_CNTL_EXT_WAKEUP_CONF_REG: u32 = 1072988256;
pub const RTC_CNTL_EXT_WAKEUP1_LV_V: u32 = 1;
pub const RTC_CNTL_EXT_WAKEUP1_LV_S: u32 = 31;
pub const RTC_CNTL_EXT_WAKEUP0_LV_V: u32 = 1;
pub const RTC_CNTL_EXT_WAKEUP0_LV_S: u32 = 30;
pub const RTC_CNTL_SLP_REJECT_CONF_REG: u32 = 1072988260;
pub const RTC_CNTL_REJECT_CAUSE: u32 = 15;
pub const RTC_CNTL_REJECT_CAUSE_V: u32 = 15;
pub const RTC_CNTL_REJECT_CAUSE_S: u32 = 28;
pub const RTC_CNTL_DEEP_SLP_REJECT_EN_V: u32 = 1;
pub const RTC_CNTL_DEEP_SLP_REJECT_EN_S: u32 = 27;
pub const RTC_CNTL_LIGHT_SLP_REJECT_EN_V: u32 = 1;
pub const RTC_CNTL_LIGHT_SLP_REJECT_EN_S: u32 = 26;
pub const RTC_CNTL_SDIO_REJECT_EN_V: u32 = 1;
pub const RTC_CNTL_SDIO_REJECT_EN_S: u32 = 25;
pub const RTC_CNTL_GPIO_REJECT_EN_V: u32 = 1;
pub const RTC_CNTL_GPIO_REJECT_EN_S: u32 = 24;
pub const RTC_CNTL_CPU_PERIOD_CONF_REG: u32 = 1072988264;
pub const RTC_CNTL_CPUPERIOD_SEL: u32 = 3;
pub const RTC_CNTL_CPUPERIOD_SEL_V: u32 = 3;
pub const RTC_CNTL_CPUPERIOD_SEL_S: u32 = 30;
pub const RTC_CNTL_CPUSEL_CONF_V: u32 = 1;
pub const RTC_CNTL_CPUSEL_CONF_S: u32 = 29;
pub const RTC_CNTL_SDIO_ACT_CONF_REG: u32 = 1072988268;
pub const RTC_CNTL_SDIO_ACT_DNUM: u32 = 1023;
pub const RTC_CNTL_SDIO_ACT_DNUM_V: u32 = 1023;
pub const RTC_CNTL_SDIO_ACT_DNUM_S: u32 = 22;
pub const RTC_CNTL_CLK_CONF_REG: u32 = 1072988272;
pub const RTC_CNTL_ANA_CLK_RTC_SEL: u32 = 3;
pub const RTC_CNTL_ANA_CLK_RTC_SEL_V: u32 = 3;
pub const RTC_CNTL_ANA_CLK_RTC_SEL_S: u32 = 30;
pub const RTC_CNTL_FAST_CLK_RTC_SEL_V: u32 = 1;
pub const RTC_CNTL_FAST_CLK_RTC_SEL_S: u32 = 29;
pub const RTC_CNTL_SOC_CLK_SEL: u32 = 3;
pub const RTC_CNTL_SOC_CLK_SEL_V: u32 = 3;
pub const RTC_CNTL_SOC_CLK_SEL_S: u32 = 27;
pub const RTC_CNTL_SOC_CLK_SEL_XTL: u32 = 0;
pub const RTC_CNTL_SOC_CLK_SEL_PLL: u32 = 1;
pub const RTC_CNTL_SOC_CLK_SEL_8M: u32 = 2;
pub const RTC_CNTL_SOC_CLK_SEL_APLL: u32 = 3;
pub const RTC_CNTL_CK8M_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_CK8M_FORCE_PU_S: u32 = 26;
pub const RTC_CNTL_CK8M_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_CK8M_FORCE_PD_S: u32 = 25;
pub const RTC_CNTL_CK8M_DFREQ: u32 = 255;
pub const RTC_CNTL_CK8M_DFREQ_V: u32 = 255;
pub const RTC_CNTL_CK8M_DFREQ_S: u32 = 17;
pub const RTC_CNTL_CK8M_DFREQ_DEFAULT: u32 = 172;
pub const RTC_CNTL_CK8M_FORCE_NOGATING_V: u32 = 1;
pub const RTC_CNTL_CK8M_FORCE_NOGATING_S: u32 = 16;
pub const RTC_CNTL_XTAL_FORCE_NOGATING_V: u32 = 1;
pub const RTC_CNTL_XTAL_FORCE_NOGATING_S: u32 = 15;
pub const RTC_CNTL_CK8M_DIV_SEL: u32 = 7;
pub const RTC_CNTL_CK8M_DIV_SEL_V: u32 = 7;
pub const RTC_CNTL_CK8M_DIV_SEL_S: u32 = 12;
pub const RTC_CNTL_CK8M_DFREQ_FORCE_V: u32 = 1;
pub const RTC_CNTL_CK8M_DFREQ_FORCE_S: u32 = 11;
pub const RTC_CNTL_DIG_CLK8M_EN_V: u32 = 1;
pub const RTC_CNTL_DIG_CLK8M_EN_S: u32 = 10;
pub const RTC_CNTL_DIG_CLK8M_D256_EN_V: u32 = 1;
pub const RTC_CNTL_DIG_CLK8M_D256_EN_S: u32 = 9;
pub const RTC_CNTL_DIG_XTAL32K_EN_V: u32 = 1;
pub const RTC_CNTL_DIG_XTAL32K_EN_S: u32 = 8;
pub const RTC_CNTL_ENB_CK8M_DIV_V: u32 = 1;
pub const RTC_CNTL_ENB_CK8M_DIV_S: u32 = 7;
pub const RTC_CNTL_ENB_CK8M_V: u32 = 1;
pub const RTC_CNTL_ENB_CK8M_S: u32 = 6;
pub const RTC_CNTL_CK8M_DIV: u32 = 3;
pub const RTC_CNTL_CK8M_DIV_V: u32 = 3;
pub const RTC_CNTL_CK8M_DIV_S: u32 = 4;
pub const RTC_CNTL_SDIO_CONF_REG: u32 = 1072988276;
pub const RTC_CNTL_XPD_SDIO_REG_V: u32 = 1;
pub const RTC_CNTL_XPD_SDIO_REG_S: u32 = 31;
pub const RTC_CNTL_DREFH_SDIO: u32 = 3;
pub const RTC_CNTL_DREFH_SDIO_V: u32 = 3;
pub const RTC_CNTL_DREFH_SDIO_S: u32 = 29;
pub const RTC_CNTL_DREFM_SDIO: u32 = 3;
pub const RTC_CNTL_DREFM_SDIO_V: u32 = 3;
pub const RTC_CNTL_DREFM_SDIO_S: u32 = 27;
pub const RTC_CNTL_DREFL_SDIO: u32 = 3;
pub const RTC_CNTL_DREFL_SDIO_V: u32 = 3;
pub const RTC_CNTL_DREFL_SDIO_S: u32 = 25;
pub const RTC_CNTL_REG1P8_READY_V: u32 = 1;
pub const RTC_CNTL_REG1P8_READY_S: u32 = 24;
pub const RTC_CNTL_SDIO_TIEH_V: u32 = 1;
pub const RTC_CNTL_SDIO_TIEH_S: u32 = 23;
pub const RTC_CNTL_SDIO_FORCE_V: u32 = 1;
pub const RTC_CNTL_SDIO_FORCE_S: u32 = 22;
pub const RTC_CNTL_SDIO_PD_EN_V: u32 = 1;
pub const RTC_CNTL_SDIO_PD_EN_S: u32 = 21;
pub const RTC_CNTL_BIAS_CONF_REG: u32 = 1072988280;
pub const RTC_CNTL_RST_BIAS_I2C_V: u32 = 1;
pub const RTC_CNTL_RST_BIAS_I2C_S: u32 = 31;
pub const RTC_CNTL_DEC_HEARTBEAT_WIDTH_V: u32 = 1;
pub const RTC_CNTL_DEC_HEARTBEAT_WIDTH_S: u32 = 30;
pub const RTC_CNTL_INC_HEARTBEAT_PERIOD_V: u32 = 1;
pub const RTC_CNTL_INC_HEARTBEAT_PERIOD_S: u32 = 29;
pub const RTC_CNTL_DEC_HEARTBEAT_PERIOD_V: u32 = 1;
pub const RTC_CNTL_DEC_HEARTBEAT_PERIOD_S: u32 = 28;
pub const RTC_CNTL_INC_HEARTBEAT_REFRESH_V: u32 = 1;
pub const RTC_CNTL_INC_HEARTBEAT_REFRESH_S: u32 = 27;
pub const RTC_CNTL_ENB_SCK_XTAL_V: u32 = 1;
pub const RTC_CNTL_ENB_SCK_XTAL_S: u32 = 26;
pub const RTC_CNTL_DBG_ATTEN: u32 = 3;
pub const RTC_CNTL_DBG_ATTEN_V: u32 = 3;
pub const RTC_CNTL_DBG_ATTEN_S: u32 = 24;
pub const RTC_CNTL_DBG_ATTEN_DEFAULT: u32 = 3;
pub const RTC_CNTL_REG: u32 = 1072988284;
pub const RTC_CNTL_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_FORCE_PU_S: u32 = 31;
pub const RTC_CNTL_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_FORCE_PD_S: u32 = 30;
pub const RTC_CNTL_DBOOST_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_DBOOST_FORCE_PU_S: u32 = 29;
pub const RTC_CNTL_DBOOST_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_DBOOST_FORCE_PD_S: u32 = 28;
pub const RTC_CNTL_DBIAS_WAK: u32 = 7;
pub const RTC_CNTL_DBIAS_WAK_V: u32 = 7;
pub const RTC_CNTL_DBIAS_WAK_S: u32 = 25;
pub const RTC_CNTL_DBIAS_SLP: u32 = 7;
pub const RTC_CNTL_DBIAS_SLP_V: u32 = 7;
pub const RTC_CNTL_DBIAS_SLP_S: u32 = 22;
pub const RTC_CNTL_SCK_DCAP: u32 = 255;
pub const RTC_CNTL_SCK_DCAP_V: u32 = 255;
pub const RTC_CNTL_SCK_DCAP_S: u32 = 14;
pub const RTC_CNTL_SCK_DCAP_DEFAULT: u32 = 255;
pub const RTC_CNTL_DIG_DBIAS_WAK: u32 = 7;
pub const RTC_CNTL_DIG_DBIAS_WAK_V: u32 = 7;
pub const RTC_CNTL_DIG_DBIAS_WAK_S: u32 = 11;
pub const RTC_CNTL_DIG_DBIAS_SLP: u32 = 7;
pub const RTC_CNTL_DIG_DBIAS_SLP_V: u32 = 7;
pub const RTC_CNTL_DIG_DBIAS_SLP_S: u32 = 8;
pub const RTC_CNTL_SCK_DCAP_FORCE_V: u32 = 1;
pub const RTC_CNTL_SCK_DCAP_FORCE_S: u32 = 7;
pub const RTC_CNTL_DBIAS_0V90: u32 = 0;
pub const RTC_CNTL_DBIAS_0V95: u32 = 1;
pub const RTC_CNTL_DBIAS_1V00: u32 = 2;
pub const RTC_CNTL_DBIAS_1V05: u32 = 3;
pub const RTC_CNTL_DBIAS_1V10: u32 = 4;
pub const RTC_CNTL_DBIAS_1V15: u32 = 5;
pub const RTC_CNTL_DBIAS_1V20: u32 = 6;
pub const RTC_CNTL_DBIAS_1V25: u32 = 7;
pub const RTC_CNTL_PWC_REG: u32 = 1072988288;
pub const RTC_CNTL_PD_EN_V: u32 = 1;
pub const RTC_CNTL_PD_EN_S: u32 = 20;
pub const RTC_CNTL_PWC_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_PWC_FORCE_PU_S: u32 = 19;
pub const RTC_CNTL_PWC_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_PWC_FORCE_PD_S: u32 = 18;
pub const RTC_CNTL_SLOWMEM_PD_EN_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_PD_EN_S: u32 = 17;
pub const RTC_CNTL_SLOWMEM_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_PU_S: u32 = 16;
pub const RTC_CNTL_SLOWMEM_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_PD_S: u32 = 15;
pub const RTC_CNTL_FASTMEM_PD_EN_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_PD_EN_S: u32 = 14;
pub const RTC_CNTL_FASTMEM_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_PU_S: u32 = 13;
pub const RTC_CNTL_FASTMEM_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_PD_S: u32 = 12;
pub const RTC_CNTL_SLOWMEM_FORCE_LPU_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_LPU_S: u32 = 11;
pub const RTC_CNTL_SLOWMEM_FORCE_LPD_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_LPD_S: u32 = 10;
pub const RTC_CNTL_SLOWMEM_FOLW_CPU_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FOLW_CPU_S: u32 = 9;
pub const RTC_CNTL_FASTMEM_FORCE_LPU_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_LPU_S: u32 = 8;
pub const RTC_CNTL_FASTMEM_FORCE_LPD_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_LPD_S: u32 = 7;
pub const RTC_CNTL_FASTMEM_FOLW_CPU_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FOLW_CPU_S: u32 = 6;
pub const RTC_CNTL_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_FORCE_NOISO_S: u32 = 5;
pub const RTC_CNTL_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_FORCE_ISO_S: u32 = 4;
pub const RTC_CNTL_SLOWMEM_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_ISO_S: u32 = 3;
pub const RTC_CNTL_SLOWMEM_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_NOISO_S: u32 = 2;
pub const RTC_CNTL_FASTMEM_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_ISO_S: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_NOISO_S: u32 = 0;
pub const RTC_CNTL_DIG_PWC_REG: u32 = 1072988292;
pub const RTC_CNTL_DG_WRAP_PD_EN_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_PD_EN_S: u32 = 31;
pub const RTC_CNTL_WIFI_PD_EN_V: u32 = 1;
pub const RTC_CNTL_WIFI_PD_EN_S: u32 = 30;
pub const RTC_CNTL_INTER_RAM4_PD_EN_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM4_PD_EN_S: u32 = 29;
pub const RTC_CNTL_INTER_RAM3_PD_EN_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM3_PD_EN_S: u32 = 28;
pub const RTC_CNTL_INTER_RAM2_PD_EN_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM2_PD_EN_S: u32 = 27;
pub const RTC_CNTL_INTER_RAM1_PD_EN_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM1_PD_EN_S: u32 = 26;
pub const RTC_CNTL_INTER_RAM0_PD_EN_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM0_PD_EN_S: u32 = 25;
pub const RTC_CNTL_ROM0_PD_EN_V: u32 = 1;
pub const RTC_CNTL_ROM0_PD_EN_S: u32 = 24;
pub const RTC_CNTL_DG_WRAP_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_PU_S: u32 = 20;
pub const RTC_CNTL_DG_WRAP_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_PD_S: u32 = 19;
pub const RTC_CNTL_WIFI_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_PU_S: u32 = 18;
pub const RTC_CNTL_WIFI_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_PD_S: u32 = 17;
pub const RTC_CNTL_INTER_RAM4_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM4_FORCE_PU_S: u32 = 16;
pub const RTC_CNTL_INTER_RAM4_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM4_FORCE_PD_S: u32 = 15;
pub const RTC_CNTL_INTER_RAM3_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM3_FORCE_PU_S: u32 = 14;
pub const RTC_CNTL_INTER_RAM3_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM3_FORCE_PD_S: u32 = 13;
pub const RTC_CNTL_INTER_RAM2_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM2_FORCE_PU_S: u32 = 12;
pub const RTC_CNTL_INTER_RAM2_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM2_FORCE_PD_S: u32 = 11;
pub const RTC_CNTL_INTER_RAM1_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM1_FORCE_PU_S: u32 = 10;
pub const RTC_CNTL_INTER_RAM1_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM1_FORCE_PD_S: u32 = 9;
pub const RTC_CNTL_INTER_RAM0_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM0_FORCE_PU_S: u32 = 8;
pub const RTC_CNTL_INTER_RAM0_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM0_FORCE_PD_S: u32 = 7;
pub const RTC_CNTL_ROM0_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_ROM0_FORCE_PU_S: u32 = 6;
pub const RTC_CNTL_ROM0_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_ROM0_FORCE_PD_S: u32 = 5;
pub const RTC_CNTL_LSLP_MEM_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_LSLP_MEM_FORCE_PU_S: u32 = 4;
pub const RTC_CNTL_LSLP_MEM_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_LSLP_MEM_FORCE_PD_S: u32 = 3;
pub const RTC_CNTL_DIG_ISO_REG: u32 = 1072988296;
pub const RTC_CNTL_DG_WRAP_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_NOISO_S: u32 = 31;
pub const RTC_CNTL_DG_WRAP_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_ISO_S: u32 = 30;
pub const RTC_CNTL_WIFI_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_NOISO_S: u32 = 29;
pub const RTC_CNTL_WIFI_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_ISO_S: u32 = 28;
pub const RTC_CNTL_INTER_RAM4_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM4_FORCE_NOISO_S: u32 = 27;
pub const RTC_CNTL_INTER_RAM4_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM4_FORCE_ISO_S: u32 = 26;
pub const RTC_CNTL_INTER_RAM3_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM3_FORCE_NOISO_S: u32 = 25;
pub const RTC_CNTL_INTER_RAM3_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM3_FORCE_ISO_S: u32 = 24;
pub const RTC_CNTL_INTER_RAM2_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM2_FORCE_NOISO_S: u32 = 23;
pub const RTC_CNTL_INTER_RAM2_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM2_FORCE_ISO_S: u32 = 22;
pub const RTC_CNTL_INTER_RAM1_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM1_FORCE_NOISO_S: u32 = 21;
pub const RTC_CNTL_INTER_RAM1_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM1_FORCE_ISO_S: u32 = 20;
pub const RTC_CNTL_INTER_RAM0_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM0_FORCE_NOISO_S: u32 = 19;
pub const RTC_CNTL_INTER_RAM0_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM0_FORCE_ISO_S: u32 = 18;
pub const RTC_CNTL_ROM0_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_ROM0_FORCE_NOISO_S: u32 = 17;
pub const RTC_CNTL_ROM0_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_ROM0_FORCE_ISO_S: u32 = 16;
pub const RTC_CNTL_DG_PAD_FORCE_HOLD_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_HOLD_S: u32 = 15;
pub const RTC_CNTL_DG_PAD_FORCE_UNHOLD_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_UNHOLD_S: u32 = 14;
pub const RTC_CNTL_DG_PAD_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_ISO_S: u32 = 13;
pub const RTC_CNTL_DG_PAD_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_NOISO_S: u32 = 12;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_EN_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_EN_S: u32 = 11;
pub const RTC_CNTL_CLR_DG_PAD_AUTOHOLD_V: u32 = 1;
pub const RTC_CNTL_CLR_DG_PAD_AUTOHOLD_S: u32 = 10;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_S: u32 = 9;
pub const RTC_CNTL_DIG_ISO_FORCE_ON_V: u32 = 1;
pub const RTC_CNTL_DIG_ISO_FORCE_ON_S: u32 = 8;
pub const RTC_CNTL_DIG_ISO_FORCE_OFF_V: u32 = 1;
pub const RTC_CNTL_DIG_ISO_FORCE_OFF_S: u32 = 7;
pub const RTC_CNTL_WDTCONFIG0_REG: u32 = 1072988300;
pub const RTC_CNTL_WDT_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_EN_S: u32 = 31;
pub const RTC_CNTL_WDT_STG0: u32 = 7;
pub const RTC_CNTL_WDT_STG0_V: u32 = 7;
pub const RTC_CNTL_WDT_STG0_S: u32 = 28;
pub const RTC_CNTL_WDT_STG1: u32 = 7;
pub const RTC_CNTL_WDT_STG1_V: u32 = 7;
pub const RTC_CNTL_WDT_STG1_S: u32 = 25;
pub const RTC_CNTL_WDT_STG2: u32 = 7;
pub const RTC_CNTL_WDT_STG2_V: u32 = 7;
pub const RTC_CNTL_WDT_STG2_S: u32 = 22;
pub const RTC_CNTL_WDT_STG3: u32 = 7;
pub const RTC_CNTL_WDT_STG3_V: u32 = 7;
pub const RTC_CNTL_WDT_STG3_S: u32 = 19;
pub const RTC_CNTL_WDT_EDGE_INT_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_EDGE_INT_EN_S: u32 = 18;
pub const RTC_CNTL_WDT_LEVEL_INT_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_LEVEL_INT_EN_S: u32 = 17;
pub const RTC_CNTL_WDT_CPU_RESET_LENGTH: u32 = 7;
pub const RTC_CNTL_WDT_CPU_RESET_LENGTH_V: u32 = 7;
pub const RTC_CNTL_WDT_CPU_RESET_LENGTH_S: u32 = 14;
pub const RTC_CNTL_WDT_SYS_RESET_LENGTH: u32 = 7;
pub const RTC_CNTL_WDT_SYS_RESET_LENGTH_V: u32 = 7;
pub const RTC_CNTL_WDT_SYS_RESET_LENGTH_S: u32 = 11;
pub const RTC_CNTL_WDT_FLASHBOOT_MOD_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_FLASHBOOT_MOD_EN_S: u32 = 10;
pub const RTC_CNTL_WDT_PROCPU_RESET_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_PROCPU_RESET_EN_S: u32 = 9;
pub const RTC_CNTL_WDT_APPCPU_RESET_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_APPCPU_RESET_EN_S: u32 = 8;
pub const RTC_CNTL_WDT_PAUSE_IN_SLP_V: u32 = 1;
pub const RTC_CNTL_WDT_PAUSE_IN_SLP_S: u32 = 7;
pub const RTC_WDT_STG_SEL_OFF: u32 = 0;
pub const RTC_WDT_STG_SEL_INT: u32 = 1;
pub const RTC_WDT_STG_SEL_RESET_CPU: u32 = 2;
pub const RTC_WDT_STG_SEL_RESET_SYSTEM: u32 = 3;
pub const RTC_WDT_STG_SEL_RESET_RTC: u32 = 4;
pub const RTC_CNTL_WDTCONFIG1_REG: u32 = 1072988304;
pub const RTC_CNTL_WDT_STG0_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG0_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG0_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTCONFIG2_REG: u32 = 1072988308;
pub const RTC_CNTL_WDT_STG1_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG1_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG1_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTCONFIG3_REG: u32 = 1072988312;
pub const RTC_CNTL_WDT_STG2_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG2_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG2_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTCONFIG4_REG: u32 = 1072988316;
pub const RTC_CNTL_WDT_STG3_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG3_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG3_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTFEED_REG: u32 = 1072988320;
pub const RTC_CNTL_WDT_FEED_V: u32 = 1;
pub const RTC_CNTL_WDT_FEED_S: u32 = 31;
pub const RTC_CNTL_WDTWPROTECT_REG: u32 = 1072988324;
pub const RTC_CNTL_WDT_WKEY: u32 = 4294967295;
pub const RTC_CNTL_WDT_WKEY_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_WKEY_S: u32 = 0;
pub const RTC_CNTL_TEST_MUX_REG: u32 = 1072988328;
pub const RTC_CNTL_DTEST_RTC: u32 = 3;
pub const RTC_CNTL_DTEST_RTC_V: u32 = 3;
pub const RTC_CNTL_DTEST_RTC_S: u32 = 30;
pub const RTC_CNTL_ENT_RTC_V: u32 = 1;
pub const RTC_CNTL_ENT_RTC_S: u32 = 29;
pub const RTC_CNTL_SW_CPU_STALL_REG: u32 = 1072988332;
pub const RTC_CNTL_SW_STALL_PROCPU_C1: u32 = 63;
pub const RTC_CNTL_SW_STALL_PROCPU_C1_V: u32 = 63;
pub const RTC_CNTL_SW_STALL_PROCPU_C1_S: u32 = 26;
pub const RTC_CNTL_SW_STALL_APPCPU_C1: u32 = 63;
pub const RTC_CNTL_SW_STALL_APPCPU_C1_V: u32 = 63;
pub const RTC_CNTL_SW_STALL_APPCPU_C1_S: u32 = 20;
pub const RTC_CNTL_STORE4_REG: u32 = 1072988336;
pub const RTC_CNTL_SCRATCH4: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH4_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH4_S: u32 = 0;
pub const RTC_CNTL_STORE5_REG: u32 = 1072988340;
pub const RTC_CNTL_SCRATCH5: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH5_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH5_S: u32 = 0;
pub const RTC_CNTL_STORE6_REG: u32 = 1072988344;
pub const RTC_CNTL_SCRATCH6: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH6_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH6_S: u32 = 0;
pub const RTC_CNTL_STORE7_REG: u32 = 1072988348;
pub const RTC_CNTL_SCRATCH7: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH7_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH7_S: u32 = 0;
pub const RTC_CNTL_LOW_POWER_ST_REG: u32 = 1072988352;
pub const RTC_CNTL_RDY_FOR_WAKEUP_V: u32 = 1;
pub const RTC_CNTL_RDY_FOR_WAKEUP_S: u32 = 19;
pub const RTC_CNTL_DIAG0_REG: u32 = 1072988352;
pub const RTC_CNTL_LOW_POWER_DIAG0: u32 = 4294967295;
pub const RTC_CNTL_LOW_POWER_DIAG0_V: u32 = 4294967295;
pub const RTC_CNTL_LOW_POWER_DIAG0_S: u32 = 0;
pub const RTC_CNTL_DIAG1_REG: u32 = 1072988356;
pub const RTC_CNTL_LOW_POWER_DIAG1: u32 = 4294967295;
pub const RTC_CNTL_LOW_POWER_DIAG1_V: u32 = 4294967295;
pub const RTC_CNTL_LOW_POWER_DIAG1_S: u32 = 0;
pub const RTC_CNTL_HOLD_FORCE_REG: u32 = 1072988360;
pub const RTC_CNTL_X32N_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_X32N_HOLD_FORCE_S: u32 = 17;
pub const RTC_CNTL_X32P_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_X32P_HOLD_FORCE_S: u32 = 16;
pub const RTC_CNTL_TOUCH_PAD7_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD7_HOLD_FORCE_S: u32 = 15;
pub const RTC_CNTL_TOUCH_PAD6_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD6_HOLD_FORCE_S: u32 = 14;
pub const RTC_CNTL_TOUCH_PAD5_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD5_HOLD_FORCE_S: u32 = 13;
pub const RTC_CNTL_TOUCH_PAD4_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD4_HOLD_FORCE_S: u32 = 12;
pub const RTC_CNTL_TOUCH_PAD3_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD3_HOLD_FORCE_S: u32 = 11;
pub const RTC_CNTL_TOUCH_PAD2_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD2_HOLD_FORCE_S: u32 = 10;
pub const RTC_CNTL_TOUCH_PAD1_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD1_HOLD_FORCE_S: u32 = 9;
pub const RTC_CNTL_TOUCH_PAD0_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD0_HOLD_FORCE_S: u32 = 8;
pub const RTC_CNTL_SENSE4_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_SENSE4_HOLD_FORCE_S: u32 = 7;
pub const RTC_CNTL_SENSE3_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_SENSE3_HOLD_FORCE_S: u32 = 6;
pub const RTC_CNTL_SENSE2_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_SENSE2_HOLD_FORCE_S: u32 = 5;
pub const RTC_CNTL_SENSE1_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_SENSE1_HOLD_FORCE_S: u32 = 4;
pub const RTC_CNTL_PDAC2_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_PDAC2_HOLD_FORCE_S: u32 = 3;
pub const RTC_CNTL_PDAC1_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_PDAC1_HOLD_FORCE_S: u32 = 2;
pub const RTC_CNTL_ADC2_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_ADC2_HOLD_FORCE_S: u32 = 1;
pub const RTC_CNTL_ADC1_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_ADC1_HOLD_FORCE_S: u32 = 0;
pub const RTC_CNTL_EXT_WAKEUP1_REG: u32 = 1072988364;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS_CLR_V: u32 = 1;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS_CLR_S: u32 = 18;
pub const RTC_CNTL_EXT_WAKEUP1_SEL: u32 = 262143;
pub const RTC_CNTL_EXT_WAKEUP1_SEL_V: u32 = 262143;
pub const RTC_CNTL_EXT_WAKEUP1_SEL_S: u32 = 0;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS_REG: u32 = 1072988368;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS: u32 = 262143;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS_V: u32 = 262143;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS_S: u32 = 0;
pub const RTC_CNTL_BROWN_OUT_REG: u32 = 1072988372;
pub const RTC_CNTL_BROWN_OUT_DET_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_DET_S: u32 = 31;
pub const RTC_CNTL_BROWN_OUT_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_ENA_S: u32 = 30;
pub const RTC_CNTL_DBROWN_OUT_THRES: u32 = 7;
pub const RTC_CNTL_DBROWN_OUT_THRES_V: u32 = 7;
pub const RTC_CNTL_DBROWN_OUT_THRES_S: u32 = 27;
pub const RTC_CNTL_BROWN_OUT_RST_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_RST_ENA_S: u32 = 26;
pub const RTC_CNTL_BROWN_OUT_RST_WAIT: u32 = 1023;
pub const RTC_CNTL_BROWN_OUT_RST_WAIT_V: u32 = 1023;
pub const RTC_CNTL_BROWN_OUT_RST_WAIT_S: u32 = 16;
pub const RTC_CNTL_BROWN_OUT_PD_RF_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_PD_RF_ENA_S: u32 = 15;
pub const RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_S: u32 = 14;
pub const RTC_MEM_CONF: u32 = 1072988416;
pub const RTC_MEM_CRC_FINISH_V: u32 = 1;
pub const RTC_MEM_CRC_FINISH_S: u32 = 31;
pub const RTC_MEM_CRC_LEN: u32 = 2047;
pub const RTC_MEM_CRC_LEN_V: u32 = 2047;
pub const RTC_MEM_CRC_LEN_S: u32 = 20;
pub const RTC_MEM_CRC_ADDR: u32 = 2047;
pub const RTC_MEM_CRC_ADDR_V: u32 = 2047;
pub const RTC_MEM_CRC_ADDR_S: u32 = 9;
pub const RTC_MEM_CRC_START_V: u32 = 1;
pub const RTC_MEM_CRC_START_S: u32 = 8;
pub const RTC_MEM_PID_CONF: u32 = 255;
pub const RTC_MEM_PID_CONF_M: u32 = 255;
pub const RTC_MEM_PID_CONF_V: u32 = 255;
pub const RTC_MEM_PID_CONF_S: u32 = 0;
pub const RTC_MEM_CRC_RES: u32 = 1072988420;
pub const RTC_CNTL_DATE_REG: u32 = 1072988476;
pub const RTC_CNTL_CNTL_DATE: u32 = 268435455;
pub const RTC_CNTL_CNTL_DATE_V: u32 = 268435455;
pub const RTC_CNTL_CNTL_DATE_S: u32 = 0;
pub const RTC_CNTL_RTC_CNTL_DATE_VERSION: u32 = 23085696;
pub const RTCIO_GPIO36_CHANNEL: u32 = 0;
pub const RTCIO_CHANNEL_0_GPIO_NUM: u32 = 36;
pub const RTCIO_GPIO37_CHANNEL: u32 = 1;
pub const RTCIO_CHANNEL_1_GPIO_NUM: u32 = 37;
pub const RTCIO_GPIO38_CHANNEL: u32 = 2;
pub const RTCIO_CHANNEL_2_GPIO_NUM: u32 = 38;
pub const RTCIO_GPIO39_CHANNEL: u32 = 3;
pub const RTCIO_CHANNEL_3_GPIO_NUM: u32 = 39;
pub const RTCIO_GPIO34_CHANNEL: u32 = 4;
pub const RTCIO_CHANNEL_4_GPIO_NUM: u32 = 34;
pub const RTCIO_GPIO35_CHANNEL: u32 = 5;
pub const RTCIO_CHANNEL_5_GPIO_NUM: u32 = 35;
pub const RTCIO_GPIO25_CHANNEL: u32 = 6;
pub const RTCIO_CHANNEL_6_GPIO_NUM: u32 = 25;
pub const RTCIO_GPIO26_CHANNEL: u32 = 7;
pub const RTCIO_CHANNEL_7_GPIO_NUM: u32 = 26;
pub const RTCIO_GPIO33_CHANNEL: u32 = 8;
pub const RTCIO_CHANNEL_8_GPIO_NUM: u32 = 33;
pub const RTCIO_GPIO32_CHANNEL: u32 = 9;
pub const RTCIO_CHANNEL_9_GPIO_NUM: u32 = 32;
pub const RTCIO_GPIO4_CHANNEL: u32 = 10;
pub const RTCIO_CHANNEL_10_GPIO_NUM: u32 = 4;
pub const RTCIO_GPIO0_CHANNEL: u32 = 11;
pub const RTCIO_CHANNEL_11_GPIO_NUM: u32 = 0;
pub const RTCIO_GPIO2_CHANNEL: u32 = 12;
pub const RTCIO_CHANNEL_12_GPIO_NUM: u32 = 2;
pub const RTCIO_GPIO15_CHANNEL: u32 = 13;
pub const RTCIO_CHANNEL_13_GPIO_NUM: u32 = 15;
pub const RTCIO_GPIO13_CHANNEL: u32 = 14;
pub const RTCIO_CHANNEL_14_GPIO_NUM: u32 = 13;
pub const RTCIO_GPIO12_CHANNEL: u32 = 15;
pub const RTCIO_CHANNEL_15_GPIO_NUM: u32 = 12;
pub const RTCIO_GPIO14_CHANNEL: u32 = 16;
pub const RTCIO_CHANNEL_16_GPIO_NUM: u32 = 14;
pub const RTCIO_GPIO27_CHANNEL: u32 = 17;
pub const RTCIO_CHANNEL_17_GPIO_NUM: u32 = 27;
pub const I2S_PIN_NO_CHANGE: i32 = -1;
pub const LEDC_APB_CLK_HZ: u32 = 80000000;
pub const LEDC_REF_CLK_HZ: u32 = 1000000;
pub const LEDC_ERR_DUTY: u32 = 4294967295;
pub const LEDC_ERR_VAL: i32 = -1;
pub const LLDESC_TX_MBLK_SIZE: u32 = 268;
pub const LLDESC_RX_SMBLK_SIZE: u32 = 64;
pub const LLDESC_RX_MBLK_SIZE: u32 = 524;
pub const LLDESC_RX_AMPDU_ENTRY_MBLK_SIZE: u32 = 64;
pub const LLDESC_RX_AMPDU_LEN_MBLK_SIZE: u32 = 256;
pub const LLDESC_TX_MBLK_NUM: u32 = 10;
pub const LLDESC_RX_MBLK_NUM: u32 = 10;
pub const LLDESC_RX_AMPDU_ENTRY_MBLK_NUM: u32 = 4;
pub const LLDESC_RX_AMPDU_LEN_MLBK_NUM: u32 = 8;
pub const LLDESC_OWNER_MASK: u32 = 2147483648;
pub const LLDESC_OWNER_SHIFT: u32 = 31;
pub const LLDESC_SW_OWNED: u32 = 0;
pub const LLDESC_HW_OWNED: u32 = 1;
pub const LLDESC_EOF_MASK: u32 = 1073741824;
pub const LLDESC_EOF_SHIFT: u32 = 30;
pub const LLDESC_SOSF_MASK: u32 = 536870912;
pub const LLDESC_SOSF_SHIFT: u32 = 29;
pub const LLDESC_LENGTH_MASK: u32 = 16773120;
pub const LLDESC_LENGTH_SHIFT: u32 = 12;
pub const LLDESC_SIZE_MASK: u32 = 4095;
pub const LLDESC_SIZE_SHIFT: u32 = 0;
pub const LLDESC_ADDR_MASK: u32 = 1048575;
pub const SOC_SPI_PERIPH_NUM: u32 = 3;
pub const SOC_SPI_DMA_CHAN_NUM: u32 = 2;
pub const SPI_IOMUX_PIN_NUM_MISO: u32 = 7;
pub const SPI_IOMUX_PIN_NUM_MOSI: u32 = 8;
pub const SPI_IOMUX_PIN_NUM_CLK: u32 = 6;
pub const SPI_IOMUX_PIN_NUM_CS: u32 = 11;
pub const SPI_IOMUX_PIN_NUM_WP: u32 = 10;
pub const SPI_IOMUX_PIN_NUM_HD: u32 = 9;
pub const SPI_D2WD_PIN_NUM_MISO: u32 = 17;
pub const SPI_D2WD_PIN_NUM_MOSI: u32 = 8;
pub const SPI_D2WD_PIN_NUM_CLK: u32 = 6;
pub const SPI_D2WD_PIN_NUM_CS: u32 = 16;
pub const SPI_D2WD_PIN_NUM_WP: u32 = 7;
pub const SPI_D2WD_PIN_NUM_HD: u32 = 11;
pub const HSPI_IOMUX_PIN_NUM_MISO: u32 = 12;
pub const HSPI_IOMUX_PIN_NUM_MOSI: u32 = 13;
pub const HSPI_IOMUX_PIN_NUM_CLK: u32 = 14;
pub const HSPI_IOMUX_PIN_NUM_CS: u32 = 15;
pub const HSPI_IOMUX_PIN_NUM_WP: u32 = 2;
pub const HSPI_IOMUX_PIN_NUM_HD: u32 = 4;
pub const VSPI_IOMUX_PIN_NUM_MISO: u32 = 19;
pub const VSPI_IOMUX_PIN_NUM_MOSI: u32 = 23;
pub const VSPI_IOMUX_PIN_NUM_CLK: u32 = 18;
pub const VSPI_IOMUX_PIN_NUM_CS: u32 = 5;
pub const VSPI_IOMUX_PIN_NUM_WP: u32 = 22;
pub const VSPI_IOMUX_PIN_NUM_HD: u32 = 21;
pub const SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 64;
pub const SOC_SPI_SUPPORT_AS_CS: u32 = 1;
pub const SPI_FLASH_READ_V: u32 = 1;
pub const SPI_FLASH_READ_S: u32 = 31;
pub const SPI_FLASH_WREN_V: u32 = 1;
pub const SPI_FLASH_WREN_S: u32 = 30;
pub const SPI_FLASH_WRDI_V: u32 = 1;
pub const SPI_FLASH_WRDI_S: u32 = 29;
pub const SPI_FLASH_RDID_V: u32 = 1;
pub const SPI_FLASH_RDID_S: u32 = 28;
pub const SPI_FLASH_RDSR_V: u32 = 1;
pub const SPI_FLASH_RDSR_S: u32 = 27;
pub const SPI_FLASH_WRSR_V: u32 = 1;
pub const SPI_FLASH_WRSR_S: u32 = 26;
pub const SPI_FLASH_PP_V: u32 = 1;
pub const SPI_FLASH_PP_S: u32 = 25;
pub const SPI_FLASH_SE_V: u32 = 1;
pub const SPI_FLASH_SE_S: u32 = 24;
pub const SPI_FLASH_BE_V: u32 = 1;
pub const SPI_FLASH_BE_S: u32 = 23;
pub const SPI_FLASH_CE_V: u32 = 1;
pub const SPI_FLASH_CE_S: u32 = 22;
pub const SPI_FLASH_DP_V: u32 = 1;
pub const SPI_FLASH_DP_S: u32 = 21;
pub const SPI_FLASH_RES_V: u32 = 1;
pub const SPI_FLASH_RES_S: u32 = 20;
pub const SPI_FLASH_HPM_V: u32 = 1;
pub const SPI_FLASH_HPM_S: u32 = 19;
pub const SPI_USR_V: u32 = 1;
pub const SPI_USR_S: u32 = 18;
pub const SPI_FLASH_PES_V: u32 = 1;
pub const SPI_FLASH_PES_S: u32 = 17;
pub const SPI_FLASH_PER_V: u32 = 1;
pub const SPI_FLASH_PER_S: u32 = 16;
pub const SPI_WR_BIT_ORDER_V: u32 = 1;
pub const SPI_WR_BIT_ORDER_S: u32 = 26;
pub const SPI_RD_BIT_ORDER_V: u32 = 1;
pub const SPI_RD_BIT_ORDER_S: u32 = 25;
pub const SPI_FREAD_QIO_V: u32 = 1;
pub const SPI_FREAD_QIO_S: u32 = 24;
pub const SPI_FREAD_DIO_V: u32 = 1;
pub const SPI_FREAD_DIO_S: u32 = 23;
pub const SPI_WRSR_2B_V: u32 = 1;
pub const SPI_WRSR_2B_S: u32 = 22;
pub const SPI_WP_REG_V: u32 = 1;
pub const SPI_WP_REG_S: u32 = 21;
pub const SPI_FREAD_QUAD_V: u32 = 1;
pub const SPI_FREAD_QUAD_S: u32 = 20;
pub const SPI_RESANDRES_V: u32 = 1;
pub const SPI_RESANDRES_S: u32 = 15;
pub const SPI_FREAD_DUAL_V: u32 = 1;
pub const SPI_FREAD_DUAL_S: u32 = 14;
pub const SPI_FASTRD_MODE_V: u32 = 1;
pub const SPI_FASTRD_MODE_S: u32 = 13;
pub const SPI_WAIT_FLASH_IDLE_EN_V: u32 = 1;
pub const SPI_WAIT_FLASH_IDLE_EN_S: u32 = 12;
pub const SPI_TX_CRC_EN_V: u32 = 1;
pub const SPI_TX_CRC_EN_S: u32 = 11;
pub const SPI_FCS_CRC_EN_V: u32 = 1;
pub const SPI_FCS_CRC_EN_S: u32 = 10;
pub const SPI_CS_HOLD_DELAY: u32 = 15;
pub const SPI_CS_HOLD_DELAY_V: u32 = 15;
pub const SPI_CS_HOLD_DELAY_S: u32 = 28;
pub const SPI_CS_HOLD_DELAY_RES: u32 = 4095;
pub const SPI_CS_HOLD_DELAY_RES_V: u32 = 4095;
pub const SPI_CS_HOLD_DELAY_RES_S: u32 = 16;
pub const SPI_STATUS_EXT: u32 = 255;
pub const SPI_STATUS_EXT_V: u32 = 255;
pub const SPI_STATUS_EXT_S: u32 = 24;
pub const SPI_WB_MODE: u32 = 255;
pub const SPI_WB_MODE_V: u32 = 255;
pub const SPI_WB_MODE_S: u32 = 16;
pub const SPI_STATUS: u32 = 65535;
pub const SPI_STATUS_V: u32 = 65535;
pub const SPI_STATUS_S: u32 = 0;
pub const SPI_CS_DELAY_NUM: u32 = 15;
pub const SPI_CS_DELAY_NUM_V: u32 = 15;
pub const SPI_CS_DELAY_NUM_S: u32 = 28;
pub const SPI_CS_DELAY_MODE: u32 = 3;
pub const SPI_CS_DELAY_MODE_V: u32 = 3;
pub const SPI_CS_DELAY_MODE_S: u32 = 26;
pub const SPI_MOSI_DELAY_NUM: u32 = 7;
pub const SPI_MOSI_DELAY_NUM_V: u32 = 7;
pub const SPI_MOSI_DELAY_NUM_S: u32 = 23;
pub const SPI_MOSI_DELAY_MODE: u32 = 3;
pub const SPI_MOSI_DELAY_MODE_V: u32 = 3;
pub const SPI_MOSI_DELAY_MODE_S: u32 = 21;
pub const SPI_MISO_DELAY_NUM: u32 = 7;
pub const SPI_MISO_DELAY_NUM_V: u32 = 7;
pub const SPI_MISO_DELAY_NUM_S: u32 = 18;
pub const SPI_MISO_DELAY_MODE: u32 = 3;
pub const SPI_MISO_DELAY_MODE_V: u32 = 3;
pub const SPI_MISO_DELAY_MODE_S: u32 = 16;
pub const SPI_CK_OUT_HIGH_MODE: u32 = 15;
pub const SPI_CK_OUT_HIGH_MODE_V: u32 = 15;
pub const SPI_CK_OUT_HIGH_MODE_S: u32 = 12;
pub const SPI_CK_OUT_LOW_MODE: u32 = 15;
pub const SPI_CK_OUT_LOW_MODE_V: u32 = 15;
pub const SPI_CK_OUT_LOW_MODE_S: u32 = 8;
pub const SPI_HOLD_TIME: u32 = 15;
pub const SPI_HOLD_TIME_V: u32 = 15;
pub const SPI_HOLD_TIME_S: u32 = 4;
pub const SPI_SETUP_TIME: u32 = 15;
pub const SPI_SETUP_TIME_V: u32 = 15;
pub const SPI_SETUP_TIME_S: u32 = 0;
pub const SPI_CLK_EQU_SYSCLK_V: u32 = 1;
pub const SPI_CLK_EQU_SYSCLK_S: u32 = 31;
pub const SPI_CLKDIV_PRE: u32 = 8191;
pub const SPI_CLKDIV_PRE_V: u32 = 8191;
pub const SPI_CLKDIV_PRE_S: u32 = 18;
pub const SPI_CLKCNT_N: u32 = 63;
pub const SPI_CLKCNT_N_V: u32 = 63;
pub const SPI_CLKCNT_N_S: u32 = 12;
pub const SPI_CLKCNT_H: u32 = 63;
pub const SPI_CLKCNT_H_V: u32 = 63;
pub const SPI_CLKCNT_H_S: u32 = 6;
pub const SPI_CLKCNT_L: u32 = 63;
pub const SPI_CLKCNT_L_V: u32 = 63;
pub const SPI_CLKCNT_L_S: u32 = 0;
pub const SPI_USR_COMMAND_V: u32 = 1;
pub const SPI_USR_COMMAND_S: u32 = 31;
pub const SPI_USR_ADDR_V: u32 = 1;
pub const SPI_USR_ADDR_S: u32 = 30;
pub const SPI_USR_DUMMY_V: u32 = 1;
pub const SPI_USR_DUMMY_S: u32 = 29;
pub const SPI_USR_MISO_V: u32 = 1;
pub const SPI_USR_MISO_S: u32 = 28;
pub const SPI_USR_MOSI_V: u32 = 1;
pub const SPI_USR_MOSI_S: u32 = 27;
pub const SPI_USR_DUMMY_IDLE_V: u32 = 1;
pub const SPI_USR_DUMMY_IDLE_S: u32 = 26;
pub const SPI_USR_MOSI_HIGHPART_V: u32 = 1;
pub const SPI_USR_MOSI_HIGHPART_S: u32 = 25;
pub const SPI_USR_MISO_HIGHPART_V: u32 = 1;
pub const SPI_USR_MISO_HIGHPART_S: u32 = 24;
pub const SPI_USR_PREP_HOLD_V: u32 = 1;
pub const SPI_USR_PREP_HOLD_S: u32 = 23;
pub const SPI_USR_CMD_HOLD_V: u32 = 1;
pub const SPI_USR_CMD_HOLD_S: u32 = 22;
pub const SPI_USR_ADDR_HOLD_V: u32 = 1;
pub const SPI_USR_ADDR_HOLD_S: u32 = 21;
pub const SPI_USR_DUMMY_HOLD_V: u32 = 1;
pub const SPI_USR_DUMMY_HOLD_S: u32 = 20;
pub const SPI_USR_DIN_HOLD_V: u32 = 1;
pub const SPI_USR_DIN_HOLD_S: u32 = 19;
pub const SPI_USR_DOUT_HOLD_V: u32 = 1;
pub const SPI_USR_DOUT_HOLD_S: u32 = 18;
pub const SPI_USR_HOLD_POL_V: u32 = 1;
pub const SPI_USR_HOLD_POL_S: u32 = 17;
pub const SPI_SIO_V: u32 = 1;
pub const SPI_SIO_S: u32 = 16;
pub const SPI_FWRITE_QIO_V: u32 = 1;
pub const SPI_FWRITE_QIO_S: u32 = 15;
pub const SPI_FWRITE_DIO_V: u32 = 1;
pub const SPI_FWRITE_DIO_S: u32 = 14;
pub const SPI_FWRITE_QUAD_V: u32 = 1;
pub const SPI_FWRITE_QUAD_S: u32 = 13;
pub const SPI_FWRITE_DUAL_V: u32 = 1;
pub const SPI_FWRITE_DUAL_S: u32 = 12;
pub const SPI_WR_BYTE_ORDER_V: u32 = 1;
pub const SPI_WR_BYTE_ORDER_S: u32 = 11;
pub const SPI_RD_BYTE_ORDER_V: u32 = 1;
pub const SPI_RD_BYTE_ORDER_S: u32 = 10;
pub const SPI_CK_OUT_EDGE_V: u32 = 1;
pub const SPI_CK_OUT_EDGE_S: u32 = 7;
pub const SPI_CK_I_EDGE_V: u32 = 1;
pub const SPI_CK_I_EDGE_S: u32 = 6;
pub const SPI_CS_SETUP_V: u32 = 1;
pub const SPI_CS_SETUP_S: u32 = 5;
pub const SPI_CS_HOLD_V: u32 = 1;
pub const SPI_CS_HOLD_S: u32 = 4;
pub const SPI_DOUTDIN_V: u32 = 1;
pub const SPI_DOUTDIN_S: u32 = 0;
pub const SPI_USR_ADDR_BITLEN: u32 = 63;
pub const SPI_USR_ADDR_BITLEN_V: u32 = 63;
pub const SPI_USR_ADDR_BITLEN_S: u32 = 26;
pub const SPI_USR_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_USR_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_USR_DUMMY_CYCLELEN_S: u32 = 0;
pub const SPI_USR_COMMAND_BITLEN: u32 = 15;
pub const SPI_USR_COMMAND_BITLEN_V: u32 = 15;
pub const SPI_USR_COMMAND_BITLEN_S: u32 = 28;
pub const SPI_USR_COMMAND_VALUE: u32 = 65535;
pub const SPI_USR_COMMAND_VALUE_V: u32 = 65535;
pub const SPI_USR_COMMAND_VALUE_S: u32 = 0;
pub const SPI_USR_MOSI_DBITLEN: u32 = 16777215;
pub const SPI_USR_MOSI_DBITLEN_V: u32 = 16777215;
pub const SPI_USR_MOSI_DBITLEN_S: u32 = 0;
pub const SPI_USR_MISO_DBITLEN: u32 = 16777215;
pub const SPI_USR_MISO_DBITLEN_V: u32 = 16777215;
pub const SPI_USR_MISO_DBITLEN_S: u32 = 0;
pub const SPI_SLV_WR_ST: u32 = 4294967295;
pub const SPI_SLV_WR_ST_V: u32 = 4294967295;
pub const SPI_SLV_WR_ST_S: u32 = 0;
pub const SPI_CS_KEEP_ACTIVE_V: u32 = 1;
pub const SPI_CS_KEEP_ACTIVE_S: u32 = 30;
pub const SPI_CK_IDLE_EDGE_V: u32 = 1;
pub const SPI_CK_IDLE_EDGE_S: u32 = 29;
pub const SPI_MASTER_CK_SEL: u32 = 7;
pub const SPI_MASTER_CK_SEL_V: u32 = 7;
pub const SPI_MASTER_CK_SEL_S: u32 = 11;
pub const SPI_MASTER_CS_POL: u32 = 7;
pub const SPI_MASTER_CS_POL_V: u32 = 7;
pub const SPI_MASTER_CS_POL_S: u32 = 6;
pub const SPI_CK_DIS_V: u32 = 1;
pub const SPI_CK_DIS_S: u32 = 5;
pub const SPI_CS2_DIS_V: u32 = 1;
pub const SPI_CS2_DIS_S: u32 = 2;
pub const SPI_CS1_DIS_V: u32 = 1;
pub const SPI_CS1_DIS_S: u32 = 1;
pub const SPI_CS0_DIS_V: u32 = 1;
pub const SPI_CS0_DIS_S: u32 = 0;
pub const SPI_SYNC_RESET_V: u32 = 1;
pub const SPI_SYNC_RESET_S: u32 = 31;
pub const SPI_SLAVE_MODE_V: u32 = 1;
pub const SPI_SLAVE_MODE_S: u32 = 30;
pub const SPI_SLV_WR_RD_BUF_EN_V: u32 = 1;
pub const SPI_SLV_WR_RD_BUF_EN_S: u32 = 29;
pub const SPI_SLV_WR_RD_STA_EN_V: u32 = 1;
pub const SPI_SLV_WR_RD_STA_EN_S: u32 = 28;
pub const SPI_SLV_CMD_DEFINE_V: u32 = 1;
pub const SPI_SLV_CMD_DEFINE_S: u32 = 27;
pub const SPI_TRANS_CNT: u32 = 15;
pub const SPI_TRANS_CNT_V: u32 = 15;
pub const SPI_TRANS_CNT_S: u32 = 23;
pub const SPI_SLV_LAST_STATE: u32 = 7;
pub const SPI_SLV_LAST_STATE_V: u32 = 7;
pub const SPI_SLV_LAST_STATE_S: u32 = 20;
pub const SPI_SLV_LAST_COMMAND: u32 = 7;
pub const SPI_SLV_LAST_COMMAND_V: u32 = 7;
pub const SPI_SLV_LAST_COMMAND_S: u32 = 17;
pub const SPI_CS_I_MODE: u32 = 3;
pub const SPI_CS_I_MODE_V: u32 = 3;
pub const SPI_CS_I_MODE_S: u32 = 10;
pub const SPI_INT_EN: u32 = 31;
pub const SPI_INT_EN_V: u32 = 31;
pub const SPI_INT_EN_S: u32 = 5;
pub const SPI_TRANS_DONE_V: u32 = 1;
pub const SPI_TRANS_DONE_S: u32 = 4;
pub const SPI_SLV_WR_STA_DONE_V: u32 = 1;
pub const SPI_SLV_WR_STA_DONE_S: u32 = 3;
pub const SPI_SLV_RD_STA_DONE_V: u32 = 1;
pub const SPI_SLV_RD_STA_DONE_S: u32 = 2;
pub const SPI_SLV_WR_BUF_DONE_V: u32 = 1;
pub const SPI_SLV_WR_BUF_DONE_S: u32 = 1;
pub const SPI_SLV_RD_BUF_DONE_V: u32 = 1;
pub const SPI_SLV_RD_BUF_DONE_S: u32 = 0;
pub const SPI_SLV_STATUS_BITLEN: u32 = 31;
pub const SPI_SLV_STATUS_BITLEN_V: u32 = 31;
pub const SPI_SLV_STATUS_BITLEN_S: u32 = 27;
pub const SPI_SLV_STATUS_FAST_EN_V: u32 = 1;
pub const SPI_SLV_STATUS_FAST_EN_S: u32 = 26;
pub const SPI_SLV_STATUS_READBACK_V: u32 = 1;
pub const SPI_SLV_STATUS_READBACK_S: u32 = 25;
pub const SPI_SLV_RD_ADDR_BITLEN: u32 = 63;
pub const SPI_SLV_RD_ADDR_BITLEN_V: u32 = 63;
pub const SPI_SLV_RD_ADDR_BITLEN_S: u32 = 10;
pub const SPI_SLV_WR_ADDR_BITLEN: u32 = 63;
pub const SPI_SLV_WR_ADDR_BITLEN_V: u32 = 63;
pub const SPI_SLV_WR_ADDR_BITLEN_S: u32 = 4;
pub const SPI_SLV_WRSTA_DUMMY_EN_V: u32 = 1;
pub const SPI_SLV_WRSTA_DUMMY_EN_S: u32 = 3;
pub const SPI_SLV_RDSTA_DUMMY_EN_V: u32 = 1;
pub const SPI_SLV_RDSTA_DUMMY_EN_S: u32 = 2;
pub const SPI_SLV_WRBUF_DUMMY_EN_V: u32 = 1;
pub const SPI_SLV_WRBUF_DUMMY_EN_S: u32 = 1;
pub const SPI_SLV_RDBUF_DUMMY_EN_V: u32 = 1;
pub const SPI_SLV_RDBUF_DUMMY_EN_S: u32 = 0;
pub const SPI_SLV_WRBUF_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_WRBUF_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_SLV_WRBUF_DUMMY_CYCLELEN_S: u32 = 24;
pub const SPI_SLV_RDBUF_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_RDBUF_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_SLV_RDBUF_DUMMY_CYCLELEN_S: u32 = 16;
pub const SPI_SLV_WRSTA_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_WRSTA_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_SLV_WRSTA_DUMMY_CYCLELEN_S: u32 = 8;
pub const SPI_SLV_RDSTA_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_RDSTA_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_SLV_RDSTA_DUMMY_CYCLELEN_S: u32 = 0;
pub const SPI_SLV_WRSTA_CMD_VALUE: u32 = 255;
pub const SPI_SLV_WRSTA_CMD_VALUE_V: u32 = 255;
pub const SPI_SLV_WRSTA_CMD_VALUE_S: u32 = 24;
pub const SPI_SLV_RDSTA_CMD_VALUE: u32 = 255;
pub const SPI_SLV_RDSTA_CMD_VALUE_V: u32 = 255;
pub const SPI_SLV_RDSTA_CMD_VALUE_S: u32 = 16;
pub const SPI_SLV_WRBUF_CMD_VALUE: u32 = 255;
pub const SPI_SLV_WRBUF_CMD_VALUE_V: u32 = 255;
pub const SPI_SLV_WRBUF_CMD_VALUE_S: u32 = 8;
pub const SPI_SLV_RDBUF_CMD_VALUE: u32 = 255;
pub const SPI_SLV_RDBUF_CMD_VALUE_V: u32 = 255;
pub const SPI_SLV_RDBUF_CMD_VALUE_S: u32 = 0;
pub const SPI_SLV_WRBUF_DBITLEN: u32 = 16777215;
pub const SPI_SLV_WRBUF_DBITLEN_V: u32 = 16777215;
pub const SPI_SLV_WRBUF_DBITLEN_S: u32 = 0;
pub const SPI_SLV_RDBUF_DBITLEN: u32 = 16777215;
pub const SPI_SLV_RDBUF_DBITLEN_V: u32 = 16777215;
pub const SPI_SLV_RDBUF_DBITLEN_S: u32 = 0;
pub const SPI_CACHE_FLASH_PES_EN_V: u32 = 1;
pub const SPI_CACHE_FLASH_PES_EN_S: u32 = 3;
pub const SPI_CACHE_FLASH_USR_CMD_V: u32 = 1;
pub const SPI_CACHE_FLASH_USR_CMD_S: u32 = 2;
pub const SPI_CACHE_USR_CMD_4BYTE_V: u32 = 1;
pub const SPI_CACHE_USR_CMD_4BYTE_S: u32 = 1;
pub const SPI_CACHE_REQ_EN_V: u32 = 1;
pub const SPI_CACHE_REQ_EN_S: u32 = 0;
pub const SPI_CACHE_SRAM_USR_WCMD_V: u32 = 1;
pub const SPI_CACHE_SRAM_USR_WCMD_S: u32 = 28;
pub const SPI_SRAM_ADDR_BITLEN: u32 = 63;
pub const SPI_SRAM_ADDR_BITLEN_V: u32 = 63;
pub const SPI_SRAM_ADDR_BITLEN_S: u32 = 22;
pub const SPI_SRAM_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SRAM_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_SRAM_DUMMY_CYCLELEN_S: u32 = 14;
pub const SPI_SRAM_BYTES_LEN: u32 = 255;
pub const SPI_SRAM_BYTES_LEN_V: u32 = 255;
pub const SPI_SRAM_BYTES_LEN_S: u32 = 6;
pub const SPI_CACHE_SRAM_USR_RCMD_V: u32 = 1;
pub const SPI_CACHE_SRAM_USR_RCMD_S: u32 = 5;
pub const SPI_USR_RD_SRAM_DUMMY_V: u32 = 1;
pub const SPI_USR_RD_SRAM_DUMMY_S: u32 = 4;
pub const SPI_USR_WR_SRAM_DUMMY_V: u32 = 1;
pub const SPI_USR_WR_SRAM_DUMMY_S: u32 = 3;
pub const SPI_USR_SRAM_QIO_V: u32 = 1;
pub const SPI_USR_SRAM_QIO_S: u32 = 2;
pub const SPI_USR_SRAM_DIO_V: u32 = 1;
pub const SPI_USR_SRAM_DIO_S: u32 = 1;
pub const SPI_SRAM_RSTIO_V: u32 = 1;
pub const SPI_SRAM_RSTIO_S: u32 = 4;
pub const SPI_SRAM_QIO_V: u32 = 1;
pub const SPI_SRAM_QIO_S: u32 = 1;
pub const SPI_SRAM_DIO_V: u32 = 1;
pub const SPI_SRAM_DIO_S: u32 = 0;
pub const SPI_CACHE_SRAM_USR_RD_CMD_BITLEN: u32 = 15;
pub const SPI_CACHE_SRAM_USR_RD_CMD_BITLEN_V: u32 = 15;
pub const SPI_CACHE_SRAM_USR_RD_CMD_BITLEN_S: u32 = 28;
pub const SPI_CACHE_SRAM_USR_RD_CMD_VALUE: u32 = 65535;
pub const SPI_CACHE_SRAM_USR_RD_CMD_VALUE_V: u32 = 65535;
pub const SPI_CACHE_SRAM_USR_RD_CMD_VALUE_S: u32 = 0;
pub const SPI_CACHE_SRAM_USR_WR_CMD_BITLEN: u32 = 15;
pub const SPI_CACHE_SRAM_USR_WR_CMD_BITLEN_V: u32 = 15;
pub const SPI_CACHE_SRAM_USR_WR_CMD_BITLEN_S: u32 = 28;
pub const SPI_CACHE_SRAM_USR_WR_CMD_VALUE: u32 = 65535;
pub const SPI_CACHE_SRAM_USR_WR_CMD_VALUE_V: u32 = 65535;
pub const SPI_CACHE_SRAM_USR_WR_CMD_VALUE_S: u32 = 0;
pub const SPI_SLV_RDATA_BIT: u32 = 16777215;
pub const SPI_SLV_RDATA_BIT_V: u32 = 16777215;
pub const SPI_SLV_RDATA_BIT_S: u32 = 0;
pub const SPI_BUF0: u32 = 4294967295;
pub const SPI_BUF0_V: u32 = 4294967295;
pub const SPI_BUF0_S: u32 = 0;
pub const SPI_BUF1: u32 = 4294967295;
pub const SPI_BUF1_V: u32 = 4294967295;
pub const SPI_BUF1_S: u32 = 0;
pub const SPI_BUF2: u32 = 4294967295;
pub const SPI_BUF2_V: u32 = 4294967295;
pub const SPI_BUF2_S: u32 = 0;
pub const SPI_BUF3: u32 = 4294967295;
pub const SPI_BUF3_V: u32 = 4294967295;
pub const SPI_BUF3_S: u32 = 0;
pub const SPI_BUF4: u32 = 4294967295;
pub const SPI_BUF4_V: u32 = 4294967295;
pub const SPI_BUF4_S: u32 = 0;
pub const SPI_BUF5: u32 = 4294967295;
pub const SPI_BUF5_V: u32 = 4294967295;
pub const SPI_BUF5_S: u32 = 0;
pub const SPI_BUF6: u32 = 4294967295;
pub const SPI_BUF6_V: u32 = 4294967295;
pub const SPI_BUF6_S: u32 = 0;
pub const SPI_BUF7: u32 = 4294967295;
pub const SPI_BUF7_V: u32 = 4294967295;
pub const SPI_BUF7_S: u32 = 0;
pub const SPI_BUF8: u32 = 4294967295;
pub const SPI_BUF8_V: u32 = 4294967295;
pub const SPI_BUF8_S: u32 = 0;
pub const SPI_BUF9: u32 = 4294967295;
pub const SPI_BUF9_V: u32 = 4294967295;
pub const SPI_BUF9_S: u32 = 0;
pub const SPI_BUF10: u32 = 4294967295;
pub const SPI_BUF10_V: u32 = 4294967295;
pub const SPI_BUF10_S: u32 = 0;
pub const SPI_BUF11: u32 = 4294967295;
pub const SPI_BUF11_V: u32 = 4294967295;
pub const SPI_BUF11_S: u32 = 0;
pub const SPI_BUF12: u32 = 4294967295;
pub const SPI_BUF12_V: u32 = 4294967295;
pub const SPI_BUF12_S: u32 = 0;
pub const SPI_BUF13: u32 = 4294967295;
pub const SPI_BUF13_V: u32 = 4294967295;
pub const SPI_BUF13_S: u32 = 0;
pub const SPI_BUF14: u32 = 4294967295;
pub const SPI_BUF14_V: u32 = 4294967295;
pub const SPI_BUF14_S: u32 = 0;
pub const SPI_BUF15: u32 = 4294967295;
pub const SPI_BUF15_V: u32 = 4294967295;
pub const SPI_BUF15_S: u32 = 0;
pub const SPI_TX_CRC_DATA: u32 = 4294967295;
pub const SPI_TX_CRC_DATA_V: u32 = 4294967295;
pub const SPI_TX_CRC_DATA_S: u32 = 0;
pub const SPI_T_PP_ENA_V: u32 = 1;
pub const SPI_T_PP_ENA_S: u32 = 31;
pub const SPI_T_PP_SHIFT: u32 = 15;
pub const SPI_T_PP_SHIFT_V: u32 = 15;
pub const SPI_T_PP_SHIFT_S: u32 = 16;
pub const SPI_T_PP_TIME: u32 = 4095;
pub const SPI_T_PP_TIME_V: u32 = 4095;
pub const SPI_T_PP_TIME_S: u32 = 0;
pub const SPI_T_ERASE_ENA_V: u32 = 1;
pub const SPI_T_ERASE_ENA_S: u32 = 31;
pub const SPI_T_ERASE_SHIFT: u32 = 15;
pub const SPI_T_ERASE_SHIFT_V: u32 = 15;
pub const SPI_T_ERASE_SHIFT_S: u32 = 16;
pub const SPI_T_ERASE_TIME: u32 = 4095;
pub const SPI_T_ERASE_TIME_V: u32 = 4095;
pub const SPI_T_ERASE_TIME_S: u32 = 0;
pub const SPI_ST: u32 = 7;
pub const SPI_ST_V: u32 = 7;
pub const SPI_ST_S: u32 = 0;
pub const SPI_INT_HOLD_ENA: u32 = 3;
pub const SPI_INT_HOLD_ENA_V: u32 = 3;
pub const SPI_INT_HOLD_ENA_S: u32 = 0;
pub const SPI_DMA_CONTINUE_V: u32 = 1;
pub const SPI_DMA_CONTINUE_S: u32 = 16;
pub const SPI_DMA_TX_STOP_V: u32 = 1;
pub const SPI_DMA_TX_STOP_S: u32 = 15;
pub const SPI_DMA_RX_STOP_V: u32 = 1;
pub const SPI_DMA_RX_STOP_S: u32 = 14;
pub const SPI_OUT_DATA_BURST_EN_V: u32 = 1;
pub const SPI_OUT_DATA_BURST_EN_S: u32 = 12;
pub const SPI_INDSCR_BURST_EN_V: u32 = 1;
pub const SPI_INDSCR_BURST_EN_S: u32 = 11;
pub const SPI_OUTDSCR_BURST_EN_V: u32 = 1;
pub const SPI_OUTDSCR_BURST_EN_S: u32 = 10;
pub const SPI_OUT_EOF_MODE_V: u32 = 1;
pub const SPI_OUT_EOF_MODE_S: u32 = 9;
pub const SPI_OUT_AUTO_WRBACK_V: u32 = 1;
pub const SPI_OUT_AUTO_WRBACK_S: u32 = 8;
pub const SPI_OUT_LOOP_TEST_V: u32 = 1;
pub const SPI_OUT_LOOP_TEST_S: u32 = 7;
pub const SPI_IN_LOOP_TEST_V: u32 = 1;
pub const SPI_IN_LOOP_TEST_S: u32 = 6;
pub const SPI_AHBM_RST_V: u32 = 1;
pub const SPI_AHBM_RST_S: u32 = 5;
pub const SPI_AHBM_FIFO_RST_V: u32 = 1;
pub const SPI_AHBM_FIFO_RST_S: u32 = 4;
pub const SPI_OUT_RST_V: u32 = 1;
pub const SPI_OUT_RST_S: u32 = 3;
pub const SPI_IN_RST_V: u32 = 1;
pub const SPI_IN_RST_S: u32 = 2;
pub const SPI_OUTLINK_RESTART_V: u32 = 1;
pub const SPI_OUTLINK_RESTART_S: u32 = 30;
pub const SPI_OUTLINK_START_V: u32 = 1;
pub const SPI_OUTLINK_START_S: u32 = 29;
pub const SPI_OUTLINK_STOP_V: u32 = 1;
pub const SPI_OUTLINK_STOP_S: u32 = 28;
pub const SPI_OUTLINK_ADDR: u32 = 1048575;
pub const SPI_OUTLINK_ADDR_V: u32 = 1048575;
pub const SPI_OUTLINK_ADDR_S: u32 = 0;
pub const SPI_INLINK_RESTART_V: u32 = 1;
pub const SPI_INLINK_RESTART_S: u32 = 30;
pub const SPI_INLINK_START_V: u32 = 1;
pub const SPI_INLINK_START_S: u32 = 29;
pub const SPI_INLINK_STOP_V: u32 = 1;
pub const SPI_INLINK_STOP_S: u32 = 28;
pub const SPI_INLINK_AUTO_RET_V: u32 = 1;
pub const SPI_INLINK_AUTO_RET_S: u32 = 20;
pub const SPI_INLINK_ADDR: u32 = 1048575;
pub const SPI_INLINK_ADDR_V: u32 = 1048575;
pub const SPI_INLINK_ADDR_S: u32 = 0;
pub const SPI_DMA_TX_EN_V: u32 = 1;
pub const SPI_DMA_TX_EN_S: u32 = 1;
pub const SPI_DMA_RX_EN_V: u32 = 1;
pub const SPI_DMA_RX_EN_S: u32 = 0;
pub const SPI_OUT_TOTAL_EOF_INT_ENA_V: u32 = 1;
pub const SPI_OUT_TOTAL_EOF_INT_ENA_S: u32 = 8;
pub const SPI_OUT_EOF_INT_ENA_V: u32 = 1;
pub const SPI_OUT_EOF_INT_ENA_S: u32 = 7;
pub const SPI_OUT_DONE_INT_ENA_V: u32 = 1;
pub const SPI_OUT_DONE_INT_ENA_S: u32 = 6;
pub const SPI_IN_SUC_EOF_INT_ENA_V: u32 = 1;
pub const SPI_IN_SUC_EOF_INT_ENA_S: u32 = 5;
pub const SPI_IN_ERR_EOF_INT_ENA_V: u32 = 1;
pub const SPI_IN_ERR_EOF_INT_ENA_S: u32 = 4;
pub const SPI_IN_DONE_INT_ENA_V: u32 = 1;
pub const SPI_IN_DONE_INT_ENA_S: u32 = 3;
pub const SPI_INLINK_DSCR_ERROR_INT_ENA_V: u32 = 1;
pub const SPI_INLINK_DSCR_ERROR_INT_ENA_S: u32 = 2;
pub const SPI_OUTLINK_DSCR_ERROR_INT_ENA_V: u32 = 1;
pub const SPI_OUTLINK_DSCR_ERROR_INT_ENA_S: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_ENA_V: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_ENA_S: u32 = 0;
pub const SPI_OUT_TOTAL_EOF_INT_RAW_V: u32 = 1;
pub const SPI_OUT_TOTAL_EOF_INT_RAW_S: u32 = 8;
pub const SPI_OUT_EOF_INT_RAW_V: u32 = 1;
pub const SPI_OUT_EOF_INT_RAW_S: u32 = 7;
pub const SPI_OUT_DONE_INT_RAW_V: u32 = 1;
pub const SPI_OUT_DONE_INT_RAW_S: u32 = 6;
pub const SPI_IN_SUC_EOF_INT_RAW_V: u32 = 1;
pub const SPI_IN_SUC_EOF_INT_RAW_S: u32 = 5;
pub const SPI_IN_ERR_EOF_INT_RAW_V: u32 = 1;
pub const SPI_IN_ERR_EOF_INT_RAW_S: u32 = 4;
pub const SPI_IN_DONE_INT_RAW_V: u32 = 1;
pub const SPI_IN_DONE_INT_RAW_S: u32 = 3;
pub const SPI_INLINK_DSCR_ERROR_INT_RAW_V: u32 = 1;
pub const SPI_INLINK_DSCR_ERROR_INT_RAW_S: u32 = 2;
pub const SPI_OUTLINK_DSCR_ERROR_INT_RAW_V: u32 = 1;
pub const SPI_OUTLINK_DSCR_ERROR_INT_RAW_S: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_RAW_V: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_RAW_S: u32 = 0;
pub const SPI_OUT_TOTAL_EOF_INT_ST_V: u32 = 1;
pub const SPI_OUT_TOTAL_EOF_INT_ST_S: u32 = 8;
pub const SPI_OUT_EOF_INT_ST_V: u32 = 1;
pub const SPI_OUT_EOF_INT_ST_S: u32 = 7;
pub const SPI_OUT_DONE_INT_ST_V: u32 = 1;
pub const SPI_OUT_DONE_INT_ST_S: u32 = 6;
pub const SPI_IN_SUC_EOF_INT_ST_V: u32 = 1;
pub const SPI_IN_SUC_EOF_INT_ST_S: u32 = 5;
pub const SPI_IN_ERR_EOF_INT_ST_V: u32 = 1;
pub const SPI_IN_ERR_EOF_INT_ST_S: u32 = 4;
pub const SPI_IN_DONE_INT_ST_V: u32 = 1;
pub const SPI_IN_DONE_INT_ST_S: u32 = 3;
pub const SPI_INLINK_DSCR_ERROR_INT_ST_V: u32 = 1;
pub const SPI_INLINK_DSCR_ERROR_INT_ST_S: u32 = 2;
pub const SPI_OUTLINK_DSCR_ERROR_INT_ST_V: u32 = 1;
pub const SPI_OUTLINK_DSCR_ERROR_INT_ST_S: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_ST_V: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_ST_S: u32 = 0;
pub const SPI_OUT_TOTAL_EOF_INT_CLR_V: u32 = 1;
pub const SPI_OUT_TOTAL_EOF_INT_CLR_S: u32 = 8;
pub const SPI_OUT_EOF_INT_CLR_V: u32 = 1;
pub const SPI_OUT_EOF_INT_CLR_S: u32 = 7;
pub const SPI_OUT_DONE_INT_CLR_V: u32 = 1;
pub const SPI_OUT_DONE_INT_CLR_S: u32 = 6;
pub const SPI_IN_SUC_EOF_INT_CLR_V: u32 = 1;
pub const SPI_IN_SUC_EOF_INT_CLR_S: u32 = 5;
pub const SPI_IN_ERR_EOF_INT_CLR_V: u32 = 1;
pub const SPI_IN_ERR_EOF_INT_CLR_S: u32 = 4;
pub const SPI_IN_DONE_INT_CLR_V: u32 = 1;
pub const SPI_IN_DONE_INT_CLR_S: u32 = 3;
pub const SPI_INLINK_DSCR_ERROR_INT_CLR_V: u32 = 1;
pub const SPI_INLINK_DSCR_ERROR_INT_CLR_S: u32 = 2;
pub const SPI_OUTLINK_DSCR_ERROR_INT_CLR_V: u32 = 1;
pub const SPI_OUTLINK_DSCR_ERROR_INT_CLR_S: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_CLR_V: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_CLR_S: u32 = 0;
pub const SPI_DMA_IN_ERR_EOF_DES_ADDR: u32 = 4294967295;
pub const SPI_DMA_IN_ERR_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SPI_DMA_IN_ERR_EOF_DES_ADDR_S: u32 = 0;
pub const SPI_DMA_IN_SUC_EOF_DES_ADDR: u32 = 4294967295;
pub const SPI_DMA_IN_SUC_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SPI_DMA_IN_SUC_EOF_DES_ADDR_S: u32 = 0;
pub const SPI_DMA_INLINK_DSCR: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_V: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_S: u32 = 0;
pub const SPI_DMA_INLINK_DSCR_BF0: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_BF0_V: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_BF0_S: u32 = 0;
pub const SPI_DMA_INLINK_DSCR_BF1: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_BF1_V: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_BF1_S: u32 = 0;
pub const SPI_DMA_OUT_EOF_BFR_DES_ADDR: u32 = 4294967295;
pub const SPI_DMA_OUT_EOF_BFR_DES_ADDR_V: u32 = 4294967295;
pub const SPI_DMA_OUT_EOF_BFR_DES_ADDR_S: u32 = 0;
pub const SPI_DMA_OUT_EOF_DES_ADDR: u32 = 4294967295;
pub const SPI_DMA_OUT_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SPI_DMA_OUT_EOF_DES_ADDR_S: u32 = 0;
pub const SPI_DMA_OUTLINK_DSCR: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_V: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_S: u32 = 0;
pub const SPI_DMA_OUTLINK_DSCR_BF0: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_BF0_V: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_BF0_S: u32 = 0;
pub const SPI_DMA_OUTLINK_DSCR_BF1: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_BF1_V: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_BF1_S: u32 = 0;
pub const SPI_DMA_OUT_STATUS: u32 = 4294967295;
pub const SPI_DMA_OUT_STATUS_V: u32 = 4294967295;
pub const SPI_DMA_OUT_STATUS_S: u32 = 0;
pub const SPI_DMA_IN_STATUS: u32 = 4294967295;
pub const SPI_DMA_IN_STATUS_V: u32 = 4294967295;
pub const SPI_DMA_IN_STATUS_S: u32 = 0;
pub const SPI_DATE: u32 = 268435455;
pub const SPI_DATE_V: u32 = 268435455;
pub const SPI_DATE_S: u32 = 0;
pub const SPI_MAX_DMA_LEN: u32 = 4092;
pub const SPICOMMON_BUSFLAG_SLAVE: u32 = 0;
pub const SPICOMMON_BUSFLAG_MASTER: u32 = 1;
pub const SPICOMMON_BUSFLAG_IOMUX_PINS: u32 = 2;
pub const SPICOMMON_BUSFLAG_SCLK: u32 = 4;
pub const SPICOMMON_BUSFLAG_MISO: u32 = 8;
pub const SPICOMMON_BUSFLAG_MOSI: u32 = 16;
pub const SPICOMMON_BUSFLAG_DUAL: u32 = 32;
pub const SPICOMMON_BUSFLAG_WPHD: u32 = 64;
pub const SPICOMMON_BUSFLAG_QUAD: u32 = 96;
pub const SPICOMMON_BUSFLAG_NATIVE_PINS: u32 = 2;
pub const SPI_MASTER_FREQ_8M: u32 = 8000000;
pub const SPI_MASTER_FREQ_9M: u32 = 8888888;
pub const SPI_MASTER_FREQ_10M: u32 = 10000000;
pub const SPI_MASTER_FREQ_11M: u32 = 11428571;
pub const SPI_MASTER_FREQ_13M: u32 = 13333333;
pub const SPI_MASTER_FREQ_16M: u32 = 16000000;
pub const SPI_MASTER_FREQ_20M: u32 = 20000000;
pub const SPI_MASTER_FREQ_26M: u32 = 26666666;
pub const SPI_MASTER_FREQ_40M: u32 = 40000000;
pub const SPI_MASTER_FREQ_80M: u32 = 80000000;
pub const SPI_DEVICE_TXBIT_LSBFIRST: u32 = 1;
pub const SPI_DEVICE_RXBIT_LSBFIRST: u32 = 2;
pub const SPI_DEVICE_BIT_LSBFIRST: u32 = 3;
pub const SPI_DEVICE_3WIRE: u32 = 4;
pub const SPI_DEVICE_POSITIVE_CS: u32 = 8;
pub const SPI_DEVICE_HALFDUPLEX: u32 = 16;
pub const SPI_DEVICE_CLK_AS_CS: u32 = 32;
pub const SPI_DEVICE_NO_DUMMY: u32 = 64;
pub const SPI_TRANS_MODE_DIO: u32 = 1;
pub const SPI_TRANS_MODE_QIO: u32 = 2;
pub const SPI_TRANS_USE_RXDATA: u32 = 4;
pub const SPI_TRANS_USE_TXDATA: u32 = 8;
pub const SPI_TRANS_MODE_DIOQIO_ADDR: u32 = 16;
pub const SPI_TRANS_VARIABLE_CMD: u32 = 32;
pub const SPI_TRANS_VARIABLE_ADDR: u32 = 64;
pub const SPI_TRANS_VARIABLE_DUMMY: u32 = 128;
pub const POLLIN: u32 = 1;
pub const POLLRDNORM: u32 = 2;
pub const POLLRDBAND: u32 = 4;
pub const POLLPRI: u32 = 4;
pub const POLLOUT: u32 = 8;
pub const POLLWRNORM: u32 = 8;
pub const POLLWRBAND: u32 = 16;
pub const POLLERR: u32 = 32;
pub const POLLHUP: u32 = 64;
pub const POLLNVAL: u32 = 128;
pub const PBUF_TRANSPORT_HLEN: u32 = 20;
pub const PBUF_IP_HLEN: u32 = 40;
pub const PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS: u32 = 128;
pub const PBUF_TYPE_FLAG_DATA_VOLATILE: u32 = 64;
pub const PBUF_TYPE_ALLOC_SRC_MASK: u32 = 15;
pub const PBUF_ALLOC_FLAG_RX: u32 = 256;
pub const PBUF_ALLOC_FLAG_DATA_CONTIGUOUS: u32 = 512;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP: u32 = 0;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF: u32 = 1;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL: u32 = 2;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MIN: u32 = 3;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MAX: u32 = 15;
pub const PBUF_FLAG_PUSH: u32 = 1;
pub const PBUF_FLAG_IS_CUSTOM: u32 = 2;
pub const PBUF_FLAG_MCASTLOOP: u32 = 4;
pub const PBUF_FLAG_LLBCAST: u32 = 8;
pub const PBUF_FLAG_LLMCAST: u32 = 16;
pub const PBUF_FLAG_TCP_FIN: u32 = 32;
pub const PBUF_POOL_FREE_OOSEQ: u32 = 1;
pub const MEMP_SIZE: u32 = 0;
pub const NETIF_MAX_HWADDR_LEN: u32 = 6;
pub const NETIF_NAMESIZE: u32 = 6;
pub const NETIF_FLAG_UP: u32 = 1;
pub const NETIF_FLAG_BROADCAST: u32 = 2;
pub const NETIF_FLAG_LINK_UP: u32 = 4;
pub const NETIF_FLAG_ETHARP: u32 = 8;
pub const NETIF_FLAG_ETHERNET: u32 = 16;
pub const NETIF_FLAG_IGMP: u32 = 32;
pub const NETIF_FLAG_MLD6: u32 = 64;
pub const NETIF_FLAG_GARP: u32 = 128;
pub const NETIF_ADDR_IDX_MAX: u32 = 127;
pub const LWIP_NETIF_USE_HINTS: u32 = 0;
pub const NETIF_NO_INDEX: u32 = 0;
pub const LWIP_NSC_NONE: u32 = 0;
pub const LWIP_NSC_NETIF_ADDED: u32 = 1;
pub const LWIP_NSC_NETIF_REMOVED: u32 = 2;
pub const LWIP_NSC_LINK_CHANGED: u32 = 4;
pub const LWIP_NSC_STATUS_CHANGED: u32 = 8;
pub const LWIP_NSC_IPV4_ADDRESS_CHANGED: u32 = 16;
pub const LWIP_NSC_IPV4_GATEWAY_CHANGED: u32 = 32;
pub const LWIP_NSC_IPV4_NETMASK_CHANGED: u32 = 64;
pub const LWIP_NSC_IPV4_SETTINGS_CHANGED: u32 = 128;
pub const LWIP_NSC_IPV6_SET: u32 = 256;
pub const LWIP_NSC_IPV6_ADDR_STATE_CHANGED: u32 = 512;
pub const SIN_ZERO_LEN: u32 = 8;
pub const IOV_MAX: u32 = 65535;
pub const MSG_TRUNC: u32 = 4;
pub const MSG_CTRUNC: u32 = 8;
pub const IFNAMSIZ: u32 = 6;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_BROADCAST: u32 = 32;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_CONTIMEO: u32 = 4105;
pub const SO_NO_CHECK: u32 = 4106;
pub const SO_BINDTODEVICE: u32 = 4107;
pub const SOL_SOCKET: u32 = 4095;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const AF_INET6: u32 = 10;
pub const PF_INET: u32 = 2;
pub const PF_INET6: u32 = 10;
pub const PF_UNSPEC: u32 = 0;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_UDPLITE: u32 = 136;
pub const IPPROTO_RAW: u32 = 255;
pub const MSG_PEEK: u32 = 1;
pub const MSG_WAITALL: u32 = 2;
pub const MSG_OOB: u32 = 4;
pub const MSG_DONTWAIT: u32 = 8;
pub const MSG_MORE: u32 = 16;
pub const MSG_NOSIGNAL: u32 = 32;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_PKTINFO: u32 = 8;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_KEEPALIVE: u32 = 2;
pub const TCP_KEEPIDLE: u32 = 3;
pub const TCP_KEEPINTVL: u32 = 4;
pub const TCP_KEEPCNT: u32 = 5;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_V6ONLY: u32 = 27;
pub const IP_MULTICAST_TTL: u32 = 5;
pub const IP_MULTICAST_IF: u32 = 6;
pub const IP_MULTICAST_LOOP: u32 = 7;
pub const IP_ADD_MEMBERSHIP: u32 = 3;
pub const IP_DROP_MEMBERSHIP: u32 = 4;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_ADD_MEMBERSHIP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_DROP_MEMBERSHIP: u32 = 13;
pub const IPV6_MULTICAST_IF: u32 = 768;
pub const IPV6_MULTICAST_HOPS: u32 = 769;
pub const IPV6_MULTICAST_LOOP: u32 = 770;
pub const IPTOS_TOS_MASK: u32 = 30;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_LOWCOST: u32 = 2;
pub const IPTOS_MINCOST: u32 = 2;
pub const IPTOS_PREC_MASK: u32 = 224;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IOCPARM_MASK: u32 = 127;
pub const IOC_VOID: u32 = 536870912;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const O_NDELAY: u32 = 16384;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const LWIP_SELECT_MAXNFDS: u32 = 64;
pub const LWIP_DNS_API_DECLARE_H_ERRNO: u32 = 1;
pub const LWIP_DNS_API_DEFINE_ERRORS: u32 = 1;
pub const LWIP_DNS_API_DEFINE_FLAGS: u32 = 1;
pub const LWIP_DNS_API_DECLARE_STRUCTS: u32 = 1;
pub const EAI_NONAME: u32 = 200;
pub const EAI_SERVICE: u32 = 201;
pub const EAI_FAIL: u32 = 202;
pub const EAI_MEMORY: u32 = 203;
pub const EAI_FAMILY: u32 = 204;
pub const HOST_NOT_FOUND: u32 = 210;
pub const NO_DATA: u32 = 211;
pub const NO_RECOVERY: u32 = 212;
pub const TRY_AGAIN: u32 = 213;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_NUMERICSERV: u32 = 8;
pub const AI_V4MAPPED: u32 = 16;
pub const AI_ALL: u32 = 32;
pub const AI_ADDRCONFIG: u32 = 64;
pub const SYS_ARCH_TIMEOUT: u32 = 4294967295;
pub const SYS_MBOX_EMPTY: u32 = 4294967295;
pub const PTHREAD_CANCEL_ENABLE: u32 = 0;
pub const PTHREAD_CANCEL_DISABLE: u32 = 1;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 1;
pub type error_t = std::os::raw::c_int;
pub type wchar_t = std::os::raw::c_uchar;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: std::os::raw::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type __int8_t = std::os::raw::c_schar;
pub type __uint8_t = std::os::raw::c_uchar;
pub type __int16_t = std::os::raw::c_short;
pub type __uint16_t = std::os::raw::c_ushort;
pub type __int32_t = std::os::raw::c_int;
pub type __uint32_t = std::os::raw::c_uint;
pub type __int64_t = std::os::raw::c_longlong;
pub type __uint64_t = std::os::raw::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __intptr_t = std::os::raw::c_int;
pub type __uintptr_t = std::os::raw::c_uint;
pub type _lock_t = std::os::raw::c_int;
pub type _LOCK_RECURSIVE_T = _lock_t;
pub type _LOCK_T = _lock_t;
extern "C" {
    pub fn _lock_init(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_init_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_try_acquire(lock: *mut _lock_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_try_acquire_recursive(lock: *mut _lock_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_release(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_release_recursive(lock: *mut _lock_t);
}
pub type _off_t = std::os::raw::c_long;
pub type __dev_t = std::os::raw::c_short;
pub type __uid_t = std::os::raw::c_ushort;
pub type __gid_t = std::os::raw::c_ushort;
pub type _off64_t = std::os::raw::c_longlong;
pub type _fpos_t = std::os::raw::c_long;
pub type _ssize_t = std::os::raw::c_int;
pub type wint_t = std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: std::os::raw::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [std::os::raw::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for _mbstate_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_mbstate_t__bindgen_ty_1 {{ union }}")
    }
}
impl Default for _mbstate_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for _mbstate_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "_mbstate_t {{ __count: {:?}, __value: {:?} }}",
            self.__count, self.__value
        )
    }
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut std::os::raw::c_void;
pub type __ULong = std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: std::os::raw::c_int,
    pub _maxwds: std::os::raw::c_int,
    pub _sign: std::os::raw::c_int,
    pub _wds: std::os::raw::c_int,
    pub _x: [__ULong; 1usize],
}
impl Default for _Bigint {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct __tm {
    pub __tm_sec: std::os::raw::c_int,
    pub __tm_min: std::os::raw::c_int,
    pub __tm_hour: std::os::raw::c_int,
    pub __tm_mday: std::os::raw::c_int,
    pub __tm_mon: std::os::raw::c_int,
    pub __tm_year: std::os::raw::c_int,
    pub __tm_wday: std::os::raw::c_int,
    pub __tm_yday: std::os::raw::c_int,
    pub __tm_isdst: std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _on_exit_args {
    pub _fnargs: [*mut std::os::raw::c_void; 32usize],
    pub _dso_handle: [*mut std::os::raw::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
impl Default for _on_exit_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: std::os::raw::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
impl Default for _atexit {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __sbuf {
    pub _base: *mut std::os::raw::c_uchar,
    pub _size: std::os::raw::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __sFILE_fake {
    pub _p: *mut std::os::raw::c_uchar,
    pub _r: std::os::raw::c_int,
    pub _w: std::os::raw::c_int,
    pub _flags: std::os::raw::c_short,
    pub _file: std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: std::os::raw::c_int,
    pub _data: *mut _reent,
}
impl Default for __sFILE_fake {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __sinit(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut std::os::raw::c_uchar,
    pub _r: std::os::raw::c_int,
    pub _w: std::os::raw::c_int,
    pub _flags: std::os::raw::c_short,
    pub _file: std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: std::os::raw::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut std::os::raw::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut std::os::raw::c_void,
            arg3: *mut std::os::raw::c_char,
            arg4: std::os::raw::c_int,
        ) -> std::os::raw::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut std::os::raw::c_void,
            arg3: *const std::os::raw::c_char,
            arg4: std::os::raw::c_int,
        ) -> std::os::raw::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut std::os::raw::c_void,
            arg3: _fpos_t,
            arg4: std::os::raw::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut std::os::raw::c_void,
        ) -> std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut std::os::raw::c_uchar,
    pub _ur: std::os::raw::c_int,
    pub _ubuf: [std::os::raw::c_uchar; 3usize],
    pub _nbuf: [std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: std::os::raw::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: std::os::raw::c_int,
}
impl Default for __sFILE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for __sFILE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "__sFILE {{ _p: {:?}, _r: {:?}, _w: {:?}, _flags: {:?}, _file: {:?}, _bf: {:?}, _lbfsize: {:?}, _data: {:?}, _cookie: {:?}, _read: {:?}, _write: {:?}, _seek: {:?}, _close: {:?}, _ub: {:?}, _up: {:?}, _ur: {:?}, _ubuf: {:?}, _nbuf: {:?}, _lb: {:?}, _blksize: {:?}, _offset: {:?}, _lock: {:?}, _mbstate: {:?}, _flags2: {:?} }}" , self . _p , self . _r , self . _w , self . _flags , self . _file , self . _bf , self . _lbfsize , self . _data , self . _cookie , self . _read , self . _write , self . _seek , self . _close , self . _ub , self . _up , self . _ur , self . _ubuf , self . _nbuf , self . _lb , self . _blksize , self . _offset , self . _lock , self . _mbstate , self . _flags2 )
    }
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: std::os::raw::c_int,
    pub _iobs: *mut __FILE,
}
impl Default for _glue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _rand48 {
    pub _seed: [std::os::raw::c_ushort; 3usize],
    pub _mult: [std::os::raw::c_ushort; 3usize],
    pub _add: std::os::raw::c_ushort,
    pub _rand_next: std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: std::os::raw::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
impl Default for _mprec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut std::os::raw::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [std::os::raw::c_char; 8usize],
    pub _getdate_err: std::os::raw::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
impl Default for _misc_reent {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for _misc_reent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "_misc_reent {{ _strtok_last: {:?}, _mblen_state: {:?}, _wctomb_state: {:?}, _mbtowc_state: {:?}, _l64a_buf: {:?}, _getdate_err: {:?}, _mbrlen_state: {:?}, _mbrtowc_state: {:?}, _mbsrtowcs_state: {:?}, _wcrtomb_state: {:?}, _wcsrtombs_state: {:?} }}" , self . _strtok_last , self . _mblen_state , self . _wctomb_state , self . _mbtowc_state , self . _l64a_buf , self . _getdate_err , self . _mbrlen_state , self . _mbrtowc_state , self . _mbsrtowcs_state , self . _wcrtomb_state , self . _wcsrtombs_state )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _reent {
    pub _errno: std::os::raw::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: std::os::raw::c_int,
    pub _emergency: *mut std::os::raw::c_char,
    pub __sdidinit: std::os::raw::c_int,
    pub _current_category: std::os::raw::c_int,
    pub _current_locale: *const std::os::raw::c_char,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: std::os::raw::c_int,
    pub _cvtlen: std::os::raw::c_int,
    pub _cvtbuf: *mut std::os::raw::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut std::os::raw::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: std::os::raw::c_int)>,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub __sglue: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut std::os::raw::c_char,
}
impl Default for _reent {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static __sf_fake_stdin: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stdout: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stderr: __sFILE_fake;
}
extern "C" {
    pub static mut _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
extern "C" {
    pub fn __errno() -> *mut std::os::raw::c_int;
}
extern "C" {
    pub static mut _sys_errlist: [*const std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut _sys_nerr: std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __dmath {
    pub d: f64,
    pub i: [__ULong; 2usize],
    _bindgen_union_align: [u32; 2usize],
}
impl Default for __dmath {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for __dmath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "__dmath {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __fmath {
    pub f: f32,
    pub i: [__ULong; 1usize],
    _bindgen_union_align: u32,
}
impl Default for __fmath {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for __fmath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "__fmath {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __ldmath {
    pub ld: f64,
    pub i: [__ULong; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for __ldmath {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for __ldmath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "__ldmath {{ union }}")
    }
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __isinff(x: f32) -> std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfd(x: f64) -> std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(x: f32) -> std::os::raw::c_int;
}
extern "C" {
    pub fn __isnand(x: f64) -> std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyf(x: f32) -> std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyd(x: f64) -> std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(x: f32) -> std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitd(x: f64) -> std::os::raw::c_int;
}
extern "C" {
    pub fn infinity() -> f64;
}
extern "C" {
    pub fn nan(arg1: *const std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn finite(arg1: f64) -> std::os::raw::c_int;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> std::os::raw::c_int;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrint(arg1: f64) -> std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(arg1: f64) -> std::os::raw::c_longlong;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn lround(arg1: f64) -> std::os::raw::c_long;
}
extern "C" {
    pub fn llround(arg1: f64) -> std::os::raw::c_longlong;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> std::os::raw::c_longlong;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> std::os::raw::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn infinityf() -> f32;
}
extern "C" {
    pub fn nanf(arg1: *const std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn finitef(arg1: f32) -> std::os::raw::c_int;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> std::os::raw::c_int;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> std::os::raw::c_int;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> std::os::raw::c_longlong;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> std::os::raw::c_longlong;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sincos(arg1: f64, arg2: *mut f64, arg3: *mut f64);
}
extern "C" {
    pub fn gamma_r(arg1: f64, arg2: *mut std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn sincosf(arg1: f32, arg2: *mut f32, arg3: *mut f32);
}
extern "C" {
    pub fn gammaf_r(arg1: f32, arg2: *mut std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn pow10(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn pow10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __signgam() -> *mut std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct exception {
    pub type_: std::os::raw::c_int,
    pub name: *mut std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
    pub err: std::os::raw::c_int,
}
impl Default for exception {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn matherr(e: *mut exception) -> std::os::raw::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __fdlibm_version {
    __fdlibm_ieee = -1,
    __fdlibm_svid = 0,
    __fdlibm_xopen = 1,
    __fdlibm_posix = 2,
}
extern "C" {
    pub static mut __fdlib_version: __fdlibm_version;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct div_t {
    pub quot: std::os::raw::c_int,
    pub rem: std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: std::os::raw::c_long,
    pub rem: std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: std::os::raw::c_longlong,
    pub rem: std::os::raw::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const std::os::raw::c_void,
        arg2: *const std::os::raw::c_void,
    ) -> std::os::raw::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> std::os::raw::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const std::os::raw::c_char) -> std::os::raw::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const std::os::raw::c_char) -> std::os::raw::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const std::os::raw::c_void,
        __base: *const std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: std::os::raw::c_uint,
        __size: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn div(__numer: std::os::raw::c_int, __denom: std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn getenv(__string: *const std::os::raw::c_char) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const std::os::raw::c_char,
        arg2: *mut std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: *mut std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut std::os::raw::c_char,
        arg2: *const *mut std::os::raw::c_char,
        arg3: *mut *mut std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn labs(arg1: std::os::raw::c_long) -> std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(__numer: std::os::raw::c_long, __denom: std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(__size: std::os::raw::c_uint) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const std::os::raw::c_char, arg2: usize) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const std::os::raw::c_char,
        arg3: usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const std::os::raw::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut std::os::raw::c_char, arg2: wchar_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const std::os::raw::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut std::os::raw::c_char) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp(
        arg1: *mut std::os::raw::c_char,
        arg2: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        arg1: *mut std::os::raw::c_char,
        arg2: std::os::raw::c_int,
        arg3: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp(arg1: *mut std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut std::os::raw::c_char,
        arg2: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut std::os::raw::c_char) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
        arg4: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _mktemp_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(
        __r: *mut std::os::raw::c_void,
        __size: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn reallocf(__r: *mut std::os::raw::c_void, __size: usize) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const std::os::raw::c_char,
        resolved_path: *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn srand(__seed: std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        __n: *const std::os::raw::c_char,
        __end_PTR: *mut *mut std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const std::os::raw::c_char,
        __end_PTR: *mut *mut std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __n: *const std::os::raw::c_char,
        __end_PTR: *mut *mut std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const std::os::raw::c_char,
        __end_PTR: *mut *mut std::os::raw::c_char,
        __base: std::os::raw::c_int,
    ) -> std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const std::os::raw::c_char,
        __end_PTR: *mut *mut std::os::raw::c_char,
        __base: std::os::raw::c_int,
    ) -> std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const std::os::raw::c_char,
        __end_PTR: *mut *mut std::os::raw::c_char,
        __base: std::os::raw::c_int,
    ) -> std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const std::os::raw::c_char,
        __end_PTR: *mut *mut std::os::raw::c_char,
        __base: std::os::raw::c_int,
    ) -> std::os::raw::c_ulong;
}
extern "C" {
    pub fn system(__string: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn a64l(__input: *const std::os::raw::c_char) -> std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(__input: std::os::raw::c_long) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: std::os::raw::c_long) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: std::os::raw::c_int, arg2: *mut std::os::raw::c_void),
        >,
        __arg: *mut std::os::raw::c_void,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(__status: std::os::raw::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut std::os::raw::c_char)
        -> std::os::raw::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_void,
        arg3: usize,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const std::os::raw::c_char,
        __value: *const std::os::raw::c_char,
        __overwrite: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const std::os::raw::c_char,
        __value: *const std::os::raw::c_char,
        __overwrite: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: std::os::raw::c_int,
        arg3: *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn gcvtf(
        arg1: f32,
        arg2: std::os::raw::c_int,
        arg3: *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: std::os::raw::c_int,
        arg3: *mut std::os::raw::c_int,
        arg4: *mut std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn fcvtf(
        arg1: f32,
        arg2: std::os::raw::c_int,
        arg3: *mut std::os::raw::c_int,
        arg4: *mut std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: std::os::raw::c_int,
        arg3: *mut std::os::raw::c_int,
        arg4: *mut std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn ecvtbuf(
        arg1: f64,
        arg2: std::os::raw::c_int,
        arg3: *mut std::os::raw::c_int,
        arg4: *mut std::os::raw::c_int,
        arg5: *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn fcvtbuf(
        arg1: f64,
        arg2: std::os::raw::c_int,
        arg3: *mut std::os::raw::c_int,
        arg4: *mut std::os::raw::c_int,
        arg5: *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn ecvtf(
        arg1: f32,
        arg2: std::os::raw::c_int,
        arg3: *mut std::os::raw::c_int,
        arg4: *mut std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn dtoa(
        arg1: f64,
        arg2: std::os::raw::c_int,
        arg3: std::os::raw::c_int,
        arg4: *mut std::os::raw::c_int,
        arg5: *mut std::os::raw::c_int,
        arg6: *mut *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn __itoa(
        arg1: std::os::raw::c_int,
        arg2: *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: std::os::raw::c_uint,
        arg2: *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: std::os::raw::c_int,
        arg2: *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: std::os::raw::c_uint,
        arg2: *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut std::os::raw::c_uint) -> std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut [std::os::raw::c_ushort; 3usize]) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut [std::os::raw::c_ushort; 3usize]) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut [std::os::raw::c_ushort; 3usize]) -> std::os::raw::c_long;
}
extern "C" {
    pub fn _jrand48_r(
        arg1: *mut _reent,
        arg2: *mut [std::os::raw::c_ushort; 3usize],
    ) -> std::os::raw::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut [std::os::raw::c_ushort; 7usize]);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut [std::os::raw::c_ushort; 7usize]);
}
extern "C" {
    pub fn lrand48() -> std::os::raw::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> std::os::raw::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut [std::os::raw::c_ushort; 3usize]) -> std::os::raw::c_long;
}
extern "C" {
    pub fn _nrand48_r(
        arg1: *mut _reent,
        arg2: *mut [std::os::raw::c_ushort; 3usize],
    ) -> std::os::raw::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut [std::os::raw::c_ushort; 3usize]) -> *mut std::os::raw::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut [std::os::raw::c_ushort; 3usize],
    ) -> *mut std::os::raw::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: std::os::raw::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: std::os::raw::c_long);
}
extern "C" {
    pub fn atoll(__nptr: *const std::os::raw::c_char) -> std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const std::os::raw::c_char,
    ) -> std::os::raw::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: std::os::raw::c_longlong) -> std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: std::os::raw::c_longlong, __denom: std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const std::os::raw::c_char,
        __end_PTR: *mut *mut std::os::raw::c_char,
        __base: std::os::raw::c_int,
    ) -> std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const std::os::raw::c_char,
        __end_PTR: *mut *mut std::os::raw::c_char,
        __base: std::os::raw::c_int,
    ) -> std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const std::os::raw::c_char,
        __end_PTR: *mut *mut std::os::raw::c_char,
        __base: std::os::raw::c_int,
    ) -> std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const std::os::raw::c_char,
        __end_PTR: *mut *mut std::os::raw::c_char,
        __base: std::os::raw::c_int,
    ) -> std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: std::os::raw::c_int,
        arg4: std::os::raw::c_int,
        arg5: *mut std::os::raw::c_int,
        arg6: *mut std::os::raw::c_int,
        arg7: *mut *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_void,
        arg3: usize,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut std::os::raw::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_uint,
        arg4: *const std::os::raw::c_char,
    );
}
extern "C" {
    pub fn strtold(arg1: *const std::os::raw::c_char, arg2: *mut *mut std::os::raw::c_char) -> f64;
}
pub type __off_t = std::os::raw::c_long;
pub type __pid_t = std::os::raw::c_int;
pub type __loff_t = std::os::raw::c_longlong;
pub type u_char = std::os::raw::c_uchar;
pub type u_short = std::os::raw::c_ushort;
pub type u_int = std::os::raw::c_uint;
pub type u_long = std::os::raw::c_ulong;
pub type ushort = std::os::raw::c_ushort;
pub type uint = std::os::raw::c_uint;
pub type ulong = std::os::raw::c_ulong;
pub type clock_t = std::os::raw::c_ulong;
pub type time_t = std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type daddr_t = std::os::raw::c_long;
pub type caddr_t = *mut std::os::raw::c_char;
pub type ino_t = std::os::raw::c_ushort;
pub type off_t = _off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = std::os::raw::c_int;
pub type key_t = std::os::raw::c_long;
pub type mode_t = std::os::raw::c_uint;
pub type nlink_t = std::os::raw::c_ushort;
pub type fd_mask = std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
pub type clockid_t = std::os::raw::c_ulong;
pub type timer_t = std::os::raw::c_ulong;
pub type useconds_t = std::os::raw::c_ulong;
pub type suseconds_t = std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sched_param {
    pub sched_priority: std::os::raw::c_int,
}
extern "C" {
    pub fn sched_yield() -> std::os::raw::c_int;
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct pthread_attr_t {
    pub is_initialized: std::os::raw::c_int,
    pub stackaddr: *mut std::os::raw::c_void,
    pub stacksize: std::os::raw::c_int,
    pub contentionscope: std::os::raw::c_int,
    pub inheritsched: std::os::raw::c_int,
    pub schedpolicy: std::os::raw::c_int,
    pub schedparam: sched_param,
    pub detachstate: std::os::raw::c_int,
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct pthread_mutexattr_t {
    pub is_initialized: std::os::raw::c_int,
    pub type_: std::os::raw::c_int,
    pub recursive: std::os::raw::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct pthread_condattr_t {
    pub is_initialized: std::os::raw::c_int,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct pthread_once_t {
    pub is_initialized: std::os::raw::c_int,
    pub init_executed: std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct tm {
    pub tm_sec: std::os::raw::c_int,
    pub tm_min: std::os::raw::c_int,
    pub tm_hour: std::os::raw::c_int,
    pub tm_mday: std::os::raw::c_int,
    pub tm_mon: std::os::raw::c_int,
    pub tm_year: std::os::raw::c_int,
    pub tm_wday: std::os::raw::c_int,
    pub tm_yday: std::os::raw::c_int,
    pub tm_isdst: std::os::raw::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut std::os::raw::c_char,
        _maxsize: usize,
        _fmt: *const std::os::raw::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut std::os::raw::c_char)
        -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn strptime(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct __tzrule_struct {
    pub ch: std::os::raw::c_char,
    pub m: std::os::raw::c_int,
    pub n: std::os::raw::c_int,
    pub d: std::os::raw::c_int,
    pub s: std::os::raw::c_int,
    pub change: time_t,
    pub offset: std::os::raw::c_long,
}
pub type __tzrule_type = __tzrule_struct;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct __tzinfo_struct {
    pub __tznorth: std::os::raw::c_int,
    pub __tzyear: std::os::raw::c_int,
    pub __tzrule: [__tzrule_type; 2usize],
}
pub type __tzinfo_type = __tzinfo_struct;
extern "C" {
    pub fn __gettzinfo() -> *mut __tzinfo_type;
}
extern "C" {
    pub static mut _timezone: std::os::raw::c_long;
}
extern "C" {
    pub static mut _daylight: std::os::raw::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut environ: *mut *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _exit(__status: std::os::raw::c_int);
}
extern "C" {
    pub fn access(
        __path: *const std::os::raw::c_char,
        __amode: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__secs: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn chdir(__path: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn chmod(__path: *const std::os::raw::c_char, __mode: mode_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __path: *const std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn close(__fildes: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut std::os::raw::c_char) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut std::os::raw::c_char) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fildes: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(
        __fildes: std::os::raw::c_int,
        __fildes2: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const std::os::raw::c_char,
        arg1: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const std::os::raw::c_char,
        arg1: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const std::os::raw::c_char,
        arg1: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const std::os::raw::c_char,
        __argv: *const [*mut std::os::raw::c_char; 0usize],
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        __path: *const std::os::raw::c_char,
        __argv: *const [*mut std::os::raw::c_char; 0usize],
        __envp: *const [*mut std::os::raw::c_char; 0usize],
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const std::os::raw::c_char,
        __argv: *const [*mut std::os::raw::c_char; 0usize],
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __dirfd: std::os::raw::c_int,
        __path: *const std::os::raw::c_char,
        __mode: std::os::raw::c_int,
        __flags: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(__fildes: std::os::raw::c_int, __mode: mode_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fildes: std::os::raw::c_int,
        __owner: uid_t,
        __group: gid_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __dirfd: std::os::raw::c_int,
        __path: *const std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
        __flags: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(
        __fd: std::os::raw::c_int,
        __name: std::os::raw::c_int,
    ) -> std::os::raw::c_long;
}
extern "C" {
    pub fn fsync(__fd: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fd: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut std::os::raw::c_char, __size: usize) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(
        __gidsetsize: std::os::raw::c_int,
        __grouplist: *mut [gid_t; 0usize],
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn getpass(__prompt: *const std::os::raw::c_char) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn getpagesize() -> std::os::raw::c_int;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn isatty(__fildes: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __path: *const std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __path1: *const std::os::raw::c_char,
        __path2: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __dirfd1: std::os::raw::c_int,
        __path1: *const std::os::raw::c_char,
        __dirfd2: std::os::raw::c_int,
        __path2: *const std::os::raw::c_char,
        __flags: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__nice_value: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fildes: std::os::raw::c_int,
        __offset: off_t,
        __whence: std::os::raw::c_int,
    ) -> off_t;
}
extern "C" {
    pub fn pathconf(
        __path: *const std::os::raw::c_char,
        __name: std::os::raw::c_int,
    ) -> std::os::raw::c_long;
}
extern "C" {
    pub fn pause() -> std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(__fildes: *mut [std::os::raw::c_int; 2usize]) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pread(
        __fd: std::os::raw::c_int,
        __buf: *mut std::os::raw::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: std::os::raw::c_int,
        __buf: *const std::os::raw::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn read(
        __fd: std::os::raw::c_int,
        __buf: *mut std::os::raw::c_void,
        __nbyte: usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__incr: isize) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn setgid(__gid: gid_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(arg1: *const std::os::raw::c_char, arg2: usize) -> std::os::raw::c_int;
}
extern "C" {
    pub fn setpgid(__pid: pid_t, __pgid: pid_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(__uid: uid_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn sleep(__seconds: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn swab(arg1: *const std::os::raw::c_void, arg2: *mut std::os::raw::c_void, arg3: isize);
}
extern "C" {
    pub fn sysconf(__name: std::os::raw::c_int) -> std::os::raw::c_long;
}
extern "C" {
    pub fn tcgetpgrp(__fildes: std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fildes: std::os::raw::c_int, __pgrp_id: pid_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fildes: std::os::raw::c_int) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn unlink(__path: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn usleep(__useconds: useconds_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> std::os::raw::c_int;
}
extern "C" {
    pub fn write(
        __fd: std::os::raw::c_int,
        __buf: *const std::os::raw::c_void,
        __nbyte: usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        arg1: std::os::raw::c_int,
        arg2: *const [*mut std::os::raw::c_char; 0usize],
        arg3: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub static mut optreset: std::os::raw::c_int;
}
extern "C" {
    pub fn vfork() -> std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const std::os::raw::c_char,
        __buf: *mut std::os::raw::c_char,
        __buflen: usize,
    ) -> isize;
}
extern "C" {
    pub fn readlinkat(
        __dirfd1: std::os::raw::c_int,
        __path: *const std::os::raw::c_char,
        __buf: *mut std::os::raw::c_char,
        __buflen: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlink(
        __name1: *const std::os::raw::c_char,
        __name2: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const std::os::raw::c_char,
        arg2: std::os::raw::c_int,
        arg3: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct timezone {
    pub tz_minuteswest: std::os::raw::c_int,
    pub tz_dsttime: std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut std::os::raw::c_void) -> std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __path: *const std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(__which: std::os::raw::c_int, __value: *mut itimerval) -> std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: std::os::raw::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct flock {
    pub l_type: std::os::raw::c_short,
    pub l_whence: std::os::raw::c_short,
    pub l_start: std::os::raw::c_long,
    pub l_len: std::os::raw::c_long,
    pub l_pid: std::os::raw::c_short,
    pub l_xxx: std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct eflock {
    pub l_type: std::os::raw::c_short,
    pub l_whence: std::os::raw::c_short,
    pub l_start: std::os::raw::c_long,
    pub l_len: std::os::raw::c_long,
    pub l_pid: std::os::raw::c_short,
    pub l_xxx: std::os::raw::c_short,
    pub l_rpid: std::os::raw::c_long,
    pub l_rsys: std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_size: off_t,
    pub st_atime: time_t,
    pub st_spare1: std::os::raw::c_long,
    pub st_mtime: time_t,
    pub st_spare2: std::os::raw::c_long,
    pub st_ctime: time_t,
    pub st_spare3: std::os::raw::c_long,
    pub st_blksize: std::os::raw::c_long,
    pub st_blocks: std::os::raw::c_long,
    pub st_spare4: [std::os::raw::c_long; 2usize],
}
extern "C" {
    pub fn fstat(__fd: std::os::raw::c_int, __sbuf: *mut stat) -> std::os::raw::c_int;
}
extern "C" {
    pub fn mkdir(_path: *const std::os::raw::c_char, __mode: mode_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const std::os::raw::c_char, __mode: mode_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn stat(__path: *const std::os::raw::c_char, __sbuf: *mut stat) -> std::os::raw::c_int;
}
extern "C" {
    pub fn umask(__mask: mode_t) -> mode_t;
}
extern "C" {
    pub fn fchmodat(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        arg3: mode_t,
        arg4: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        arg3: *mut stat,
        arg4: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        arg3: mode_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        arg3: mode_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        arg3: mode_t,
        arg4: dev_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        arg3: *const timespec,
        arg4: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(arg1: std::os::raw::c_int, arg2: *const timespec) -> std::os::raw::c_int;
}
extern "C" {
    pub fn open(
        arg1: *const std::os::raw::c_char,
        arg2: std::os::raw::c_int,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_int,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn creat(arg1: *const std::os::raw::c_char, arg2: mode_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fcntl(arg1: std::os::raw::c_int, arg2: std::os::raw::c_int, ...) -> std::os::raw::c_int;
}
extern "C" {
    pub fn flock(arg1: std::os::raw::c_int, arg2: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ioctl(fd: std::os::raw::c_int, request: std::os::raw::c_int, ...)
        -> std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        nfds: std::os::raw::c_int,
        readfds: *mut _types_fd_set,
        writefds: *mut _types_fd_set,
        errorfds: *mut _types_fd_set,
        timeout: *mut timeval,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xt_clock_freq() -> std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_rev_no: std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_save_extra(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_restore_extra(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_save_cpregs(base: *mut std::os::raw::c_void, arg1: std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_restore_cpregs(base: *mut std::os::raw::c_void, arg1: std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_save_cp0(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_save_cp1(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_save_cp2(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_save_cp3(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_save_cp4(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_save_cp5(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_save_cp6(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_save_cp7(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_restore_cp0(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_restore_cp1(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_restore_cp2(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_restore_cp3(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_restore_cp4(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_restore_cp5(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_restore_cp6(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_restore_cp7(base: *mut std::os::raw::c_void);
}
extern "C" {
    pub static mut Xthal_cpregs_save_fn: [*mut std::os::raw::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_fn: [*mut std::os::raw::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_save_nw_fn: [*mut std::os::raw::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_nw_fn: [*mut std::os::raw::c_void; 8usize];
}
extern "C" {
    pub static Xthal_extra_size: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_extra_align: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cpregs_size: [std::os::raw::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_cpregs_align: [std::os::raw::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_all_extra_size: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_all_extra_align: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_names: [*const std::os::raw::c_char; 8usize];
}
extern "C" {
    pub fn xthal_init_mem_extra(arg1: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_init_mem_cp(arg1: *mut std::os::raw::c_void, arg2: std::os::raw::c_int);
}
extern "C" {
    pub static Xthal_num_coprocessors: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_num: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_max: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs_log2: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linewidth: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_linewidth: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linesize: std::os::raw::c_ushort;
}
extern "C" {
    pub static Xthal_dcache_linesize: std::os::raw::c_ushort;
}
extern "C" {
    pub static Xthal_icache_size: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_dcache_size: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_dcache_is_writeback: std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_icache_region_invalidate(
        addr: *mut std::os::raw::c_void,
        size: std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_dcache_region_invalidate(
        addr: *mut std::os::raw::c_void,
        size: std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_icache_line_invalidate(addr: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_invalidate(addr: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_dcache_region_writeback(
        addr: *mut std::os::raw::c_void,
        size: std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_dcache_line_writeback(addr: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_dcache_region_writeback_inv(
        addr: *mut std::os::raw::c_void,
        size: std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_dcache_line_writeback_inv(addr: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_icache_sync();
}
extern "C" {
    pub fn xthal_dcache_sync();
}
extern "C" {
    pub fn xthal_icache_get_ways() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_icache_set_ways(ways: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_dcache_get_ways() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_dcache_set_ways(ways: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_cache_coherence_on();
}
extern "C" {
    pub fn xthal_cache_coherence_off();
}
extern "C" {
    pub fn xthal_cache_coherence_optin();
}
extern "C" {
    pub fn xthal_cache_coherence_optout();
}
extern "C" {
    pub fn xthal_get_cache_prefetch() -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_cache_prefetch(arg1: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_cache_prefetch_long(arg1: std::os::raw::c_ulonglong) -> std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_debug_configured: std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_soft_break(addr: *mut std::os::raw::c_void) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_remove_soft_break(addr: *mut std::os::raw::c_void, arg1: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_disassemble(
        instr_buf: *mut std::os::raw::c_uchar,
        tgt_addr: *mut std::os::raw::c_void,
        buffer: *mut std::os::raw::c_char,
        buflen: std::os::raw::c_uint,
        options: std::os::raw::c_uint,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_disassemble_size(instr_buf: *mut std::os::raw::c_uchar) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_memcpy(
        dst: *mut std::os::raw::c_void,
        src: *const std::os::raw::c_void,
        len: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn xthal_bcopy(
        src: *const std::os::raw::c_void,
        dst: *mut std::os::raw::c_void,
        len: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn xthal_compare_and_set(
        addr: *mut std::os::raw::c_int,
        test_val: std::os::raw::c_int,
        compare_val: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_release_major: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_release_minor: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_release_name: *const std::os::raw::c_char;
}
extern "C" {
    pub static Xthal_release_internal: *const std::os::raw::c_char;
}
extern "C" {
    pub static Xthal_memory_order: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_windowed: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_density: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_booleans: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_loops: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_nsa: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_minmax: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_sext: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_clamps: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_mac16: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_mul16: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_fp: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_speculation: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_threadptr: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_pif: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_writebuffer_entries: std::os::raw::c_ushort;
}
extern "C" {
    pub static Xthal_build_unique_id: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid0: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid1: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_major: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_minor: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_name: *const std::os::raw::c_char;
}
extern "C" {
    pub static Xthal_hw_release_internal: *const std::os::raw::c_char;
}
extern "C" {
    pub fn xthal_clear_regcached_code();
}
extern "C" {
    pub fn xthal_window_spill();
}
extern "C" {
    pub fn xthal_validate_cp(arg1: std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_invalidate_cp(arg1: std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_set_cpenable(arg1: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_cpenable() -> std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_num_intlevels: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_interrupts: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_excm_level: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_intlevel_mask: [std::os::raw::c_uint; 16usize];
}
extern "C" {
    pub static Xthal_intlevel_andbelow_mask: [std::os::raw::c_uint; 16usize];
}
extern "C" {
    pub static Xthal_intlevel: [std::os::raw::c_uchar; 32usize];
}
extern "C" {
    pub static Xthal_inttype: [std::os::raw::c_uchar; 32usize];
}
extern "C" {
    pub static Xthal_inttype_mask: [std::os::raw::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_timer_interrupt: [std::os::raw::c_int; 4usize];
}
extern "C" {
    pub fn xthal_get_intenable() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_intenable(arg1: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_interrupt() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_intset(arg1: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_intclear(arg1: std::os::raw::c_uint);
}
extern "C" {
    pub static Xthal_num_ibreak: std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_num_dbreak: std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_have_ccount: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_ccompare: std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_get_ccount() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_ccompare(arg1: std::os::raw::c_int, arg2: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_ccompare(arg1: std::os::raw::c_int) -> std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_have_prid: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_exceptions: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_xea_version: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_interrupts: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_highlevel_interrupts: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_nmi: std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_get_prid() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_vpri_to_intlevel(vpri: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_intlevel_to_vpri(intlevel: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_int_enable(arg1: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_int_disable(arg1: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_int_vpri(
        intnum: std::os::raw::c_int,
        vpri: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_get_int_vpri(intnum: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_vpri_locklevel(intlevel: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_vpri_locklevel() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri(vpri: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_get_vpri() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_intlevel(intlevel: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_lock() -> std::os::raw::c_uint;
}
pub type XtHalVoidFunc = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut Xthal_tram_pending: std::os::raw::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_enabled: std::os::raw::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_sync: std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_tram_pending_to_service() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_tram_done(serviced_mask: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_tram_set_sync(
        intnum: std::os::raw::c_int,
        sync: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_tram_trigger_func(trigger_fn: XtHalVoidFunc) -> XtHalVoidFunc;
}
extern "C" {
    pub static Xthal_num_instrom: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_instram: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_datarom: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_dataram: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_xlmi: std::os::raw::c_uchar;
}
extern "C" {
    pub static mut Xthal_instrom_vaddr: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_paddr: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_size: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_vaddr: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_paddr: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_size: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_vaddr: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_paddr: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_size: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_vaddr: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_paddr: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_size: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_vaddr: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_paddr: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_size: [std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static Xthal_icache_setwidth: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_setwidth: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_icache_ways: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_dcache_ways: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_icache_line_lockable: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_line_lockable: std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_get_cacheattr() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_get_icacheattr() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_get_dcacheattr() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_cacheattr(arg1: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_icacheattr(arg1: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_dcacheattr(arg1: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_region_attribute(
        addr: *mut std::os::raw::c_void,
        size: std::os::raw::c_uint,
        cattr: std::os::raw::c_uint,
        flags: std::os::raw::c_uint,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_icache_enable();
}
extern "C" {
    pub fn xthal_dcache_enable();
}
extern "C" {
    pub fn xthal_icache_disable();
}
extern "C" {
    pub fn xthal_dcache_disable();
}
extern "C" {
    pub fn xthal_icache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_writeback();
}
extern "C" {
    pub fn xthal_dcache_all_writeback_inv();
}
extern "C" {
    pub fn xthal_icache_region_lock(addr: *mut std::os::raw::c_void, size: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_lock(addr: *mut std::os::raw::c_void, size: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_lock(addr: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_lock(addr: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_icache_all_unlock();
}
extern "C" {
    pub fn xthal_dcache_all_unlock();
}
extern "C" {
    pub fn xthal_icache_region_unlock(addr: *mut std::os::raw::c_void, size: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_unlock(addr: *mut std::os::raw::c_void, size: std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_unlock(addr: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_unlock(addr: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xthal_memep_inject_error(
        addr: *mut std::os::raw::c_void,
        size: std::os::raw::c_int,
        flags: std::os::raw::c_int,
    );
}
extern "C" {
    pub static Xthal_have_spanning_way: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_identity_map: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_mimic_cacheattr: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_xlt_cacheattr: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_cacheattr: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_tlbs: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_bits: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_kernel: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_rings: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ring_bits: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_sr_bits: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ca_bits: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_max_pte_page_size: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_mmu_min_pte_page_size: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_itlb_way_bits: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_ways: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_arf_ways: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_way_bits: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_ways: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_arf_ways: std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_static_v2p(
        vaddr: std::os::raw::c_uint,
        paddrp: *mut std::os::raw::c_uint,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_static_p2v(
        paddr: std::os::raw::c_uint,
        vaddrp: *mut std::os::raw::c_uint,
        cached: std::os::raw::c_uint,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_region_translation(
        vaddr: *mut std::os::raw::c_void,
        paddr: *mut std::os::raw::c_void,
        size: std::os::raw::c_uint,
        cache_atr: std::os::raw::c_uint,
        flags: std::os::raw::c_uint,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_v2p(
        arg1: *mut std::os::raw::c_void,
        arg2: *mut *mut std::os::raw::c_void,
        arg3: *mut std::os::raw::c_uint,
        arg4: *mut std::os::raw::c_uint,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_invalidate_region(addr: *mut std::os::raw::c_void) -> std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_region_translation_raw(
        vaddr: *mut std::os::raw::c_void,
        paddr: *mut std::os::raw::c_void,
        cattr: std::os::raw::c_uint,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_cp_id_FPU: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_FPU: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP1_IDENT: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP1_IDENT: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP2_IDENT: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP2_IDENT: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP3_IDENT: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP3_IDENT: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP4_IDENT: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP4_IDENT: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP5_IDENT: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP5_IDENT: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP6_IDENT: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP6_IDENT: std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP7_IDENT: std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP7_IDENT: std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct KernelFrame {
    pub pc: std::os::raw::c_long,
    pub ps: std::os::raw::c_long,
    pub areg: [std::os::raw::c_long; 4usize],
    pub sar: std::os::raw::c_long,
    pub lcount: std::os::raw::c_long,
    pub lbeg: std::os::raw::c_long,
    pub lend: std::os::raw::c_long,
    pub acclo: std::os::raw::c_long,
    pub acchi: std::os::raw::c_long,
    pub mr: [std::os::raw::c_long; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct UserFrame {
    pub pc: std::os::raw::c_long,
    pub ps: std::os::raw::c_long,
    pub sar: std::os::raw::c_long,
    pub vpri: std::os::raw::c_long,
    pub a2: std::os::raw::c_long,
    pub a3: std::os::raw::c_long,
    pub a4: std::os::raw::c_long,
    pub a5: std::os::raw::c_long,
    pub exccause: std::os::raw::c_long,
    pub lcount: std::os::raw::c_long,
    pub lbeg: std::os::raw::c_long,
    pub lend: std::os::raw::c_long,
    pub acclo: std::os::raw::c_long,
    pub acchi: std::os::raw::c_long,
    pub mr: [std::os::raw::c_long; 4usize],
    pub pad: [std::os::raw::c_long; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct XtExcFrame {
    pub exit: std::os::raw::c_long,
    pub pc: std::os::raw::c_long,
    pub ps: std::os::raw::c_long,
    pub a0: std::os::raw::c_long,
    pub a1: std::os::raw::c_long,
    pub a2: std::os::raw::c_long,
    pub a3: std::os::raw::c_long,
    pub a4: std::os::raw::c_long,
    pub a5: std::os::raw::c_long,
    pub a6: std::os::raw::c_long,
    pub a7: std::os::raw::c_long,
    pub a8: std::os::raw::c_long,
    pub a9: std::os::raw::c_long,
    pub a10: std::os::raw::c_long,
    pub a11: std::os::raw::c_long,
    pub a12: std::os::raw::c_long,
    pub a13: std::os::raw::c_long,
    pub a14: std::os::raw::c_long,
    pub a15: std::os::raw::c_long,
    pub sar: std::os::raw::c_long,
    pub exccause: std::os::raw::c_long,
    pub excvaddr: std::os::raw::c_long,
    pub lbeg: std::os::raw::c_long,
    pub lend: std::os::raw::c_long,
    pub lcount: std::os::raw::c_long,
    pub tmp0: std::os::raw::c_long,
    pub tmp1: std::os::raw::c_long,
    pub tmp2: std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct XtSolFrame {
    pub exit: std::os::raw::c_long,
    pub pc: std::os::raw::c_long,
    pub ps: std::os::raw::c_long,
    pub next: std::os::raw::c_long,
    pub a0: std::os::raw::c_long,
    pub a1: std::os::raw::c_long,
    pub a2: std::os::raw::c_long,
    pub a3: std::os::raw::c_long,
}
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = std::os::raw::c_schar;
pub type uint_fast8_t = std::os::raw::c_uchar;
pub type int_fast16_t = std::os::raw::c_short;
pub type uint_fast16_t = std::os::raw::c_ushort;
pub type int_fast32_t = std::os::raw::c_int;
pub type uint_fast32_t = std::os::raw::c_uint;
pub type int_fast64_t = std::os::raw::c_longlong;
pub type uint_fast64_t = std::os::raw::c_ulonglong;
pub type intmax_t = std::os::raw::c_longlong;
pub type uintmax_t = std::os::raw::c_ulonglong;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ETS_STATUS {
    ETS_OK = 0,
    ETS_FAILED = 1,
}
pub type ETSSignal = u32;
pub type ETSParam = u32;
pub type ETSEvent = ETSEventTag;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct ETSEventTag {
    pub sig: ETSSignal,
    pub par: ETSParam,
}
pub type ETSTask = ::core::option::Option<unsafe extern "C" fn(e: *mut ETSEvent)>;
pub type ets_idle_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut std::os::raw::c_void)>;
extern "C" {
    pub fn ets_run();
}
extern "C" {
    pub fn ets_set_idle_cb(func: ets_idle_cb_t, arg: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn ets_task(task: ETSTask, prio: u8, queue: *mut ETSEvent, qlen: u8);
}
extern "C" {
    pub fn ets_post(prio: u8, sig: ETSSignal, par: ETSParam) -> ETS_STATUS;
}
extern "C" {
    pub static exc_cause_table: [*const std::os::raw::c_char; 40usize];
}
extern "C" {
    pub fn ets_set_user_start(start: u32);
}
extern "C" {
    pub fn ets_set_startup_callback(callback: u32);
}
extern "C" {
    pub fn ets_set_appcpu_boot_addr(start: u32);
}
extern "C" {
    pub fn ets_unpack_flash_code_legacy(
        pos: u32,
        entry_addr: *mut u32,
        jump: bool,
        config: bool,
    ) -> ETS_STATUS;
}
extern "C" {
    pub fn ets_unpack_flash_code(
        pos: u32,
        entry_addr: *mut u32,
        jump: bool,
        sb_need_check: bool,
        config: bool,
    ) -> ETS_STATUS;
}
extern "C" {
    pub fn ets_printf(fmt: *const std::os::raw::c_char, ...) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ets_write_char_uart(c: std::os::raw::c_char);
}
extern "C" {
    pub fn ets_install_putc1(
        p: ::core::option::Option<unsafe extern "C" fn(c: std::os::raw::c_char)>,
    );
}
extern "C" {
    pub fn ets_install_putc2(
        p: ::core::option::Option<unsafe extern "C" fn(c: std::os::raw::c_char)>,
    );
}
extern "C" {
    pub fn ets_install_uart_printf();
}
pub type ETSTimerFunc =
    ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _ETSTIMER_ {
    pub timer_next: *mut _ETSTIMER_,
    pub timer_expire: u32,
    pub timer_period: u32,
    pub timer_func: ETSTimerFunc,
    pub timer_arg: *mut std::os::raw::c_void,
}
impl Default for _ETSTIMER_ {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ETSTimer = _ETSTIMER_;
extern "C" {
    pub fn ets_timer_init();
}
extern "C" {
    pub fn ets_timer_deinit();
}
extern "C" {
    pub fn ets_timer_arm(timer: *mut ETSTimer, tmout: u32, repeat: bool);
}
extern "C" {
    pub fn ets_timer_arm_us(ptimer: *mut ETSTimer, us: u32, repeat: bool);
}
extern "C" {
    pub fn ets_timer_disarm(timer: *mut ETSTimer);
}
extern "C" {
    pub fn ets_timer_setfn(
        ptimer: *mut ETSTimer,
        pfunction: ETSTimerFunc,
        parg: *mut std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ets_timer_done(ptimer: *mut ETSTimer);
}
extern "C" {
    pub fn ets_delay_us(us: u32);
}
extern "C" {
    pub fn ets_update_cpu_frequency(ticks_per_us: u32);
}
extern "C" {
    pub fn ets_update_cpu_frequency_rom(ticks_per_us: u32);
}
extern "C" {
    pub fn ets_get_cpu_frequency() -> u32;
}
extern "C" {
    pub fn ets_get_xtal_scale() -> u32;
}
extern "C" {
    pub fn ets_get_detected_xtal_freq() -> u32;
}
pub type ets_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void)>;
extern "C" {
    pub fn ets_isr_attach(i: std::os::raw::c_int, func: ets_isr_t, arg: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn ets_isr_mask(mask: u32);
}
extern "C" {
    pub fn ets_isr_unmask(unmask: u32);
}
extern "C" {
    pub fn ets_intr_lock();
}
extern "C" {
    pub fn ets_intr_unlock();
}
extern "C" {
    pub fn ets_waiti0();
}
extern "C" {
    pub fn intr_matrix_set(cpu_no: std::os::raw::c_int, model_num: u32, intr_num: u32);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum STATUS {
    OK = 0,
    FAIL = 1,
    PENDING = 2,
    BUSY = 3,
    CANCEL = 4,
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut std::os::raw::c_char) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
        arg4: usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const std::os::raw::c_char, ...) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const std::os::raw::c_char, ...) -> std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const std::os::raw::c_char, ...) -> std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const std::os::raw::c_char, ...) -> std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut std::os::raw::c_char,
        arg2: std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn fputc(arg1: std::os::raw::c_int, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const std::os::raw::c_char, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut std::os::raw::c_char) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn putc(arg1: std::os::raw::c_int, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(arg1: std::os::raw::c_int, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut std::os::raw::c_void,
        _size: std::os::raw::c_uint,
        _n: std::os::raw::c_uint,
        arg2: *mut FILE,
    ) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const std::os::raw::c_void,
        _size: std::os::raw::c_uint,
        _n: std::os::raw::c_uint,
        arg2: *mut FILE,
    ) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: std::os::raw::c_long,
        arg3: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn perror(arg1: *const std::os::raw::c_char);
}
extern "C" {
    pub fn fopen(
        _name: *const std::os::raw::c_char,
        _type: *const std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn diprintf(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const std::os::raw::c_char, ...)
        -> std::os::raw::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const std::os::raw::c_char, ...) -> std::os::raw::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const std::os::raw::c_char, ...) -> std::os::raw::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const std::os::raw::c_char, ...) -> std::os::raw::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: std::os::raw::c_uint,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: usize,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vdiprintf(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const std::os::raw::c_char, arg2: __gnuc_va_list)
        -> std::os::raw::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const std::os::raw::c_char, arg2: __gnuc_va_list) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: usize,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut std::os::raw::c_char,
        arg2: std::os::raw::c_uint,
        arg3: *const std::os::raw::c_char,
        arg4: __builtin_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(arg1: std::os::raw::c_int, arg2: *const std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn popen(arg1: *const std::os::raw::c_char, arg2: *const std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn putw(arg1: std::os::raw::c_int, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut std::os::raw::c_char, arg3: std::os::raw::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: std::os::raw::c_int, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut std::os::raw::c_void,
        arg2: usize,
        arg3: *const std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut std::os::raw::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn renameat(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_int,
        arg4: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: std::os::raw::c_int,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const std::os::raw::c_char,
        ...
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const std::os::raw::c_char,
        ...
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: *const std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t)
        -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_void,
        arg3: usize,
        arg4: *const std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: std::os::raw::c_long,
        arg4: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> std::os::raw::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut std::os::raw::c_char)
        -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut std::os::raw::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const std::os::raw::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: std::os::raw::c_int)
        -> std::os::raw::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const std::os::raw::c_char) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const std::os::raw::c_char,
        _new: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _scanf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: usize,
        arg4: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: usize,
        arg4: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        ...
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const std::os::raw::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const std::os::raw::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: usize,
        arg4: *const std::os::raw::c_char,
        arg5: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: usize,
        arg4: *const std::os::raw::c_char,
        arg5: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: *const std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut std::os::raw::c_char,
        arg2: *mut usize,
        arg3: std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: std::os::raw::c_int, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const std::os::raw::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut std::os::raw::c_void,
                __buf: *mut std::os::raw::c_char,
                __n: std::os::raw::c_int,
            ) -> std::os::raw::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut std::os::raw::c_void,
                __buf: *const std::os::raw::c_char,
                __n: std::os::raw::c_int,
            ) -> std::os::raw::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut std::os::raw::c_void,
                __off: fpos_t,
                __whence: std::os::raw::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut std::os::raw::c_void) -> std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const std::os::raw::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut std::os::raw::c_void,
                __buf: *mut std::os::raw::c_char,
                __n: std::os::raw::c_int,
            ) -> std::os::raw::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut std::os::raw::c_void,
                __buf: *const std::os::raw::c_char,
                __n: std::os::raw::c_int,
            ) -> std::os::raw::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut std::os::raw::c_void,
                __off: fpos_t,
                __whence: std::os::raw::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut std::os::raw::c_void) -> std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
pub type cookie_read_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut std::os::raw::c_void,
        __buf: *mut std::os::raw::c_char,
        __n: usize,
    ) -> isize,
>;
pub type cookie_write_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut std::os::raw::c_void,
        __buf: *const std::os::raw::c_char,
        __n: usize,
    ) -> isize,
>;
pub type cookie_seek_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut std::os::raw::c_void,
        __off: *mut off_t,
        __whence: std::os::raw::c_int,
    ) -> std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::core::option::Option<
    unsafe extern "C" fn(__cookie: *mut std::os::raw::c_void) -> std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
extern "C" {
    pub fn fopencookie(
        __cookie: *mut std::os::raw::c_void,
        __mode: *const std::os::raw::c_char,
        __functions: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopencookie_r(
        arg1: *mut _reent,
        __cookie: *mut std::os::raw::c_void,
        __mode: *const std::os::raw::c_char,
        __functions: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __assert(
        arg1: *const std::os::raw::c_char,
        arg2: std::os::raw::c_int,
        arg3: *const std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_func(
        arg1: *const std::os::raw::c_char,
        arg2: std::os::raw::c_int,
        arg3: *const std::os::raw::c_char,
        arg4: *const std::os::raw::c_char,
    );
}
pub type esp_err_t = i32;
extern "C" {
    pub fn esp_err_to_name(code: esp_err_t) -> *const std::os::raw::c_char;
}
extern "C" {
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut std::os::raw::c_char,
        buflen: usize,
    ) -> *const std::os::raw::c_char;
}
extern "C" {
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const std::os::raw::c_char,
        line: std::os::raw::c_int,
        function: *const std::os::raw::c_char,
        expression: *const std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const std::os::raw::c_char,
        line: std::os::raw::c_int,
        function: *const std::os::raw::c_char,
        expression: *const std::os::raw::c_char,
    );
}
extern "C" {
    pub fn esp_get_idf_version() -> *const std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_mac_type_t {
    ESP_MAC_WIFI_STA = 0,
    ESP_MAC_WIFI_SOFTAP = 1,
    ESP_MAC_BT = 2,
    ESP_MAC_ETH = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_reset_reason_t {
    ESP_RST_UNKNOWN = 0,
    ESP_RST_POWERON = 1,
    ESP_RST_EXT = 2,
    ESP_RST_SW = 3,
    ESP_RST_PANIC = 4,
    ESP_RST_INT_WDT = 5,
    ESP_RST_TASK_WDT = 6,
    ESP_RST_WDT = 7,
    ESP_RST_DEEPSLEEP = 8,
    ESP_RST_BROWNOUT = 9,
    ESP_RST_SDIO = 10,
}
pub type shutdown_handler_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn esp_register_shutdown_handler(handle: shutdown_handler_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_unregister_shutdown_handler(handle: shutdown_handler_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_restart();
}
extern "C" {
    pub fn esp_reset_reason() -> esp_reset_reason_t;
}
extern "C" {
    pub fn esp_get_free_heap_size() -> u32;
}
extern "C" {
    pub fn esp_get_minimum_free_heap_size() -> u32;
}
extern "C" {
    pub fn esp_random() -> u32;
}
extern "C" {
    pub fn esp_fill_random(buf: *mut std::os::raw::c_void, len: usize);
}
extern "C" {
    pub fn esp_base_mac_addr_set(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    pub fn esp_base_mac_addr_get(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    pub fn esp_efuse_mac_get_custom(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    pub fn esp_efuse_mac_get_default(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    pub fn esp_read_mac(mac: *mut u8, type_: esp_mac_type_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_derive_local_mac(local_mac: *mut u8, universal_mac: *const u8) -> esp_err_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_chip_model_t {
    CHIP_ESP32 = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct esp_chip_info_t {
    pub model: esp_chip_model_t,
    pub features: u32,
    pub cores: u8,
    pub revision: u8,
}
impl Default for esp_chip_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn esp_chip_info(out_info: *mut esp_chip_info_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sntp_sync_mode_t {
    SNTP_SYNC_MODE_IMMED = 0,
    SNTP_SYNC_MODE_SMOOTH = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sntp_sync_status_t {
    SNTP_SYNC_STATUS_RESET = 0,
    SNTP_SYNC_STATUS_COMPLETED = 1,
    SNTP_SYNC_STATUS_IN_PROGRESS = 2,
}
pub type sntp_sync_time_cb_t = ::core::option::Option<unsafe extern "C" fn(tv: *mut timeval)>;
extern "C" {
    pub fn sntp_sync_time(tv: *mut timeval);
}
extern "C" {
    pub fn sntp_set_sync_mode(sync_mode: sntp_sync_mode_t);
}
extern "C" {
    pub fn sntp_get_sync_mode() -> sntp_sync_mode_t;
}
extern "C" {
    pub fn sntp_get_sync_status() -> sntp_sync_status_t;
}
extern "C" {
    pub fn sntp_set_sync_status(sync_status: sntp_sync_status_t);
}
extern "C" {
    pub fn sntp_set_time_sync_notification_cb(callback: sntp_sync_time_cb_t);
}
extern "C" {
    pub fn dhcp_ip_addr_restore(netif: *mut std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn dhcp_ip_addr_store(netif: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn dhcp_ip_addr_erase(netif: *mut std::os::raw::c_void);
}
pub type TaskFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void)>;
extern "C" {
    pub fn esp_cpu_stall(cpu_id: std::os::raw::c_int);
}
extern "C" {
    pub fn esp_cpu_unstall(cpu_id: std::os::raw::c_int);
}
extern "C" {
    pub fn esp_cpu_reset(cpu_id: std::os::raw::c_int);
}
extern "C" {
    pub fn esp_cpu_in_ocd_debug_mode() -> bool;
}
#[repr(C)]
pub struct XtosCoreState {
    pub signature: std::os::raw::c_long,
    pub restore_label: std::os::raw::c_long,
    pub aftersave_label: std::os::raw::c_long,
    pub areg: [std::os::raw::c_long; 64usize],
    pub caller_regs: [std::os::raw::c_long; 16usize],
    pub caller_regs_saved: std::os::raw::c_long,
    pub windowbase: std::os::raw::c_long,
    pub windowstart: std::os::raw::c_long,
    pub sar: std::os::raw::c_long,
    pub epc1: std::os::raw::c_long,
    pub ps: std::os::raw::c_long,
    pub excsave1: std::os::raw::c_long,
    pub depc: std::os::raw::c_long,
    pub epc: [std::os::raw::c_long; 6usize],
    pub eps: [std::os::raw::c_long; 6usize],
    pub excsave: [std::os::raw::c_long; 6usize],
    pub lcount: std::os::raw::c_long,
    pub lbeg: std::os::raw::c_long,
    pub lend: std::os::raw::c_long,
    pub vecbase: std::os::raw::c_long,
    pub atomctl: std::os::raw::c_long,
    pub memctl: std::os::raw::c_long,
    pub ccount: std::os::raw::c_long,
    pub ccompare: [std::os::raw::c_long; 3usize],
    pub intenable: std::os::raw::c_long,
    pub interrupt: std::os::raw::c_long,
    pub icount: std::os::raw::c_long,
    pub icountlevel: std::os::raw::c_long,
    pub debugcause: std::os::raw::c_long,
    pub dbreakc: [std::os::raw::c_long; 2usize],
    pub dbreaka: [std::os::raw::c_long; 2usize],
    pub ibreaka: [std::os::raw::c_long; 2usize],
    pub ibreakenable: std::os::raw::c_long,
    pub misc: [std::os::raw::c_long; 4usize],
    pub cpenable: std::os::raw::c_long,
    pub tlbs: [std::os::raw::c_long; 16usize],
    pub ncp: [std::os::raw::c_char; 48usize],
    pub cp0: [std::os::raw::c_char; 72usize],
    pub cp1: __IncompleteArrayField<std::os::raw::c_char>,
    pub cp2: __IncompleteArrayField<std::os::raw::c_char>,
    pub cp3: __IncompleteArrayField<std::os::raw::c_char>,
    pub cp4: __IncompleteArrayField<std::os::raw::c_char>,
    pub cp5: __IncompleteArrayField<std::os::raw::c_char>,
    pub cp6: __IncompleteArrayField<std::os::raw::c_char>,
    pub cp7: __IncompleteArrayField<std::os::raw::c_char>,
}
impl Default for XtosCoreState {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for XtosCoreState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "XtosCoreState {{ signature: {:?}, restore_label: {:?}, aftersave_label: {:?}, areg: [...], caller_regs: {:?}, caller_regs_saved: {:?}, windowbase: {:?}, windowstart: {:?}, sar: {:?}, epc1: {:?}, ps: {:?}, excsave1: {:?}, depc: {:?}, epc: {:?}, eps: {:?}, excsave: {:?}, lcount: {:?}, lbeg: {:?}, lend: {:?}, vecbase: {:?}, atomctl: {:?}, memctl: {:?}, ccount: {:?}, ccompare: {:?}, intenable: {:?}, interrupt: {:?}, icount: {:?}, icountlevel: {:?}, debugcause: {:?}, dbreakc: {:?}, dbreaka: {:?}, ibreaka: {:?}, ibreakenable: {:?}, misc: {:?}, cpenable: {:?}, tlbs: {:?}, ncp: [...], cp0: [...], cp1: {:?}, cp2: {:?}, cp3: {:?}, cp4: {:?}, cp5: {:?}, cp6: {:?}, cp7: {:?} }}" , self . signature , self . restore_label , self . aftersave_label , self . caller_regs , self . caller_regs_saved , self . windowbase , self . windowstart , self . sar , self . epc1 , self . ps , self . excsave1 , self . depc , self . epc , self . eps , self . excsave , self . lcount , self . lbeg , self . lend , self . vecbase , self . atomctl , self . memctl , self . ccount , self . ccompare , self . intenable , self . interrupt , self . icount , self . icountlevel , self . debugcause , self . dbreakc , self . dbreaka , self . ibreaka , self . ibreakenable , self . misc , self . cpenable , self . tlbs , self . cp1 , self . cp2 , self . cp3 , self . cp4 , self . cp5 , self . cp6 , self . cp7 )
    }
}
pub type _xtos_handler_func = ::core::option::Option<unsafe extern "C" fn()>;
pub type _xtos_handler = _xtos_handler_func;
extern "C" {
    pub fn _xtos_ints_off(mask: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_ints_on(mask: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_set_intlevel(intlevel: std::os::raw::c_int) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_set_min_intlevel(intlevel: std::os::raw::c_int) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_restore_intlevel(restoreval: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_restore_just_intlevel(restoreval: std::os::raw::c_uint) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler(n: std::os::raw::c_int, f: _xtos_handler) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler_arg(
        n: std::os::raw::c_int,
        f: _xtos_handler,
        arg: *mut std::os::raw::c_void,
    ) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_exception_handler(n: std::os::raw::c_int, f: _xtos_handler) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_memep_initrams();
}
extern "C" {
    pub fn _xtos_memep_enable(flags: std::os::raw::c_int);
}
extern "C" {
    pub fn _xtos_dispatch_level1_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level2_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level3_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level4_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level5_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level6_interrupts();
}
extern "C" {
    pub fn _xtos_read_ints() -> std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_clear_ints(mask: std::os::raw::c_uint);
}
extern "C" {
    pub fn _xtos_core_shutoff(flags: std::os::raw::c_uint) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _xtos_core_save(
        flags: std::os::raw::c_uint,
        savearea: *mut XtosCoreState,
        code: *mut std::os::raw::c_void,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _xtos_core_restore(retvalue: std::os::raw::c_uint, savearea: *mut XtosCoreState);
}
extern "C" {
    pub fn _xtos_timer_0_delta(cycles: std::os::raw::c_int);
}
extern "C" {
    pub fn _xtos_timer_1_delta(cycles: std::os::raw::c_int);
}
extern "C" {
    pub fn _xtos_timer_2_delta(cycles: std::os::raw::c_int);
}
extern "C" {
    pub fn esp_crosscore_int_init();
}
extern "C" {
    pub fn esp_crosscore_int_send_yield(core_id: std::os::raw::c_int);
}
extern "C" {
    pub fn esp_crosscore_int_send_freq_switch(core_id: std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_timer {
    _unused: [u8; 0],
}
pub type esp_timer_handle_t = *mut esp_timer;
pub type esp_timer_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut std::os::raw::c_void)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_timer_dispatch_t {
    ESP_TIMER_TASK = 0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct esp_timer_create_args_t {
    pub callback: esp_timer_cb_t,
    pub arg: *mut std::os::raw::c_void,
    pub dispatch_method: esp_timer_dispatch_t,
    pub name: *const std::os::raw::c_char,
}
impl Default for esp_timer_create_args_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn esp_timer_init() -> esp_err_t;
}
extern "C" {
    pub fn esp_timer_deinit() -> esp_err_t;
}
extern "C" {
    pub fn esp_timer_create(
        create_args: *const esp_timer_create_args_t,
        out_handle: *mut esp_timer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_timer_start_once(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    pub fn esp_timer_start_periodic(timer: esp_timer_handle_t, period: u64) -> esp_err_t;
}
extern "C" {
    pub fn esp_timer_stop(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_timer_delete(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_timer_get_time() -> i64;
}
extern "C" {
    pub fn esp_timer_get_next_alarm() -> i64;
}
extern "C" {
    pub fn esp_timer_dump(stream: *mut FILE) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multi_heap_info {
    _unused: [u8; 0],
}
pub type multi_heap_handle_t = *mut multi_heap_info;
extern "C" {
    pub fn multi_heap_malloc(heap: multi_heap_handle_t, size: usize) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn multi_heap_free(heap: multi_heap_handle_t, p: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn multi_heap_realloc(
        heap: multi_heap_handle_t,
        p: *mut std::os::raw::c_void,
        size: usize,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn multi_heap_get_allocated_size(
        heap: multi_heap_handle_t,
        p: *mut std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    pub fn multi_heap_register(
        start: *mut std::os::raw::c_void,
        size: usize,
    ) -> multi_heap_handle_t;
}
extern "C" {
    pub fn multi_heap_set_lock(heap: multi_heap_handle_t, lock: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn multi_heap_dump(heap: multi_heap_handle_t);
}
extern "C" {
    pub fn multi_heap_check(heap: multi_heap_handle_t, print_errors: bool) -> bool;
}
extern "C" {
    pub fn multi_heap_free_size(heap: multi_heap_handle_t) -> usize;
}
extern "C" {
    pub fn multi_heap_minimum_free_size(heap: multi_heap_handle_t) -> usize;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct multi_heap_info_t {
    pub total_free_bytes: usize,
    pub total_allocated_bytes: usize,
    pub largest_free_block: usize,
    pub minimum_free_bytes: usize,
    pub allocated_blocks: usize,
    pub free_blocks: usize,
    pub total_blocks: usize,
}
extern "C" {
    pub fn multi_heap_get_info(heap: multi_heap_handle_t, info: *mut multi_heap_info_t);
}
extern "C" {
    pub fn heap_caps_malloc(size: usize, caps: u32) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn heap_caps_free(ptr: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn heap_caps_realloc(
        ptr: *mut std::os::raw::c_void,
        size: usize,
        caps: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn heap_caps_calloc(n: usize, size: usize, caps: u32) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn heap_caps_get_free_size(caps: u32) -> usize;
}
extern "C" {
    pub fn heap_caps_get_minimum_free_size(caps: u32) -> usize;
}
extern "C" {
    pub fn heap_caps_get_largest_free_block(caps: u32) -> usize;
}
extern "C" {
    pub fn heap_caps_get_info(info: *mut multi_heap_info_t, caps: u32);
}
extern "C" {
    pub fn heap_caps_print_heap_info(caps: u32);
}
extern "C" {
    pub fn heap_caps_check_integrity_all(print_errors: bool) -> bool;
}
extern "C" {
    pub fn heap_caps_check_integrity(caps: u32, print_errors: bool) -> bool;
}
extern "C" {
    pub fn heap_caps_check_integrity_addr(addr: isize, print_errors: bool) -> bool;
}
extern "C" {
    pub fn heap_caps_malloc_extmem_enable(limit: usize);
}
extern "C" {
    pub fn heap_caps_malloc_prefer(size: usize, num: usize, ...) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn heap_caps_realloc_prefer(
        ptr: *mut std::os::raw::c_void,
        size: usize,
        num: usize,
        ...
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn heap_caps_calloc_prefer(
        n: usize,
        size: usize,
        num: usize,
        ...
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn heap_caps_dump(caps: u32);
}
extern "C" {
    pub fn heap_caps_dump_all();
}
pub type StackType_t = u8;
pub type BaseType_t = std::os::raw::c_int;
pub type UBaseType_t = std::os::raw::c_uint;
pub type TickType_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct portMUX_TYPE {
    pub owner: u32,
    pub count: u32,
}
extern "C" {
    pub fn vPortAssertIfInISR();
}
extern "C" {
    pub fn vPortCPUInitializeMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vTaskExitCritical(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vTaskEnterCritical(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vPortCPUAcquireMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vPortCPUAcquireMutexTimeout(
        mux: *mut portMUX_TYPE,
        timeout_cycles: std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn vPortCPUReleaseMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vPortYield();
}
extern "C" {
    pub fn _frxt_setup_switch();
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xMPU_SETTINGS {
    pub coproc_area: *mut StackType_t,
}
impl Default for xMPU_SETTINGS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn esp_vApplicationIdleHook();
}
extern "C" {
    pub fn esp_vApplicationTickHook();
}
extern "C" {
    pub fn _xt_coproc_release(coproc_sa_base: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn vApplicationSleep(xExpectedIdleTime: TickType_t);
}
extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut std::os::raw::c_void,
        xRunPrivileged: BaseType_t,
    ) -> *mut StackType_t;
}
extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
    pub fn vPortEndScheduler();
}
extern "C" {
    pub fn vPortYieldOtherCore(coreid: BaseType_t);
}
extern "C" {
    pub fn vPortSetStackWatchpoint(pxStackStart: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xPortInIsrContext() -> BaseType_t;
}
extern "C" {
    pub fn xPortInterruptedFromISRContext() -> BaseType_t;
}
extern "C" {
    pub fn vPortStoreTaskMPUSettings(
        xMPUSettings: *mut xMPU_SETTINGS,
        xRegions: *const xMEMORY_REGION,
        pxBottomOfStack: *mut StackType_t,
        usStackDepth: u32,
    );
}
extern "C" {
    pub fn vPortReleaseTaskMPUSettings(xMPUSettings: *mut xMPU_SETTINGS);
}
extern "C" {
    pub fn xPortGetTickRateHz() -> u32;
}
extern "C" {
    pub fn uxPortCompareSetExtram(addr: *mut u32, compare: u32, set: *mut u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy1: TickType_t,
    pub pvDummy2: [*mut std::os::raw::c_void; 4usize],
}
impl Default for xSTATIC_LIST_ITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy1: TickType_t,
    pub pvDummy2: [*mut std::os::raw::c_void; 2usize],
}
impl Default for xSTATIC_MINI_LIST_ITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xSTATIC_LIST {
    pub uxDummy1: UBaseType_t,
    pub pvDummy2: *mut std::os::raw::c_void,
    pub xDummy3: StaticMiniListItem_t,
}
impl Default for xSTATIC_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut std::os::raw::c_void,
    pub xDummy2: xMPU_SETTINGS,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut std::os::raw::c_void,
    pub ucDummy7: [u8; 16usize],
    pub uxDummyCoreId: UBaseType_t,
    pub pxDummy8: *mut std::os::raw::c_void,
    pub uxDummy9: UBaseType_t,
    pub OldInterruptState: u32,
    pub uxDummy12: [UBaseType_t; 2usize],
    pub pvDummy15: [*mut std::os::raw::c_void; 1usize],
    pub pvDummyLocalStorageCallBack: [*mut std::os::raw::c_void; 1usize],
    pub xDummy17: _reent,
    pub ulDummy18: u32,
    pub ucDummy19: u32,
    pub uxDummy20: u8,
}
impl Default for xSTATIC_TCB {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut std::os::raw::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub pvDummy7: *mut std::os::raw::c_void,
    pub muxDummy: portMUX_TYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut std::os::raw::c_void,
    pub uxDummy2: UBaseType_t,
    _bindgen_union_align: u32,
}
impl Default for xSTATIC_QUEUE__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for xSTATIC_QUEUE__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "xSTATIC_QUEUE__bindgen_ty_1 {{ union }}")
    }
}
impl Default for xSTATIC_QUEUE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for xSTATIC_QUEUE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "xSTATIC_QUEUE {{ pvDummy1: {:?}, u: {:?}, xDummy3: {:?}, uxDummy4: {:?}, pvDummy7: {:?}, muxDummy: {:?} }}" , self . pvDummy1 , self . u , self . xDummy3 , self . uxDummy4 , self . pvDummy7 , self . muxDummy )
    }
}
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
    pub muxDummy: portMUX_TYPE,
}
impl Default for xSTATIC_EVENT_GROUP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut std::os::raw::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub uxDummy4: UBaseType_t,
    pub pvDummy5: [*mut std::os::raw::c_void; 2usize],
}
impl Default for xSTATIC_TIMER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xLIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut std::os::raw::c_void,
    pub pvContainer: *mut std::os::raw::c_void,
}
impl Default for xLIST_ITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
impl Default for xMINI_LIST_ITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    pub pxIndex: *mut ListItem_t,
    pub xListEnd: MiniListItem_t,
}
impl Default for xLIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type List_t = xLIST;
extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
pub type TaskHandle_t = *mut std::os::raw::c_void;
pub type TaskHookFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void) -> BaseType_t>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eTaskState {
    eRunning = 0,
    eReady = 1,
    eBlocked = 2,
    eSuspended = 3,
    eDeleted = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eNotifyAction {
    eNoAction = 0,
    eSetBits = 1,
    eIncrement = 2,
    eSetValueWithOverwrite = 3,
    eSetValueWithoutOverwrite = 4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
pub type TimeOut_t = xTIME_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut std::os::raw::c_void,
    pub ulLengthInBytes: u32,
    pub ulParameters: u32,
}
impl Default for xMEMORY_REGION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const std::os::raw::c_char,
    pub usStackDepth: u32,
    pub pvParameters: *mut std::os::raw::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 1usize],
}
impl Default for xTASK_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type TaskParameters_t = xTASK_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xTASK_STATUS {
    pub xHandle: TaskHandle_t,
    pub pcTaskName: *const std::os::raw::c_char,
    pub xTaskNumber: UBaseType_t,
    pub eCurrentState: eTaskState,
    pub uxCurrentPriority: UBaseType_t,
    pub uxBasePriority: UBaseType_t,
    pub ulRunTimeCounter: u32,
    pub pxStackBase: *mut StackType_t,
    pub usStackHighWaterMark: u32,
}
impl Default for xTASK_STATUS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type TaskStatus_t = xTASK_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct xTASK_SNAPSHOT {
    pub pxTCB: *mut std::os::raw::c_void,
    pub pxTopOfStack: *mut StackType_t,
    pub pxEndOfStack: *mut StackType_t,
}
impl Default for xTASK_SNAPSHOT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type TaskSnapshot_t = xTASK_SNAPSHOT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum eSleepModeStatus {
    eAbortSleep = 0,
    eStandardSleep = 1,
    eNoTasksWaitingTimeout = 2,
}
extern "C" {
    pub fn xTaskCreatePinnedToCore(
        pvTaskCode: TaskFunction_t,
        pcName: *const std::os::raw::c_char,
        usStackDepth: u32,
        pvParameters: *mut std::os::raw::c_void,
        uxPriority: UBaseType_t,
        pvCreatedTask: *mut TaskHandle_t,
        xCoreID: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskCreateRestricted(
        pxTaskDefinition: *const TaskParameters_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
extern "C" {
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
extern "C" {
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
extern "C" {
    pub fn vTaskDelayUntil(pxPreviousWakeTime: *mut TickType_t, xTimeIncrement: TickType_t);
}
extern "C" {
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
extern "C" {
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
extern "C" {
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
extern "C" {
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskStartScheduler();
}
extern "C" {
    pub fn vTaskEndScheduler();
}
extern "C" {
    pub fn vTaskSuspendAll();
}
extern "C" {
    pub fn xTaskResumeAll() -> BaseType_t;
}
extern "C" {
    pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
extern "C" {
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
extern "C" {
    pub fn pcTaskGetTaskName(xTaskToQuery: TaskHandle_t) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn pxTaskGetStackStart(xTask: TaskHandle_t) -> *mut u8;
}
extern "C" {
    pub fn vTaskSetThreadLocalStoragePointer(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pvTaskGetThreadLocalStoragePointer(
        xTaskToQuery: TaskHandle_t,
        xIndex: BaseType_t,
    ) -> *mut std::os::raw::c_void;
}
pub type TlsDeleteCallbackFunction_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: std::os::raw::c_int, arg2: *mut std::os::raw::c_void),
>;
extern "C" {
    pub fn vTaskSetThreadLocalStoragePointerAndDelCallback(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut std::os::raw::c_void,
        pvDelCallback: TlsDeleteCallbackFunction_t,
    );
}
extern "C" {
    pub fn xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut std::os::raw::c_void,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn xTaskGetIdleTaskHandleForCPU(cpuid: UBaseType_t) -> TaskHandle_t;
}
extern "C" {
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut u32,
    ) -> UBaseType_t;
}
extern "C" {
    pub fn vTaskList(pcWriteBuffer: *mut std::os::raw::c_char);
}
extern "C" {
    pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut std::os::raw::c_char);
}
extern "C" {
    pub fn xTaskNotify(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskNotifyWait(
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    pub fn ulTaskNotifyTake(xClearCountOnExit: BaseType_t, xTicksToWait: TickType_t) -> u32;
}
extern "C" {
    pub fn xTaskIncrementTick() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskSwitchContext();
}
extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandleForCPU(cpuid: BaseType_t) -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskMissedYield();
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPriorityInherit(pxMutexHolder: TaskHandle_t);
}
extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn xTaskGetAffinity(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
extern "C" {
    pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
extern "C" {
    pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn uxTaskGetSnapshotAll(
        pxTaskSnapshotArray: *mut TaskSnapshot_t,
        uxArraySize: UBaseType_t,
        pxTcbSz: *mut UBaseType_t,
    ) -> UBaseType_t;
}
pub type QueueHandle_t = *mut std::os::raw::c_void;
pub type QueueSetHandle_t = *mut std::os::raw::c_void;
pub type QueueSetMemberHandle_t = *mut std::os::raw::c_void;
extern "C" {
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const std::os::raw::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueuePeekFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut std::os::raw::c_void,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGenericReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut std::os::raw::c_void,
        xTicksToWait: TickType_t,
        xJustPeek: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
extern "C" {
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const std::os::raw::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut std::os::raw::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn xQueueAltGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const std::os::raw::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueAltGenericReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut std::os::raw::c_void,
        xTicksToWait: TickType_t,
        xJustPeeking: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const std::os::raw::c_void,
        xCoRoutinePreviouslyWoken: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut std::os::raw::c_void,
        pxTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const std::os::raw::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut std::os::raw::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn xQueueTakeMutexRecursive(xMutex: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveMutexRecursive(pxMutex: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateSet(uxEventQueueLength: UBaseType_t) -> QueueSetHandle_t;
}
extern "C" {
    pub fn xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: TickType_t,
    ) -> QueueSetMemberHandle_t;
}
extern "C" {
    pub fn xQueueSelectFromSetFromISR(xQueueSet: QueueSetHandle_t) -> QueueSetMemberHandle_t;
}
extern "C" {
    pub fn vQueueWaitForMessageRestricted(xQueue: QueueHandle_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: BaseType_t) -> BaseType_t;
}
extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
pub type SemaphoreHandle_t = QueueHandle_t;
extern "C" {
    pub fn esp_vfs_lwip_sockets_register();
}
pub type sys_sem_t = SemaphoreHandle_t;
pub type sys_mutex_t = SemaphoreHandle_t;
pub type sys_thread_t = TaskHandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sys_mbox_s {
    pub os_mbox: QueueHandle_t,
    pub owner: *mut std::os::raw::c_void,
}
impl Default for sys_mbox_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sys_mbox_t = *mut sys_mbox_s;
extern "C" {
    pub fn sys_delay_ms(ms: u32);
}
extern "C" {
    pub fn sys_thread_sem_init() -> *mut sys_sem_t;
}
extern "C" {
    pub fn sys_thread_sem_deinit();
}
extern "C" {
    pub fn sys_thread_sem_get() -> *mut sys_sem_t;
}
pub type u8_t = u8;
pub type s8_t = i8;
pub type u16_t = u16;
pub type s16_t = i16;
pub type u32_t = u32;
pub type s32_t = i32;
pub type sys_prot_t = std::os::raw::c_int;
pub type u64_t = u64;
pub type s64_t = i64;
pub type mem_ptr_t = usize;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(numer: intmax_t, denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const std::os::raw::c_char,
        arg2: *mut *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const std::os::raw::c_char,
        arg2: *mut *mut std::os::raw::c_char,
        arg3: std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn isalnum(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn islower(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub static __ctype_ptr__: *const std::os::raw::c_char;
}
extern "C" {
    pub static mut _ctype_: [std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn lwip_htons(x: u16_t) -> u16_t;
}
extern "C" {
    pub fn lwip_htonl(x: u32_t) -> u32_t;
}
extern "C" {
    pub fn lwip_itoa(
        result: *mut std::os::raw::c_char,
        bufsize: usize,
        number: std::os::raw::c_int,
    );
}
extern "C" {
    pub fn lwip_strnicmp(
        str1: *const std::os::raw::c_char,
        str2: *const std::os::raw::c_char,
        len: usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_stricmp(
        str1: *const std::os::raw::c_char,
        str2: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_strnstr(
        buffer: *const std::os::raw::c_char,
        token: *const std::os::raw::c_char,
        n: usize,
    ) -> *mut std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct ip4_addr {
    pub addr: u32_t,
}
pub type ip4_addr_t = ip4_addr;
extern "C" {
    pub fn ip4_addr_isbroadcast_u32(addr: u32_t, netif: *const netif) -> u8_t;
}
extern "C" {
    pub fn ip4_addr_netmask_valid(netmask: u32_t) -> u8_t;
}
extern "C" {
    pub fn ipaddr_addr(cp: *const std::os::raw::c_char) -> u32_t;
}
extern "C" {
    pub fn ip4addr_aton(
        cp: *const std::os::raw::c_char,
        addr: *mut ip4_addr_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ip4addr_ntoa(addr: *const ip4_addr_t) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn ip4addr_ntoa_r(
        addr: *const ip4_addr_t,
        buf: *mut std::os::raw::c_char,
        buflen: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lwip_ipv6_scope_type {
    IP6_UNKNOWN = 0,
    IP6_UNICAST = 1,
    IP6_MULTICAST = 2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct ip6_addr {
    pub addr: [u32_t; 4usize],
    pub zone: u8_t,
}
pub type ip6_addr_t = ip6_addr;
extern "C" {
    pub fn ip6addr_aton(
        cp: *const std::os::raw::c_char,
        addr: *mut ip6_addr_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn ip6addr_ntoa(addr: *const ip6_addr_t) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn ip6addr_ntoa_r(
        addr: *const ip6_addr_t,
        buf: *mut std::os::raw::c_char,
        buflen: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lwip_ip_addr_type {
    IPADDR_TYPE_V4 = 0,
    IPADDR_TYPE_V6 = 6,
    IPADDR_TYPE_ANY = 46,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_addr {
    pub u_addr: ip_addr__bindgen_ty_1,
    pub type_: u8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_addr__bindgen_ty_1 {
    pub ip6: ip6_addr_t,
    pub ip4: ip4_addr_t,
    _bindgen_union_align: [u32; 5usize],
}
impl Default for ip_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for ip_addr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "ip_addr__bindgen_ty_1 {{ union }}")
    }
}
impl Default for ip_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for ip_addr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "ip_addr {{ u_addr: {:?}, type: {:?} }}",
            self.u_addr, self.type_
        )
    }
}
pub type ip_addr_t = ip_addr;
extern "C" {
    pub static ip_addr_any_type: ip_addr_t;
}
extern "C" {
    pub fn ipaddr_ntoa(addr: *const ip_addr_t) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn ipaddr_ntoa_r(
        addr: *const ip_addr_t,
        buf: *mut std::os::raw::c_char,
        buflen: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn ipaddr_aton(
        cp: *const std::os::raw::c_char,
        addr: *mut ip_addr_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub static ip_addr_any: ip_addr_t;
}
extern "C" {
    pub static ip_addr_broadcast: ip_addr_t;
}
extern "C" {
    pub static ip6_addr_any: ip_addr_t;
}
pub type in_addr_t = u32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub un: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u32_addr: [u32_t; 4usize],
    pub u8_addr: [u8_t; 16usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for in6_addr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "in6_addr__bindgen_ty_1 {{ union }}")
    }
}
impl Default for in6_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for in6_addr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "in6_addr {{ un: {:?} }}", self.un)
    }
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
pub type nvs_handle_t = u32;
pub type nvs_handle = nvs_handle_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvs_open_mode_t {
    NVS_READONLY = 0,
    NVS_READWRITE = 1,
}
pub use self::nvs_open_mode_t as nvs_open_mode;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvs_type_t {
    NVS_TYPE_U8 = 1,
    NVS_TYPE_I8 = 17,
    NVS_TYPE_U16 = 2,
    NVS_TYPE_I16 = 18,
    NVS_TYPE_U32 = 4,
    NVS_TYPE_I32 = 20,
    NVS_TYPE_U64 = 8,
    NVS_TYPE_I64 = 24,
    NVS_TYPE_STR = 33,
    NVS_TYPE_BLOB = 66,
    NVS_TYPE_ANY = 255,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct nvs_entry_info_t {
    pub namespace_name: [std::os::raw::c_char; 16usize],
    pub key: [std::os::raw::c_char; 16usize],
    pub type_: nvs_type_t,
}
impl Default for nvs_entry_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvs_opaque_iterator_t {
    _unused: [u8; 0],
}
pub type nvs_iterator_t = *mut nvs_opaque_iterator_t;
extern "C" {
    pub fn nvs_open(
        name: *const std::os::raw::c_char,
        open_mode: nvs_open_mode_t,
        out_handle: *mut nvs_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_open_from_partition(
        part_name: *const std::os::raw::c_char,
        name: *const std::os::raw::c_char,
        open_mode: nvs_open_mode_t,
        out_handle: *mut nvs_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i8(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        value: i8,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u8(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        value: u8,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i16(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        value: i16,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u16(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        value: u16,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i32(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        value: i32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u32(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        value: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i64(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        value: i64,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u64(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        value: u64,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_str(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        value: *const std::os::raw::c_char,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_blob(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        value: *const std::os::raw::c_void,
        length: usize,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i8(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        out_value: *mut i8,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u8(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        out_value: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i16(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        out_value: *mut i16,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u16(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        out_value: *mut u16,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i32(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        out_value: *mut i32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u32(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        out_value: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i64(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        out_value: *mut i64,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u64(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        out_value: *mut u64,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_str(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        out_value: *mut std::os::raw::c_char,
        length: *mut usize,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_blob(
        handle: nvs_handle_t,
        key: *const std::os::raw::c_char,
        out_value: *mut std::os::raw::c_void,
        length: *mut usize,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_erase_key(handle: nvs_handle_t, key: *const std::os::raw::c_char) -> esp_err_t;
}
extern "C" {
    pub fn nvs_erase_all(handle: nvs_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn nvs_commit(handle: nvs_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn nvs_close(handle: nvs_handle_t);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct nvs_stats_t {
    pub used_entries: usize,
    pub free_entries: usize,
    pub total_entries: usize,
    pub namespace_count: usize,
}
extern "C" {
    pub fn nvs_get_stats(
        part_name: *const std::os::raw::c_char,
        nvs_stats: *mut nvs_stats_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_used_entry_count(handle: nvs_handle_t, used_entries: *mut usize) -> esp_err_t;
}
extern "C" {
    pub fn nvs_entry_find(
        part_name: *const std::os::raw::c_char,
        namespace_name: *const std::os::raw::c_char,
        type_: nvs_type_t,
    ) -> nvs_iterator_t;
}
extern "C" {
    pub fn nvs_entry_next(iterator: nvs_iterator_t) -> nvs_iterator_t;
}
extern "C" {
    pub fn nvs_entry_info(iterator: nvs_iterator_t, out_info: *mut nvs_entry_info_t);
}
extern "C" {
    pub fn nvs_release_iterator(iterator: nvs_iterator_t);
}
pub const ESP_ERR_FLASH_SIZE_NOT_MATCH: _bindgen_ty_1 = _bindgen_ty_1::ESP_ERR_FLASH_SIZE_NOT_MATCH;
pub const ESP_ERR_FLASH_NO_RESPONSE: _bindgen_ty_1 = _bindgen_ty_1::ESP_ERR_FLASH_NO_RESPONSE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    ESP_ERR_FLASH_SIZE_NOT_MATCH = 260,
    ESP_ERR_FLASH_NO_RESPONSE = 264,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_flash_trans_t {
    pub command: u8,
    pub mosi_len: u8,
    pub miso_len: u8,
    pub mosi_data: u32,
    pub miso_data: [u32; 2usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_flash_speed_t {
    ESP_FLASH_5MHZ = 0,
    ESP_FLASH_10MHZ = 1,
    ESP_FLASH_20MHZ = 2,
    ESP_FLASH_26MHZ = 3,
    ESP_FLASH_40MHZ = 4,
    ESP_FLASH_80MHZ = 5,
    ESP_FLASH_SPEED_MAX = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_flash_io_mode_t {
    SPI_FLASH_SLOWRD = 0,
    SPI_FLASH_FASTRD = 1,
    SPI_FLASH_DOUT = 2,
    SPI_FLASH_DIO = 3,
    SPI_FLASH_QOUT = 4,
    SPI_FLASH_QIO = 5,
    SPI_FLASH_READ_MODE_MAX = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spi_flash_host_driver_t {
    pub driver_data: *mut std::os::raw::c_void,
    pub dev_config: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t) -> esp_err_t,
    >,
    pub common_command: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            t: *mut spi_flash_trans_t,
        ) -> esp_err_t,
    >,
    pub read_id: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t, id: *mut u32) -> esp_err_t,
    >,
    pub erase_chip:
        ::core::option::Option<unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t)>,
    pub erase_sector: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t, start_address: u32),
    >,
    pub erase_block: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t, start_address: u32),
    >,
    pub read_status: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t, out_sr: *mut u8) -> esp_err_t,
    >,
    pub set_write_protect: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t, wp: bool) -> esp_err_t,
    >,
    pub program_page: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            buffer: *const std::os::raw::c_void,
            address: u32,
            length: u32,
        ),
    >,
    pub supports_direct_write: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            p: *const std::os::raw::c_void,
        ) -> bool,
    >,
    pub supports_direct_read: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            p: *const std::os::raw::c_void,
        ) -> bool,
    >,
    pub max_write_bytes: std::os::raw::c_int,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            buffer: *mut std::os::raw::c_void,
            address: u32,
            read_len: u32,
        ) -> esp_err_t,
    >,
    pub max_read_bytes: std::os::raw::c_int,
    pub host_idle:
        ::core::option::Option<unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t) -> bool>,
    pub configure_host_io_mode: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            command: u32,
            addr_bitlen: u32,
            dummy_bitlen_base: std::os::raw::c_int,
            io_mode: esp_flash_io_mode_t,
        ) -> esp_err_t,
    >,
    pub poll_cmd_done:
        ::core::option::Option<unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t)>,
    pub flush_cache: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            addr: u32,
            size: u32,
        ) -> esp_err_t,
    >,
}
impl Default for spi_flash_host_driver_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_flash_chip_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct esp_flash_region_t {
    pub offset: u32,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct esp_flash_os_functions_t {
    pub start:
        ::core::option::Option<unsafe extern "C" fn(arg: *mut std::os::raw::c_void) -> esp_err_t>,
    pub end:
        ::core::option::Option<unsafe extern "C" fn(arg: *mut std::os::raw::c_void) -> esp_err_t>,
    pub region_protected: ::core::option::Option<
        unsafe extern "C" fn(
            arg: *mut std::os::raw::c_void,
            start_addr: usize,
            size: usize,
        ) -> esp_err_t,
    >,
    pub delay_ms: ::core::option::Option<
        unsafe extern "C" fn(arg: *mut std::os::raw::c_void, ms: std::os::raw::c_uint) -> esp_err_t,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct esp_flash_t {
    pub host: *mut spi_flash_host_driver_t,
    pub chip_drv: *const spi_flash_chip_t,
    pub os_func: *const esp_flash_os_functions_t,
    pub os_func_data: *mut std::os::raw::c_void,
    pub read_mode: esp_flash_io_mode_t,
    pub size: u32,
    pub chip_id: u32,
}
impl Default for esp_flash_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn esp_flash_init(chip: *mut esp_flash_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_chip_driver_initialized(chip: *const esp_flash_t) -> bool;
}
extern "C" {
    pub fn esp_flash_read_id(chip: *mut esp_flash_t, out_id: *mut u32) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_get_size(chip: *mut esp_flash_t, out_size: *mut u32) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_erase_chip(chip: *mut esp_flash_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_erase_region(chip: *mut esp_flash_t, start: u32, len: u32) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_get_chip_write_protect(
        chip: *mut esp_flash_t,
        write_protected: *mut bool,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_set_chip_write_protect(
        chip: *mut esp_flash_t,
        write_protect: bool,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_get_protectable_regions(
        chip: *const esp_flash_t,
        out_regions: *mut *const esp_flash_region_t,
        out_num_regions: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_get_protected_region(
        chip: *mut esp_flash_t,
        region: *const esp_flash_region_t,
        out_protected: *mut bool,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_set_protected_region(
        chip: *mut esp_flash_t,
        region: *const esp_flash_region_t,
        protect: bool,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_read(
        chip: *mut esp_flash_t,
        buffer: *mut std::os::raw::c_void,
        address: u32,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_write(
        chip: *mut esp_flash_t,
        buffer: *const std::os::raw::c_void,
        address: u32,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_write_encrypted(
        chip: *mut esp_flash_t,
        address: u32,
        buffer: *const std::os::raw::c_void,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_flash_read_encrypted(
        chip: *mut esp_flash_t,
        address: u32,
        out_buffer: *mut std::os::raw::c_void,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub static mut esp_flash_default_chip: *mut esp_flash_t;
}
extern "C" {
    pub fn spi_flash_init();
}
extern "C" {
    pub fn spi_flash_get_chip_size() -> usize;
}
extern "C" {
    pub fn spi_flash_erase_sector(sector: usize) -> esp_err_t;
}
extern "C" {
    pub fn spi_flash_erase_range(start_address: usize, size: usize) -> esp_err_t;
}
extern "C" {
    pub fn spi_flash_write(
        dest_addr: usize,
        src: *const std::os::raw::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_flash_write_encrypted(
        dest_addr: usize,
        src: *const std::os::raw::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_flash_read(
        src_addr: usize,
        dest: *mut std::os::raw::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_flash_read_encrypted(
        src: usize,
        dest: *mut std::os::raw::c_void,
        size: usize,
    ) -> esp_err_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spi_flash_mmap_memory_t {
    SPI_FLASH_MMAP_DATA = 0,
    SPI_FLASH_MMAP_INST = 1,
}
pub type spi_flash_mmap_handle_t = u32;
extern "C" {
    pub fn spi_flash_mmap(
        src_addr: usize,
        size: usize,
        memory: spi_flash_mmap_memory_t,
        out_ptr: *mut *const std::os::raw::c_void,
        out_handle: *mut spi_flash_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_flash_mmap_pages(
        pages: *const std::os::raw::c_int,
        page_count: usize,
        memory: spi_flash_mmap_memory_t,
        out_ptr: *mut *const std::os::raw::c_void,
        out_handle: *mut spi_flash_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_flash_munmap(handle: spi_flash_mmap_handle_t);
}
extern "C" {
    pub fn spi_flash_mmap_dump();
}
extern "C" {
    pub fn spi_flash_mmap_get_free_pages(memory: spi_flash_mmap_memory_t) -> u32;
}
extern "C" {
    pub fn spi_flash_cache2phys(cached: *const std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn spi_flash_phys2cache(
        phys_offs: usize,
        memory: spi_flash_mmap_memory_t,
    ) -> *const std::os::raw::c_void;
}
extern "C" {
    pub fn spi_flash_cache_enabled() -> bool;
}
pub type spi_flash_guard_start_func_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type spi_flash_guard_end_func_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type spi_flash_op_lock_func_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type spi_flash_op_unlock_func_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type spi_flash_is_safe_write_address_t =
    ::core::option::Option<unsafe extern "C" fn(addr: usize, size: usize) -> bool>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_flash_guard_funcs_t {
    pub start: spi_flash_guard_start_func_t,
    pub end: spi_flash_guard_end_func_t,
    pub op_lock: spi_flash_op_lock_func_t,
    pub op_unlock: spi_flash_op_unlock_func_t,
    pub is_safe_write_address: spi_flash_is_safe_write_address_t,
}
extern "C" {
    pub fn spi_flash_guard_set(funcs: *const spi_flash_guard_funcs_t);
}
extern "C" {
    pub fn spi_flash_guard_get() -> *const spi_flash_guard_funcs_t;
}
extern "C" {
    pub static g_flash_guard_default_ops: spi_flash_guard_funcs_t;
}
extern "C" {
    pub static g_flash_guard_no_os_ops: spi_flash_guard_funcs_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_partition_type_t {
    ESP_PARTITION_TYPE_APP = 0,
    ESP_PARTITION_TYPE_DATA = 1,
}
impl esp_partition_subtype_t {
    pub const ESP_PARTITION_SUBTYPE_APP_OTA_0: esp_partition_subtype_t =
        esp_partition_subtype_t::ESP_PARTITION_SUBTYPE_APP_OTA_MIN;
}
impl esp_partition_subtype_t {
    pub const ESP_PARTITION_SUBTYPE_APP_TEST: esp_partition_subtype_t =
        esp_partition_subtype_t::ESP_PARTITION_SUBTYPE_APP_OTA_MAX;
}
impl esp_partition_subtype_t {
    pub const ESP_PARTITION_SUBTYPE_DATA_OTA: esp_partition_subtype_t =
        esp_partition_subtype_t::ESP_PARTITION_SUBTYPE_APP_FACTORY;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_partition_subtype_t {
    ESP_PARTITION_SUBTYPE_APP_FACTORY = 0,
    ESP_PARTITION_SUBTYPE_APP_OTA_MIN = 16,
    ESP_PARTITION_SUBTYPE_APP_OTA_1 = 17,
    ESP_PARTITION_SUBTYPE_APP_OTA_2 = 18,
    ESP_PARTITION_SUBTYPE_APP_OTA_3 = 19,
    ESP_PARTITION_SUBTYPE_APP_OTA_4 = 20,
    ESP_PARTITION_SUBTYPE_APP_OTA_5 = 21,
    ESP_PARTITION_SUBTYPE_APP_OTA_6 = 22,
    ESP_PARTITION_SUBTYPE_APP_OTA_7 = 23,
    ESP_PARTITION_SUBTYPE_APP_OTA_8 = 24,
    ESP_PARTITION_SUBTYPE_APP_OTA_9 = 25,
    ESP_PARTITION_SUBTYPE_APP_OTA_10 = 26,
    ESP_PARTITION_SUBTYPE_APP_OTA_11 = 27,
    ESP_PARTITION_SUBTYPE_APP_OTA_12 = 28,
    ESP_PARTITION_SUBTYPE_APP_OTA_13 = 29,
    ESP_PARTITION_SUBTYPE_APP_OTA_14 = 30,
    ESP_PARTITION_SUBTYPE_APP_OTA_15 = 31,
    ESP_PARTITION_SUBTYPE_APP_OTA_MAX = 32,
    ESP_PARTITION_SUBTYPE_DATA_PHY = 1,
    ESP_PARTITION_SUBTYPE_DATA_NVS = 2,
    ESP_PARTITION_SUBTYPE_DATA_COREDUMP = 3,
    ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS = 4,
    ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM = 5,
    ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD = 128,
    ESP_PARTITION_SUBTYPE_DATA_FAT = 129,
    ESP_PARTITION_SUBTYPE_DATA_SPIFFS = 130,
    ESP_PARTITION_SUBTYPE_ANY = 255,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_partition_iterator_opaque_ {
    _unused: [u8; 0],
}
pub type esp_partition_iterator_t = *mut esp_partition_iterator_opaque_;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct esp_partition_t {
    pub flash_chip: *mut esp_flash_t,
    pub type_: esp_partition_type_t,
    pub subtype: esp_partition_subtype_t,
    pub address: u32,
    pub size: u32,
    pub label: [std::os::raw::c_char; 17usize],
    pub encrypted: bool,
}
impl Default for esp_partition_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn esp_partition_find(
        type_: esp_partition_type_t,
        subtype: esp_partition_subtype_t,
        label: *const std::os::raw::c_char,
    ) -> esp_partition_iterator_t;
}
extern "C" {
    pub fn esp_partition_find_first(
        type_: esp_partition_type_t,
        subtype: esp_partition_subtype_t,
        label: *const std::os::raw::c_char,
    ) -> *const esp_partition_t;
}
extern "C" {
    pub fn esp_partition_get(iterator: esp_partition_iterator_t) -> *const esp_partition_t;
}
extern "C" {
    pub fn esp_partition_next(iterator: esp_partition_iterator_t) -> esp_partition_iterator_t;
}
extern "C" {
    pub fn esp_partition_iterator_release(iterator: esp_partition_iterator_t);
}
extern "C" {
    pub fn esp_partition_verify(partition: *const esp_partition_t) -> *const esp_partition_t;
}
extern "C" {
    pub fn esp_partition_read(
        partition: *const esp_partition_t,
        src_offset: usize,
        dst: *mut std::os::raw::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_partition_write(
        partition: *const esp_partition_t,
        dst_offset: usize,
        src: *const std::os::raw::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_partition_erase_range(
        partition: *const esp_partition_t,
        offset: usize,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_partition_mmap(
        partition: *const esp_partition_t,
        offset: usize,
        size: usize,
        memory: spi_flash_mmap_memory_t,
        out_ptr: *mut *const std::os::raw::c_void,
        out_handle: *mut spi_flash_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_partition_get_sha256(
        partition: *const esp_partition_t,
        sha_256: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_partition_check_identity(
        partition_1: *const esp_partition_t,
        partition_2: *const esp_partition_t,
    ) -> bool;
}
extern "C" {
    pub fn esp_partition_register_external(
        flash_chip: *mut esp_flash_t,
        offset: usize,
        size: usize,
        label: *const std::os::raw::c_char,
        type_: esp_partition_type_t,
        subtype: esp_partition_subtype_t,
        out_partition: *mut *const esp_partition_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_partition_deregister_external(partition: *const esp_partition_t) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct nvs_sec_cfg_t {
    pub eky: [u8; 32usize],
    pub tky: [u8; 32usize],
}
extern "C" {
    pub fn nvs_flash_init() -> esp_err_t;
}
extern "C" {
    pub fn nvs_flash_init_partition(partition_label: *const std::os::raw::c_char) -> esp_err_t;
}
extern "C" {
    pub fn nvs_flash_deinit() -> esp_err_t;
}
extern "C" {
    pub fn nvs_flash_deinit_partition(partition_label: *const std::os::raw::c_char) -> esp_err_t;
}
extern "C" {
    pub fn nvs_flash_erase() -> esp_err_t;
}
extern "C" {
    pub fn nvs_flash_erase_partition(part_name: *const std::os::raw::c_char) -> esp_err_t;
}
extern "C" {
    pub fn nvs_flash_secure_init(cfg: *mut nvs_sec_cfg_t) -> esp_err_t;
}
extern "C" {
    pub fn nvs_flash_secure_init_partition(
        partition_label: *const std::os::raw::c_char,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_flash_generate_keys(
        partition: *const esp_partition_t,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_flash_read_security_cfg(
        partition: *const esp_partition_t,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
pub type esp_event_base_t = *const std::os::raw::c_char;
pub type esp_event_loop_handle_t = *mut std::os::raw::c_void;
pub type esp_event_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        event_handler_arg: *mut std::os::raw::c_void,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut std::os::raw::c_void,
    ),
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_interface_t {
    ESP_IF_WIFI_STA = 0,
    ESP_IF_WIFI_AP = 1,
    ESP_IF_ETH = 2,
    ESP_IF_MAX = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_mode_t {
    WIFI_MODE_NULL = 0,
    WIFI_MODE_STA = 1,
    WIFI_MODE_AP = 2,
    WIFI_MODE_APSTA = 3,
    WIFI_MODE_MAX = 4,
}
pub use self::esp_interface_t as wifi_interface_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_country_policy_t {
    WIFI_COUNTRY_POLICY_AUTO = 0,
    WIFI_COUNTRY_POLICY_MANUAL = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct wifi_country_t {
    pub cc: [std::os::raw::c_char; 3usize],
    pub schan: u8,
    pub nchan: u8,
    pub max_tx_power: i8,
    pub policy: wifi_country_policy_t,
}
impl Default for wifi_country_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_auth_mode_t {
    WIFI_AUTH_OPEN = 0,
    WIFI_AUTH_WEP = 1,
    WIFI_AUTH_WPA_PSK = 2,
    WIFI_AUTH_WPA2_PSK = 3,
    WIFI_AUTH_WPA_WPA2_PSK = 4,
    WIFI_AUTH_WPA2_ENTERPRISE = 5,
    WIFI_AUTH_MAX = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_err_reason_t {
    WIFI_REASON_UNSPECIFIED = 1,
    WIFI_REASON_AUTH_EXPIRE = 2,
    WIFI_REASON_AUTH_LEAVE = 3,
    WIFI_REASON_ASSOC_EXPIRE = 4,
    WIFI_REASON_ASSOC_TOOMANY = 5,
    WIFI_REASON_NOT_AUTHED = 6,
    WIFI_REASON_NOT_ASSOCED = 7,
    WIFI_REASON_ASSOC_LEAVE = 8,
    WIFI_REASON_ASSOC_NOT_AUTHED = 9,
    WIFI_REASON_DISASSOC_PWRCAP_BAD = 10,
    WIFI_REASON_DISASSOC_SUPCHAN_BAD = 11,
    WIFI_REASON_IE_INVALID = 13,
    WIFI_REASON_MIC_FAILURE = 14,
    WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
    WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT = 16,
    WIFI_REASON_IE_IN_4WAY_DIFFERS = 17,
    WIFI_REASON_GROUP_CIPHER_INVALID = 18,
    WIFI_REASON_PAIRWISE_CIPHER_INVALID = 19,
    WIFI_REASON_AKMP_INVALID = 20,
    WIFI_REASON_UNSUPP_RSN_IE_VERSION = 21,
    WIFI_REASON_INVALID_RSN_IE_CAP = 22,
    WIFI_REASON_802_1X_AUTH_FAILED = 23,
    WIFI_REASON_CIPHER_SUITE_REJECTED = 24,
    WIFI_REASON_BEACON_TIMEOUT = 200,
    WIFI_REASON_NO_AP_FOUND = 201,
    WIFI_REASON_AUTH_FAIL = 202,
    WIFI_REASON_ASSOC_FAIL = 203,
    WIFI_REASON_HANDSHAKE_TIMEOUT = 204,
    WIFI_REASON_CONNECTION_FAIL = 205,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_second_chan_t {
    WIFI_SECOND_CHAN_NONE = 0,
    WIFI_SECOND_CHAN_ABOVE = 1,
    WIFI_SECOND_CHAN_BELOW = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_scan_type_t {
    WIFI_SCAN_TYPE_ACTIVE = 0,
    WIFI_SCAN_TYPE_PASSIVE = 1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_active_scan_time_t {
    pub min: u32,
    pub max: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_scan_time_t {
    pub active: wifi_active_scan_time_t,
    pub passive: u32,
    _bindgen_union_align: [u32; 2usize],
}
impl Default for wifi_scan_time_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for wifi_scan_time_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "wifi_scan_time_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_config_t {
    pub ssid: *mut u8,
    pub bssid: *mut u8,
    pub channel: u8,
    pub show_hidden: bool,
    pub scan_type: wifi_scan_type_t,
    pub scan_time: wifi_scan_time_t,
}
impl Default for wifi_scan_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for wifi_scan_config_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "wifi_scan_config_t {{ ssid: {:?}, bssid: {:?}, channel: {:?}, show_hidden: {:?}, scan_type: {:?}, scan_time: {:?} }}" , self . ssid , self . bssid , self . channel , self . show_hidden , self . scan_type , self . scan_time )
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_cipher_type_t {
    WIFI_CIPHER_TYPE_NONE = 0,
    WIFI_CIPHER_TYPE_WEP40 = 1,
    WIFI_CIPHER_TYPE_WEP104 = 2,
    WIFI_CIPHER_TYPE_TKIP = 3,
    WIFI_CIPHER_TYPE_CCMP = 4,
    WIFI_CIPHER_TYPE_TKIP_CCMP = 5,
    WIFI_CIPHER_TYPE_UNKNOWN = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_ant_t {
    WIFI_ANT_ANT0 = 0,
    WIFI_ANT_ANT1 = 1,
    WIFI_ANT_MAX = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_record_t {
    pub bssid: [u8; 6usize],
    pub ssid: [u8; 33usize],
    pub primary: u8,
    pub second: wifi_second_chan_t,
    pub rssi: i8,
    pub authmode: wifi_auth_mode_t,
    pub pairwise_cipher: wifi_cipher_type_t,
    pub group_cipher: wifi_cipher_type_t,
    pub ant: wifi_ant_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub country: wifi_country_t,
}
impl Default for wifi_ap_record_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for wifi_ap_record_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "wifi_ap_record_t {{ bssid: {:?}, ssid: [...], primary: {:?}, second: {:?}, rssi: {:?}, authmode: {:?}, pairwise_cipher: {:?}, group_cipher: {:?}, ant: {:?}, phy_11b : {:?}, phy_11g : {:?}, phy_11n : {:?}, phy_lr : {:?}, wps : {:?}, reserved : {:?}, country: {:?} }}" , self . bssid , self . primary , self . second , self . rssi , self . authmode , self . pairwise_cipher , self . group_cipher , self . ant , self . phy_11b ( ) , self . phy_11g ( ) , self . phy_11n ( ) , self . phy_lr ( ) , self . wps ( ) , self . reserved ( ) , self . country )
    }
}
impl ::core::cmp::PartialEq for wifi_ap_record_t {
    fn eq(&self, other: &wifi_ap_record_t) -> bool {
        self.bssid == other.bssid
            && &self.ssid[..] == &other.ssid[..]
            && self.primary == other.primary
            && self.second == other.second
            && self.rssi == other.rssi
            && self.authmode == other.authmode
            && self.pairwise_cipher == other.pairwise_cipher
            && self.group_cipher == other.group_cipher
            && self.ant == other.ant
            && self.phy_11b() == other.phy_11b()
            && self.phy_11g() == other.phy_11g()
            && self.phy_11n() == other.phy_11n()
            && self.phy_lr() == other.phy_lr()
            && self.wps() == other.wps()
            && self.reserved() == other.reserved()
            && self.country == other.country
    }
}
impl wifi_ap_record_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        wps: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wps: u32 = unsafe { ::core::mem::transmute(wps) };
            wps as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_scan_method_t {
    WIFI_FAST_SCAN = 0,
    WIFI_ALL_CHANNEL_SCAN = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_sort_method_t {
    WIFI_CONNECT_AP_BY_SIGNAL = 0,
    WIFI_CONNECT_AP_BY_SECURITY = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct wifi_scan_threshold_t {
    pub rssi: i8,
    pub authmode: wifi_auth_mode_t,
}
impl Default for wifi_scan_threshold_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_ps_type_t {
    WIFI_PS_NONE = 0,
    WIFI_PS_MIN_MODEM = 1,
    WIFI_PS_MAX_MODEM = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_bandwidth_t {
    WIFI_BW_HT20 = 1,
    WIFI_BW_HT40 = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_config_t {
    pub ssid: [u8; 32usize],
    pub password: [u8; 64usize],
    pub ssid_len: u8,
    pub channel: u8,
    pub authmode: wifi_auth_mode_t,
    pub ssid_hidden: u8,
    pub max_connection: u8,
    pub beacon_interval: u16,
}
impl Default for wifi_ap_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for wifi_ap_config_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "wifi_ap_config_t {{ ssid: [...], password: [...], ssid_len: {:?}, channel: {:?}, authmode: {:?}, ssid_hidden: {:?}, max_connection: {:?}, beacon_interval: {:?} }}" , self . ssid_len , self . channel , self . authmode , self . ssid_hidden , self . max_connection , self . beacon_interval )
    }
}
impl ::core::cmp::PartialEq for wifi_ap_config_t {
    fn eq(&self, other: &wifi_ap_config_t) -> bool {
        self.ssid == other.ssid
            && &self.password[..] == &other.password[..]
            && self.ssid_len == other.ssid_len
            && self.channel == other.channel
            && self.authmode == other.authmode
            && self.ssid_hidden == other.ssid_hidden
            && self.max_connection == other.max_connection
            && self.beacon_interval == other.beacon_interval
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_config_t {
    pub ssid: [u8; 32usize],
    pub password: [u8; 64usize],
    pub scan_method: wifi_scan_method_t,
    pub bssid_set: bool,
    pub bssid: [u8; 6usize],
    pub channel: u8,
    pub listen_interval: u16,
    pub sort_method: wifi_sort_method_t,
    pub threshold: wifi_scan_threshold_t,
}
impl Default for wifi_sta_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for wifi_sta_config_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "wifi_sta_config_t {{ ssid: [...], password: [...], scan_method: {:?}, bssid_set: {:?}, bssid: {:?}, channel: {:?}, listen_interval: {:?}, sort_method: {:?}, threshold: {:?} }}" , self . scan_method , self . bssid_set , self . bssid , self . channel , self . listen_interval , self . sort_method , self . threshold )
    }
}
impl ::core::cmp::PartialEq for wifi_sta_config_t {
    fn eq(&self, other: &wifi_sta_config_t) -> bool {
        self.ssid == other.ssid
            && &self.password[..] == &other.password[..]
            && self.scan_method == other.scan_method
            && self.bssid_set == other.bssid_set
            && self.bssid == other.bssid
            && self.channel == other.channel
            && self.listen_interval == other.listen_interval
            && self.sort_method == other.sort_method
            && self.threshold == other.threshold
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_config_t {
    pub ap: wifi_ap_config_t,
    pub sta: wifi_sta_config_t,
    _bindgen_union_align: [u32; 31usize],
}
impl Default for wifi_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for wifi_config_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "wifi_config_t {{ union }}")
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_sta_info_t {
    pub mac: [u8; 6usize],
    pub rssi: i8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl wifi_sta_info_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_sta_list_t {
    pub sta: [wifi_sta_info_t; 10usize],
    pub num: std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_storage_t {
    WIFI_STORAGE_FLASH = 0,
    WIFI_STORAGE_RAM = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_vendor_ie_type_t {
    WIFI_VND_IE_TYPE_BEACON = 0,
    WIFI_VND_IE_TYPE_PROBE_REQ = 1,
    WIFI_VND_IE_TYPE_PROBE_RESP = 2,
    WIFI_VND_IE_TYPE_ASSOC_REQ = 3,
    WIFI_VND_IE_TYPE_ASSOC_RESP = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_vendor_ie_id_t {
    WIFI_VND_IE_ID_0 = 0,
    WIFI_VND_IE_ID_1 = 1,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct vendor_ie_data_t {
    pub element_id: u8,
    pub length: u8,
    pub vendor_oui: [u8; 3usize],
    pub vendor_oui_type: u8,
    pub payload: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_pkt_rx_ctrl_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 28usize], u32>,
}
impl wifi_pkt_rx_ctrl_t {
    #[inline]
    pub fn rssi(&self) -> std::os::raw::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rssi(&mut self, val: std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rate(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rate(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_mode(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sig_mode(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_mcs(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn cwb(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cwb(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smoothing(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_smoothing(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_sounding(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_sounding(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aggregation(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aggregation(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stbc(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fec_coding(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fec_coding(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgi(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sgi(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn noise_floor(&self) -> std::os::raw::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_noise_floor(&mut self, val: std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ampdu_cnt(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ampdu_cnt(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(80usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(80usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn secondary_channel(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(84usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_secondary_channel(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(84usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(96usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn ant(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(191usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ant(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(191usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_len(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(192usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sig_len(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(192usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_state(&self) -> std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(216usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rx_state(&mut self, val: std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(216usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rssi: std::os::raw::c_int,
        rate: std::os::raw::c_uint,
        sig_mode: std::os::raw::c_uint,
        mcs: std::os::raw::c_uint,
        cwb: std::os::raw::c_uint,
        smoothing: std::os::raw::c_uint,
        not_sounding: std::os::raw::c_uint,
        aggregation: std::os::raw::c_uint,
        stbc: std::os::raw::c_uint,
        fec_coding: std::os::raw::c_uint,
        sgi: std::os::raw::c_uint,
        noise_floor: std::os::raw::c_int,
        ampdu_cnt: std::os::raw::c_uint,
        channel: std::os::raw::c_uint,
        secondary_channel: std::os::raw::c_uint,
        timestamp: std::os::raw::c_uint,
        ant: std::os::raw::c_uint,
        sig_len: std::os::raw::c_uint,
        rx_state: std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 28usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 28usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rssi: u32 = unsafe { ::core::mem::transmute(rssi) };
            rssi as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let rate: u32 = unsafe { ::core::mem::transmute(rate) };
            rate as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let sig_mode: u32 = unsafe { ::core::mem::transmute(sig_mode) };
            sig_mode as u64
        });
        __bindgen_bitfield_unit.set(32usize, 7u8, {
            let mcs: u32 = unsafe { ::core::mem::transmute(mcs) };
            mcs as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let cwb: u32 = unsafe { ::core::mem::transmute(cwb) };
            cwb as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let smoothing: u32 = unsafe { ::core::mem::transmute(smoothing) };
            smoothing as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let not_sounding: u32 = unsafe { ::core::mem::transmute(not_sounding) };
            not_sounding as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let aggregation: u32 = unsafe { ::core::mem::transmute(aggregation) };
            aggregation as u64
        });
        __bindgen_bitfield_unit.set(60usize, 2u8, {
            let stbc: u32 = unsafe { ::core::mem::transmute(stbc) };
            stbc as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let fec_coding: u32 = unsafe { ::core::mem::transmute(fec_coding) };
            fec_coding as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sgi: u32 = unsafe { ::core::mem::transmute(sgi) };
            sgi as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let noise_floor: u32 = unsafe { ::core::mem::transmute(noise_floor) };
            noise_floor as u64
        });
        __bindgen_bitfield_unit.set(72usize, 8u8, {
            let ampdu_cnt: u32 = unsafe { ::core::mem::transmute(ampdu_cnt) };
            ampdu_cnt as u64
        });
        __bindgen_bitfield_unit.set(80usize, 4u8, {
            let channel: u32 = unsafe { ::core::mem::transmute(channel) };
            channel as u64
        });
        __bindgen_bitfield_unit.set(84usize, 4u8, {
            let secondary_channel: u32 = unsafe { ::core::mem::transmute(secondary_channel) };
            secondary_channel as u64
        });
        __bindgen_bitfield_unit.set(96usize, 32u8, {
            let timestamp: u32 = unsafe { ::core::mem::transmute(timestamp) };
            timestamp as u64
        });
        __bindgen_bitfield_unit.set(191usize, 1u8, {
            let ant: u32 = unsafe { ::core::mem::transmute(ant) };
            ant as u64
        });
        __bindgen_bitfield_unit.set(192usize, 12u8, {
            let sig_len: u32 = unsafe { ::core::mem::transmute(sig_len) };
            sig_len as u64
        });
        __bindgen_bitfield_unit.set(216usize, 8u8, {
            let rx_state: u32 = unsafe { ::core::mem::transmute(rx_state) };
            rx_state as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct wifi_promiscuous_pkt_t {
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    pub payload: __IncompleteArrayField<u8>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_promiscuous_pkt_type_t {
    WIFI_PKT_MGMT = 0,
    WIFI_PKT_CTRL = 1,
    WIFI_PKT_DATA = 2,
    WIFI_PKT_MISC = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_promiscuous_filter_t {
    pub filter_mask: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_csi_config_t {
    pub lltf_en: bool,
    pub htltf_en: bool,
    pub stbc_htltf2_en: bool,
    pub ltf_merge_en: bool,
    pub channel_filter_en: bool,
    pub manu_scale: bool,
    pub shift: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct wifi_csi_info_t {
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    pub mac: [u8; 6usize],
    pub first_word_invalid: bool,
    pub buf: *mut i8,
    pub len: u16,
}
impl Default for wifi_csi_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_ant_gpio_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl wifi_ant_gpio_t {
    #[inline]
    pub fn gpio_select(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_select(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_num(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_num(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        gpio_select: u8,
        gpio_num: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gpio_select: u8 = unsafe { ::core::mem::transmute(gpio_select) };
            gpio_select as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let gpio_num: u8 = unsafe { ::core::mem::transmute(gpio_num) };
            gpio_num as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_ant_gpio_config_t {
    pub gpio_cfg: [wifi_ant_gpio_t; 4usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_ant_mode_t {
    WIFI_ANT_MODE_ANT0 = 0,
    WIFI_ANT_MODE_ANT1 = 1,
    WIFI_ANT_MODE_AUTO = 2,
    WIFI_ANT_MODE_MAX = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct wifi_ant_config_t {
    pub rx_ant_mode: wifi_ant_mode_t,
    pub rx_ant_default: wifi_ant_t,
    pub tx_ant_mode: wifi_ant_mode_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for wifi_ant_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl wifi_ant_config_t {
    #[inline]
    pub fn enabled_ant0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled_ant1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled_ant0: u8,
        enabled_ant1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let enabled_ant0: u8 = unsafe { ::core::mem::transmute(enabled_ant0) };
            enabled_ant0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let enabled_ant1: u8 = unsafe { ::core::mem::transmute(enabled_ant1) };
            enabled_ant1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_phy_rate_t {
    WIFI_PHY_RATE_1M_L = 0,
    WIFI_PHY_RATE_2M_L = 1,
    WIFI_PHY_RATE_5M_L = 2,
    WIFI_PHY_RATE_11M_L = 3,
    WIFI_PHY_RATE_2M_S = 5,
    WIFI_PHY_RATE_5M_S = 6,
    WIFI_PHY_RATE_11M_S = 7,
    WIFI_PHY_RATE_48M = 8,
    WIFI_PHY_RATE_24M = 9,
    WIFI_PHY_RATE_12M = 10,
    WIFI_PHY_RATE_6M = 11,
    WIFI_PHY_RATE_54M = 12,
    WIFI_PHY_RATE_36M = 13,
    WIFI_PHY_RATE_18M = 14,
    WIFI_PHY_RATE_9M = 15,
    WIFI_PHY_RATE_MCS0_LGI = 16,
    WIFI_PHY_RATE_MCS1_LGI = 17,
    WIFI_PHY_RATE_MCS2_LGI = 18,
    WIFI_PHY_RATE_MCS3_LGI = 19,
    WIFI_PHY_RATE_MCS4_LGI = 20,
    WIFI_PHY_RATE_MCS5_LGI = 21,
    WIFI_PHY_RATE_MCS6_LGI = 22,
    WIFI_PHY_RATE_MCS7_LGI = 23,
    WIFI_PHY_RATE_MCS0_SGI = 24,
    WIFI_PHY_RATE_MCS1_SGI = 25,
    WIFI_PHY_RATE_MCS2_SGI = 26,
    WIFI_PHY_RATE_MCS3_SGI = 27,
    WIFI_PHY_RATE_MCS4_SGI = 28,
    WIFI_PHY_RATE_MCS5_SGI = 29,
    WIFI_PHY_RATE_MCS6_SGI = 30,
    WIFI_PHY_RATE_MCS7_SGI = 31,
    WIFI_PHY_RATE_LORA_250K = 41,
    WIFI_PHY_RATE_LORA_500K = 42,
    WIFI_PHY_RATE_MAX = 43,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_event_t {
    WIFI_EVENT_WIFI_READY = 0,
    WIFI_EVENT_SCAN_DONE = 1,
    WIFI_EVENT_STA_START = 2,
    WIFI_EVENT_STA_STOP = 3,
    WIFI_EVENT_STA_CONNECTED = 4,
    WIFI_EVENT_STA_DISCONNECTED = 5,
    WIFI_EVENT_STA_AUTHMODE_CHANGE = 6,
    WIFI_EVENT_STA_WPS_ER_SUCCESS = 7,
    WIFI_EVENT_STA_WPS_ER_FAILED = 8,
    WIFI_EVENT_STA_WPS_ER_TIMEOUT = 9,
    WIFI_EVENT_STA_WPS_ER_PIN = 10,
    WIFI_EVENT_STA_WPS_ER_PBC_OVERLAP = 11,
    WIFI_EVENT_AP_START = 12,
    WIFI_EVENT_AP_STOP = 13,
    WIFI_EVENT_AP_STACONNECTED = 14,
    WIFI_EVENT_AP_STADISCONNECTED = 15,
    WIFI_EVENT_AP_PROBEREQRECVED = 16,
}
extern "C" {
    pub static mut WIFI_EVENT: esp_event_base_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_event_sta_scan_done_t {
    pub status: u32,
    pub number: u8,
    pub scan_id: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct wifi_event_sta_connected_t {
    pub ssid: [u8; 32usize],
    pub ssid_len: u8,
    pub bssid: [u8; 6usize],
    pub channel: u8,
    pub authmode: wifi_auth_mode_t,
}
impl Default for wifi_event_sta_connected_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_event_sta_disconnected_t {
    pub ssid: [u8; 32usize],
    pub ssid_len: u8,
    pub bssid: [u8; 6usize],
    pub reason: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct wifi_event_sta_authmode_change_t {
    pub old_mode: wifi_auth_mode_t,
    pub new_mode: wifi_auth_mode_t,
}
impl Default for wifi_event_sta_authmode_change_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_event_sta_wps_er_pin_t {
    pub pin_code: [u8; 8usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum wifi_event_sta_wps_fail_reason_t {
    WPS_FAIL_REASON_NORMAL = 0,
    WPS_FAIL_REASON_RECV_M2D = 1,
    WPS_FAIL_REASON_MAX = 2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_event_ap_staconnected_t {
    pub mac: [u8; 6usize],
    pub aid: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_event_ap_stadisconnected_t {
    pub mac: [u8; 6usize],
    pub aid: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_event_ap_probe_req_rx_t {
    pub rssi: std::os::raw::c_int,
    pub mac: [u8; 6usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct dhcps_state {
    pub state: s16_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dhcps_msg {
    pub op: u8_t,
    pub htype: u8_t,
    pub hlen: u8_t,
    pub hops: u8_t,
    pub xid: [u8_t; 4usize],
    pub secs: u16_t,
    pub flags: u16_t,
    pub ciaddr: [u8_t; 4usize],
    pub yiaddr: [u8_t; 4usize],
    pub siaddr: [u8_t; 4usize],
    pub giaddr: [u8_t; 4usize],
    pub chaddr: [u8_t; 16usize],
    pub sname: [u8_t; 64usize],
    pub file: [u8_t; 128usize],
    pub options: [u8_t; 312usize],
}
impl Default for dhcps_msg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for dhcps_msg {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "dhcps_msg {{ op: {:?}, htype: {:?}, hlen: {:?}, hops: {:?}, xid: {:?}, secs: {:?}, flags: {:?}, ciaddr: {:?}, yiaddr: {:?}, siaddr: {:?}, giaddr: {:?}, chaddr: {:?}, sname: [...], file: [...], options: [...] }}" , self . op , self . htype , self . hlen , self . hops , self . xid , self . secs , self . flags , self . ciaddr , self . yiaddr , self . siaddr , self . giaddr , self . chaddr )
    }
}
impl ::core::cmp::PartialEq for dhcps_msg {
    fn eq(&self, other: &dhcps_msg) -> bool {
        self.op == other.op
            && self.htype == other.htype
            && self.hlen == other.hlen
            && self.hops == other.hops
            && self.xid == other.xid
            && self.secs == other.secs
            && self.flags == other.flags
            && self.ciaddr == other.ciaddr
            && self.yiaddr == other.yiaddr
            && self.siaddr == other.siaddr
            && self.giaddr == other.giaddr
            && self.chaddr == other.chaddr
            && &self.sname[..] == &other.sname[..]
            && &self.file[..] == &other.file[..]
            && &self.options[..] == &other.options[..]
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct dhcps_lease_t {
    pub enable: bool,
    pub start_ip: ip4_addr_t,
    pub end_ip: ip4_addr_t,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dhcps_offer_option {
    OFFER_START = 0,
    OFFER_ROUTER = 1,
    OFFER_DNS = 2,
    OFFER_END = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct dhcps_pool {
    pub ip: ip4_addr_t,
    pub mac: [u8_t; 6usize],
    pub lease_timer: u32_t,
}
pub type dhcps_time_t = u32_t;
pub type dhcps_offer_t = u8_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct dhcps_options_t {
    pub dhcps_offer: dhcps_offer_t,
    pub dhcps_dns: dhcps_offer_t,
    pub dhcps_time: dhcps_time_t,
    pub dhcps_poll: dhcps_lease_t,
}
pub type dhcps_cb_t = ::core::option::Option<unsafe extern "C" fn(client_ip: *mut [u8_t; 4usize])>;
extern "C" {
    pub fn dhcps_start(netif: *mut netif, ip: ip4_addr_t);
}
extern "C" {
    pub fn dhcps_stop(netif: *mut netif);
}
extern "C" {
    pub fn dhcps_option_info(op_id: u8_t, opt_len: u32_t) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn dhcps_set_option_info(op_id: u8_t, opt_info: *mut std::os::raw::c_void, opt_len: u32_t);
}
extern "C" {
    pub fn dhcp_search_ip_on_mac(mac: *mut u8_t, ip: *mut ip4_addr_t) -> bool;
}
extern "C" {
    pub fn dhcps_dns_setserver(dnsserver: *const ip_addr_t);
}
extern "C" {
    pub fn dhcps_dns_getserver() -> ip4_addr_t;
}
extern "C" {
    pub fn dhcps_set_new_lease_cb(cb: dhcps_cb_t);
}
pub type tcpip_adapter_dhcps_lease_t = dhcps_lease_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct tcpip_adapter_ip_info_t {
    pub ip: ip4_addr_t,
    pub netmask: ip4_addr_t,
    pub gw: ip4_addr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct tcpip_adapter_ip6_info_t {
    pub ip: ip6_addr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct tcpip_adapter_sta_info_t {
    pub mac: [u8; 6usize],
    pub ip: ip4_addr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct tcpip_adapter_sta_list_t {
    pub sta: [tcpip_adapter_sta_info_t; 10usize],
    pub num: std::os::raw::c_int,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum tcpip_adapter_if_t {
    TCPIP_ADAPTER_IF_STA = 0,
    TCPIP_ADAPTER_IF_AP = 1,
    TCPIP_ADAPTER_IF_ETH = 2,
    TCPIP_ADAPTER_IF_TEST = 3,
    TCPIP_ADAPTER_IF_MAX = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum tcpip_adapter_dns_type_t {
    TCPIP_ADAPTER_DNS_MAIN = 0,
    TCPIP_ADAPTER_DNS_BACKUP = 1,
    TCPIP_ADAPTER_DNS_FALLBACK = 2,
    TCPIP_ADAPTER_DNS_MAX = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcpip_adapter_dns_info_t {
    pub ip: ip_addr_t,
}
impl Default for tcpip_adapter_dns_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for tcpip_adapter_dns_info_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "tcpip_adapter_dns_info_t {{ ip: {:?} }}", self.ip)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum tcpip_adapter_dhcp_status_t {
    TCPIP_ADAPTER_DHCP_INIT = 0,
    TCPIP_ADAPTER_DHCP_STARTED = 1,
    TCPIP_ADAPTER_DHCP_STOPPED = 2,
    TCPIP_ADAPTER_DHCP_STATUS_MAX = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum tcpip_adapter_dhcp_option_mode_t {
    TCPIP_ADAPTER_OP_START = 0,
    TCPIP_ADAPTER_OP_SET = 1,
    TCPIP_ADAPTER_OP_GET = 2,
    TCPIP_ADAPTER_OP_MAX = 3,
}
pub use self::tcpip_adapter_dhcp_option_mode_t as tcpip_adapter_option_mode_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum tcpip_adapter_dhcp_option_id_t {
    TCPIP_ADAPTER_DOMAIN_NAME_SERVER = 6,
    TCPIP_ADAPTER_ROUTER_SOLICITATION_ADDRESS = 32,
    TCPIP_ADAPTER_REQUESTED_IP_ADDRESS = 50,
    TCPIP_ADAPTER_IP_ADDRESS_LEASE_TIME = 51,
    TCPIP_ADAPTER_IP_REQUEST_RETRY_TIME = 52,
}
pub use self::tcpip_adapter_dhcp_option_id_t as tcpip_adapter_option_id_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ip_event_t {
    IP_EVENT_STA_GOT_IP = 0,
    IP_EVENT_STA_LOST_IP = 1,
    IP_EVENT_AP_STAIPASSIGNED = 2,
    IP_EVENT_GOT_IP6 = 3,
    IP_EVENT_ETH_GOT_IP = 4,
}
extern "C" {
    pub static mut IP_EVENT: esp_event_base_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ip_event_got_ip_t {
    pub if_index: tcpip_adapter_if_t,
    pub ip_info: tcpip_adapter_ip_info_t,
    pub ip_changed: bool,
}
impl Default for ip_event_got_ip_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ip_event_got_ip6_t {
    pub if_index: tcpip_adapter_if_t,
    pub ip6_info: tcpip_adapter_ip6_info_t,
}
impl Default for ip_event_got_ip6_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct ip_event_ap_staipassigned_t {
    pub ip: ip4_addr_t,
}
extern "C" {
    pub fn tcpip_adapter_init();
}
extern "C" {
    pub fn tcpip_adapter_eth_start(
        mac: *mut u8,
        ip_info: *mut tcpip_adapter_ip_info_t,
        args: *mut std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_sta_start(
        mac: *mut u8,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_ap_start(mac: *mut u8, ip_info: *mut tcpip_adapter_ip_info_t)
        -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_stop(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_up(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_down(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_get_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_set_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *const tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_set_dns_info(
        tcpip_if: tcpip_adapter_if_t,
        type_: tcpip_adapter_dns_type_t,
        dns: *mut tcpip_adapter_dns_info_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_get_dns_info(
        tcpip_if: tcpip_adapter_if_t,
        type_: tcpip_adapter_dns_type_t,
        dns: *mut tcpip_adapter_dns_info_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_get_old_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_set_old_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *const tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_create_ip6_linklocal(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_get_ip6_linklocal(
        tcpip_if: tcpip_adapter_if_t,
        if_ip6: *mut ip6_addr_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_dhcps_get_status(
        tcpip_if: tcpip_adapter_if_t,
        status: *mut tcpip_adapter_dhcp_status_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_dhcps_option(
        opt_op: tcpip_adapter_dhcp_option_mode_t,
        opt_id: tcpip_adapter_dhcp_option_id_t,
        opt_val: *mut std::os::raw::c_void,
        opt_len: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_dhcps_start(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_dhcps_stop(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_dhcpc_get_status(
        tcpip_if: tcpip_adapter_if_t,
        status: *mut tcpip_adapter_dhcp_status_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_dhcpc_option(
        opt_op: tcpip_adapter_dhcp_option_mode_t,
        opt_id: tcpip_adapter_dhcp_option_id_t,
        opt_val: *mut std::os::raw::c_void,
        opt_len: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_dhcpc_start(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_dhcpc_stop(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_eth_input(
        buffer: *mut std::os::raw::c_void,
        len: u16,
        eb: *mut std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_sta_input(
        buffer: *mut std::os::raw::c_void,
        len: u16,
        eb: *mut std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_ap_input(
        buffer: *mut std::os::raw::c_void,
        len: u16,
        eb: *mut std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_get_esp_if(dev: *mut std::os::raw::c_void) -> esp_interface_t;
}
extern "C" {
    pub fn tcpip_adapter_get_sta_list(
        wifi_sta_list: *const wifi_sta_list_t,
        tcpip_sta_list: *mut tcpip_adapter_sta_list_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_set_hostname(
        tcpip_if: tcpip_adapter_if_t,
        hostname: *const std::os::raw::c_char,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_get_hostname(
        tcpip_if: tcpip_adapter_if_t,
        hostname: *mut *const std::os::raw::c_char,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_get_netif(
        tcpip_if: tcpip_adapter_if_t,
        netif: *mut *mut std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_is_netif_up(tcpip_if: tcpip_adapter_if_t) -> bool;
}
extern "C" {
    pub fn tcpip_adapter_test_start(
        mac: *mut u8,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_set_default_eth_handlers() -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_clear_default_eth_handlers() -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_set_default_wifi_handlers() -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_clear_default_wifi_handlers() -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_get_netif_index(tcpip_if: tcpip_adapter_if_t) -> std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum system_event_id_t {
    SYSTEM_EVENT_WIFI_READY = 0,
    SYSTEM_EVENT_SCAN_DONE = 1,
    SYSTEM_EVENT_STA_START = 2,
    SYSTEM_EVENT_STA_STOP = 3,
    SYSTEM_EVENT_STA_CONNECTED = 4,
    SYSTEM_EVENT_STA_DISCONNECTED = 5,
    SYSTEM_EVENT_STA_AUTHMODE_CHANGE = 6,
    SYSTEM_EVENT_STA_GOT_IP = 7,
    SYSTEM_EVENT_STA_LOST_IP = 8,
    SYSTEM_EVENT_STA_WPS_ER_SUCCESS = 9,
    SYSTEM_EVENT_STA_WPS_ER_FAILED = 10,
    SYSTEM_EVENT_STA_WPS_ER_TIMEOUT = 11,
    SYSTEM_EVENT_STA_WPS_ER_PIN = 12,
    SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP = 13,
    SYSTEM_EVENT_AP_START = 14,
    SYSTEM_EVENT_AP_STOP = 15,
    SYSTEM_EVENT_AP_STACONNECTED = 16,
    SYSTEM_EVENT_AP_STADISCONNECTED = 17,
    SYSTEM_EVENT_AP_STAIPASSIGNED = 18,
    SYSTEM_EVENT_AP_PROBEREQRECVED = 19,
    SYSTEM_EVENT_GOT_IP6 = 20,
    SYSTEM_EVENT_ETH_START = 21,
    SYSTEM_EVENT_ETH_STOP = 22,
    SYSTEM_EVENT_ETH_CONNECTED = 23,
    SYSTEM_EVENT_ETH_DISCONNECTED = 24,
    SYSTEM_EVENT_ETH_GOT_IP = 25,
    SYSTEM_EVENT_MAX = 26,
}
pub use self::wifi_event_sta_wps_fail_reason_t as system_event_sta_wps_fail_reason_t;
pub type system_event_sta_scan_done_t = wifi_event_sta_scan_done_t;
pub type system_event_sta_connected_t = wifi_event_sta_connected_t;
pub type system_event_sta_disconnected_t = wifi_event_sta_disconnected_t;
pub type system_event_sta_authmode_change_t = wifi_event_sta_authmode_change_t;
pub type system_event_sta_wps_er_pin_t = wifi_event_sta_wps_er_pin_t;
pub type system_event_ap_staconnected_t = wifi_event_ap_staconnected_t;
pub type system_event_ap_stadisconnected_t = wifi_event_ap_stadisconnected_t;
pub type system_event_ap_probe_req_rx_t = wifi_event_ap_probe_req_rx_t;
pub type system_event_ap_staipassigned_t = ip_event_ap_staipassigned_t;
pub type system_event_sta_got_ip_t = ip_event_got_ip_t;
pub type system_event_got_ip6_t = ip_event_got_ip6_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union system_event_info_t {
    pub connected: system_event_sta_connected_t,
    pub disconnected: system_event_sta_disconnected_t,
    pub scan_done: system_event_sta_scan_done_t,
    pub auth_change: system_event_sta_authmode_change_t,
    pub got_ip: system_event_sta_got_ip_t,
    pub sta_er_pin: system_event_sta_wps_er_pin_t,
    pub sta_er_fail_reason: system_event_sta_wps_fail_reason_t,
    pub sta_connected: system_event_ap_staconnected_t,
    pub sta_disconnected: system_event_ap_stadisconnected_t,
    pub ap_probereqrecved: system_event_ap_probe_req_rx_t,
    pub ap_staipassigned: system_event_ap_staipassigned_t,
    pub got_ip6: system_event_got_ip6_t,
    _bindgen_union_align: [u32; 11usize],
}
impl Default for system_event_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for system_event_info_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "system_event_info_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_event_t {
    pub event_id: system_event_id_t,
    pub event_info: system_event_info_t,
}
impl Default for system_event_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for system_event_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "system_event_t {{ event_id: {:?}, event_info: {:?} }}",
            self.event_id, self.event_info
        )
    }
}
pub type system_event_handler_t =
    ::core::option::Option<unsafe extern "C" fn(event: *mut system_event_t) -> esp_err_t>;
extern "C" {
    pub fn esp_event_send(event: *mut system_event_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_process_default(event: *mut system_event_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_set_default_eth_handlers();
}
extern "C" {
    pub fn esp_event_set_default_wifi_handlers();
}
pub type system_event_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut std::os::raw::c_void, event: *mut system_event_t) -> esp_err_t,
>;
extern "C" {
    pub fn esp_event_loop_init(cb: system_event_cb_t, ctx: *mut std::os::raw::c_void) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_loop_set_cb(
        cb: system_event_cb_t,
        ctx: *mut std::os::raw::c_void,
    ) -> system_event_cb_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct esp_event_loop_args_t {
    pub queue_size: i32,
    pub task_name: *const std::os::raw::c_char,
    pub task_priority: UBaseType_t,
    pub task_stack_size: u32,
    pub task_core_id: BaseType_t,
}
impl Default for esp_event_loop_args_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn esp_event_loop_create(
        event_loop_args: *const esp_event_loop_args_t,
        event_loop: *mut esp_event_loop_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_loop_delete(event_loop: esp_event_loop_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_loop_create_default() -> esp_err_t;
}
extern "C" {
    pub fn esp_event_loop_delete_default() -> esp_err_t;
}
extern "C" {
    pub fn esp_event_loop_run(
        event_loop: esp_event_loop_handle_t,
        ticks_to_run: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_handler_register(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_handler_register_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_handler_unregister(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_handler_unregister_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_post(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut std::os::raw::c_void,
        event_data_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_post_to(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut std::os::raw::c_void,
        event_data_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_isr_post(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut std::os::raw::c_void,
        event_data_size: usize,
        task_unblocked: *mut BaseType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_isr_post_to(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut std::os::raw::c_void,
        event_data_size: usize,
        task_unblocked: *mut BaseType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_event_dump(file: *mut FILE) -> esp_err_t;
}
extern "C" {
    pub fn esp_int_wdt_init();
}
extern "C" {
    pub fn esp_int_wdt_cpu_init();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_log_level_t {
    ESP_LOG_NONE = 0,
    ESP_LOG_ERROR = 1,
    ESP_LOG_WARN = 2,
    ESP_LOG_INFO = 3,
    ESP_LOG_DEBUG = 4,
    ESP_LOG_VERBOSE = 5,
}
pub type vprintf_like_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const std::os::raw::c_char, arg2: va_list) -> std::os::raw::c_int,
>;
extern "C" {
    pub fn esp_log_level_set(tag: *const std::os::raw::c_char, level: esp_log_level_t);
}
extern "C" {
    pub fn esp_log_set_vprintf(func: vprintf_like_t) -> vprintf_like_t;
}
extern "C" {
    pub fn esp_log_timestamp() -> u32;
}
extern "C" {
    pub fn esp_log_early_timestamp() -> u32;
}
extern "C" {
    pub fn esp_log_write(
        level: esp_log_level_t,
        tag: *const std::os::raw::c_char,
        format: *const std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn esp_log_buffer_hex_internal(
        tag: *const std::os::raw::c_char,
        buffer: *const std::os::raw::c_void,
        buff_len: u16,
        level: esp_log_level_t,
    );
}
extern "C" {
    pub fn esp_log_buffer_char_internal(
        tag: *const std::os::raw::c_char,
        buffer: *const std::os::raw::c_void,
        buff_len: u16,
        level: esp_log_level_t,
    );
}
extern "C" {
    pub fn esp_log_buffer_hexdump_internal(
        tag: *const std::os::raw::c_char,
        buffer: *const std::os::raw::c_void,
        buff_len: u16,
        log_level: esp_log_level_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct esp_pthread_cfg_t {
    pub stack_size: usize,
    pub prio: usize,
    pub inherit_cfg: bool,
    pub thread_name: *const std::os::raw::c_char,
    pub pin_to_core: std::os::raw::c_int,
}
impl Default for esp_pthread_cfg_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn esp_pthread_get_default_config() -> esp_pthread_cfg_t;
}
extern "C" {
    pub fn esp_pthread_set_cfg(cfg: *const esp_pthread_cfg_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_pthread_get_cfg(p: *mut esp_pthread_cfg_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_task_wdt_init(timeout: u32, panic: bool) -> esp_err_t;
}
extern "C" {
    pub fn esp_task_wdt_deinit() -> esp_err_t;
}
extern "C" {
    pub fn esp_task_wdt_add(handle: TaskHandle_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_task_wdt_reset() -> esp_err_t;
}
extern "C" {
    pub fn esp_task_wdt_delete(handle: TaskHandle_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_task_wdt_status(handle: TaskHandle_t) -> esp_err_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_crypto_hash_alg_t {
    ESP_CRYPTO_HASH_ALG_MD5 = 0,
    ESP_CRYPTO_HASH_ALG_SHA1 = 1,
    ESP_CRYPTO_HASH_ALG_HMAC_MD5 = 2,
    ESP_CRYPTO_HASH_ALG_HMAC_SHA1 = 3,
    ESP_CRYPTO_HASH_ALG_SHA256 = 4,
    ESP_CRYPTO_HASH_ALG_HMAC_SHA256 = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum esp_crypto_cipher_alg_t {
    ESP_CRYPTO_CIPHER_NULL = 0,
    ESP_CRYPTO_CIPHER_ALG_AES = 1,
    ESP_CRYPTO_CIPHER_ALG_3DES = 2,
    ESP_CRYPTO_CIPHER_ALG_DES = 3,
    ESP_CRYPTO_CIPHER_ALG_RC2 = 4,
    ESP_CRYPTO_CIPHER_ALG_RC4 = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_hash {
    _unused: [u8; 0],
}
pub type esp_crypto_hash_t = crypto_hash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_cipher {
    _unused: [u8; 0],
}
pub type esp_crypto_cipher_t = crypto_cipher;
pub type esp_aes_128_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        iv: *const std::os::raw::c_uchar,
        data: *mut std::os::raw::c_uchar,
        data_len: std::os::raw::c_int,
    ) -> std::os::raw::c_int,
>;
pub type esp_aes_128_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        iv: *const std::os::raw::c_uchar,
        data: *mut std::os::raw::c_uchar,
        data_len: std::os::raw::c_int,
    ) -> std::os::raw::c_int,
>;
pub type esp_aes_wrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const std::os::raw::c_uchar,
        n: std::os::raw::c_int,
        plain: *const std::os::raw::c_uchar,
        cipher: *mut std::os::raw::c_uchar,
    ) -> std::os::raw::c_int,
>;
pub type esp_aes_unwrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const std::os::raw::c_uchar,
        n: std::os::raw::c_int,
        cipher: *const std::os::raw::c_uchar,
        plain: *mut std::os::raw::c_uchar,
    ) -> std::os::raw::c_int,
>;
pub type esp_hmac_sha256_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        key_len: std::os::raw::c_int,
        num_elem: std::os::raw::c_int,
        addr: *mut [*const std::os::raw::c_uchar; 0usize],
        len: *const std::os::raw::c_int,
        mac: *mut std::os::raw::c_uchar,
    ),
>;
pub type esp_sha256_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        key_len: std::os::raw::c_int,
        label: *const std::os::raw::c_char,
        data: *const std::os::raw::c_uchar,
        data_len: std::os::raw::c_int,
        buf: *mut std::os::raw::c_uchar,
        buf_len: std::os::raw::c_int,
    ),
>;
pub type esp_hmac_md5_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        key_len: std::os::raw::c_uint,
        data: *const std::os::raw::c_uchar,
        data_len: std::os::raw::c_uint,
        mac: *mut std::os::raw::c_uchar,
    ) -> std::os::raw::c_int,
>;
pub type esp_hmac_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        key_len: std::os::raw::c_uint,
        num_elem: std::os::raw::c_uint,
        addr: *mut [*const std::os::raw::c_uchar; 0usize],
        len: *const std::os::raw::c_uint,
        mac: *mut std::os::raw::c_uchar,
    ) -> std::os::raw::c_int,
>;
pub type esp_hmac_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        key_len: std::os::raw::c_uint,
        data: *const std::os::raw::c_uchar,
        data_len: std::os::raw::c_uint,
        mac: *mut std::os::raw::c_uchar,
    ) -> std::os::raw::c_int,
>;
pub type esp_hmac_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        key_len: std::os::raw::c_uint,
        num_elem: std::os::raw::c_uint,
        addr: *mut [*const std::os::raw::c_uchar; 0usize],
        len: *const std::os::raw::c_uint,
        mac: *mut std::os::raw::c_uchar,
    ) -> std::os::raw::c_int,
>;
pub type esp_sha1_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        key_len: std::os::raw::c_uint,
        label: *const std::os::raw::c_char,
        data: *const std::os::raw::c_uchar,
        data_len: std::os::raw::c_uint,
        buf: *mut std::os::raw::c_uchar,
        buf_len: std::os::raw::c_uint,
    ) -> std::os::raw::c_int,
>;
pub type esp_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: std::os::raw::c_uint,
        addr: *mut [*const std::os::raw::c_uchar; 0usize],
        len: *const std::os::raw::c_uint,
        mac: *mut std::os::raw::c_uchar,
    ) -> std::os::raw::c_int,
>;
pub type esp_pbkdf2_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        passphrase: *const std::os::raw::c_char,
        ssid: *const std::os::raw::c_char,
        ssid_len: std::os::raw::c_uint,
        iterations: std::os::raw::c_int,
        buf: *mut std::os::raw::c_uchar,
        buflen: std::os::raw::c_uint,
    ) -> std::os::raw::c_int,
>;
pub type esp_rc4_skip_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        keylen: std::os::raw::c_uint,
        skip: std::os::raw::c_uint,
        data: *mut std::os::raw::c_uchar,
        data_len: std::os::raw::c_uint,
    ) -> std::os::raw::c_int,
>;
pub type esp_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: std::os::raw::c_uint,
        addr: *mut [*const std::os::raw::c_uchar; 0usize],
        len: *const std::os::raw::c_uint,
        mac: *mut std::os::raw::c_uchar,
    ) -> std::os::raw::c_int,
>;
pub type esp_aes_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut std::os::raw::c_void,
        plain: *const std::os::raw::c_uchar,
        crypt: *mut std::os::raw::c_uchar,
    ),
>;
pub type esp_aes_encrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        len: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_void,
>;
pub type esp_aes_encrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut std::os::raw::c_void)>;
pub type esp_aes_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut std::os::raw::c_void,
        crypt: *const std::os::raw::c_uchar,
        plain: *mut std::os::raw::c_uchar,
    ),
>;
pub type esp_aes_decrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const std::os::raw::c_uchar,
        len: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_void,
>;
pub type esp_aes_decrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wpa_crypto_funcs_t {
    pub size: u32,
    pub version: u32,
    pub aes_wrap: esp_aes_wrap_t,
    pub aes_unwrap: esp_aes_unwrap_t,
    pub hmac_sha256_vector: esp_hmac_sha256_vector_t,
    pub sha256_prf: esp_sha256_prf_t,
    pub hmac_md5: esp_hmac_md5_t,
    pub hamc_md5_vector: esp_hmac_md5_vector_t,
    pub hmac_sha1: esp_hmac_sha1_t,
    pub hmac_sha1_vector: esp_hmac_sha1_vector_t,
    pub sha1_prf: esp_sha1_prf_t,
    pub sha1_vector: esp_sha1_vector_t,
    pub pbkdf2_sha1: esp_pbkdf2_sha1_t,
    pub rc4_skip: esp_rc4_skip_t,
    pub md5_vector: esp_md5_vector_t,
    pub aes_encrypt: esp_aes_encrypt_t,
    pub aes_encrypt_init: esp_aes_encrypt_init_t,
    pub aes_encrypt_deinit: esp_aes_encrypt_deinit_t,
    pub aes_decrypt: esp_aes_decrypt_t,
    pub aes_decrypt_init: esp_aes_decrypt_init_t,
    pub aes_decrypt_deinit: esp_aes_decrypt_deinit_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct mesh_crypto_funcs_t {
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct wifi_osi_funcs_t {
    pub _version: i32,
    pub _set_isr: ::core::option::Option<
        unsafe extern "C" fn(n: i32, f: *mut std::os::raw::c_void, arg: *mut std::os::raw::c_void),
    >,
    pub _ints_on: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _ints_off: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _spin_lock_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut std::os::raw::c_void>,
    pub _spin_lock_delete:
        ::core::option::Option<unsafe extern "C" fn(lock: *mut std::os::raw::c_void)>,
    pub _wifi_int_disable: ::core::option::Option<
        unsafe extern "C" fn(wifi_int_mux: *mut std::os::raw::c_void) -> u32,
    >,
    pub _wifi_int_restore: ::core::option::Option<
        unsafe extern "C" fn(wifi_int_mux: *mut std::os::raw::c_void, tmp: u32),
    >,
    pub _task_yield_from_isr: ::core::option::Option<unsafe extern "C" fn()>,
    pub _semphr_create: ::core::option::Option<
        unsafe extern "C" fn(max: u32, init: u32) -> *mut std::os::raw::c_void,
    >,
    pub _semphr_delete:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut std::os::raw::c_void)>,
    pub _semphr_take: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut std::os::raw::c_void, block_time_tick: u32) -> i32,
    >,
    pub _semphr_give:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut std::os::raw::c_void) -> i32>,
    pub _wifi_thread_semphr_get:
        ::core::option::Option<unsafe extern "C" fn() -> *mut std::os::raw::c_void>,
    pub _mutex_create: ::core::option::Option<unsafe extern "C" fn() -> *mut std::os::raw::c_void>,
    pub _recursive_mutex_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut std::os::raw::c_void>,
    pub _mutex_delete:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut std::os::raw::c_void)>,
    pub _mutex_lock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut std::os::raw::c_void) -> i32>,
    pub _mutex_unlock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut std::os::raw::c_void) -> i32>,
    pub _queue_create: ::core::option::Option<
        unsafe extern "C" fn(queue_len: u32, item_size: u32) -> *mut std::os::raw::c_void,
    >,
    pub _queue_delete:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut std::os::raw::c_void)>,
    pub _queue_send: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut std::os::raw::c_void,
            item: *mut std::os::raw::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut std::os::raw::c_void,
            item: *mut std::os::raw::c_void,
            hptw: *mut std::os::raw::c_void,
        ) -> i32,
    >,
    pub _queue_send_to_back: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut std::os::raw::c_void,
            item: *mut std::os::raw::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_to_front: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut std::os::raw::c_void,
            item: *mut std::os::raw::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_recv: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut std::os::raw::c_void,
            item: *mut std::os::raw::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_msg_waiting:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut std::os::raw::c_void) -> u32>,
    pub _event_group_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut std::os::raw::c_void>,
    pub _event_group_delete:
        ::core::option::Option<unsafe extern "C" fn(event: *mut std::os::raw::c_void)>,
    pub _event_group_set_bits: ::core::option::Option<
        unsafe extern "C" fn(event: *mut std::os::raw::c_void, bits: u32) -> u32,
    >,
    pub _event_group_clear_bits: ::core::option::Option<
        unsafe extern "C" fn(event: *mut std::os::raw::c_void, bits: u32) -> u32,
    >,
    pub _event_group_wait_bits: ::core::option::Option<
        unsafe extern "C" fn(
            event: *mut std::os::raw::c_void,
            bits_to_wait_for: u32,
            clear_on_exit: i32,
            wait_for_all_bits: i32,
            block_time_tick: u32,
        ) -> u32,
    >,
    pub _task_create_pinned_to_core: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut std::os::raw::c_void,
            name: *const std::os::raw::c_char,
            stack_depth: u32,
            param: *mut std::os::raw::c_void,
            prio: u32,
            task_handle: *mut std::os::raw::c_void,
            core_id: u32,
        ) -> i32,
    >,
    pub _task_create: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut std::os::raw::c_void,
            name: *const std::os::raw::c_char,
            stack_depth: u32,
            param: *mut std::os::raw::c_void,
            prio: u32,
            task_handle: *mut std::os::raw::c_void,
        ) -> i32,
    >,
    pub _task_delete:
        ::core::option::Option<unsafe extern "C" fn(task_handle: *mut std::os::raw::c_void)>,
    pub _task_delay: ::core::option::Option<unsafe extern "C" fn(tick: u32)>,
    pub _task_ms_to_tick: ::core::option::Option<unsafe extern "C" fn(ms: u32) -> i32>,
    pub _task_get_current_task:
        ::core::option::Option<unsafe extern "C" fn() -> *mut std::os::raw::c_void>,
    pub _task_get_max_priority: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    pub _malloc:
        ::core::option::Option<unsafe extern "C" fn(size: u32) -> *mut std::os::raw::c_void>,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut std::os::raw::c_void)>,
    pub _event_post: ::core::option::Option<
        unsafe extern "C" fn(
            event_base: *const std::os::raw::c_char,
            event_id: i32,
            event_data: *mut std::os::raw::c_void,
            event_data_size: usize,
            ticks_to_wait: u32,
        ) -> i32,
    >,
    pub _get_free_heap_size: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _rand: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _dport_access_stall_other_cpu_start_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _dport_access_stall_other_cpu_end_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_rf_deinit: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _phy_load_cal_and_init: ::core::option::Option<unsafe extern "C" fn(module: u32)>,
    pub _phy_common_clock_enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_common_clock_disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub _read_mac: ::core::option::Option<unsafe extern "C" fn(mac: *mut u8, type_: u32) -> i32>,
    pub _timer_arm: ::core::option::Option<
        unsafe extern "C" fn(timer: *mut std::os::raw::c_void, tmout: u32, repeat: bool),
    >,
    pub _timer_disarm:
        ::core::option::Option<unsafe extern "C" fn(timer: *mut std::os::raw::c_void)>,
    pub _timer_done:
        ::core::option::Option<unsafe extern "C" fn(ptimer: *mut std::os::raw::c_void)>,
    pub _timer_setfn: ::core::option::Option<
        unsafe extern "C" fn(
            ptimer: *mut std::os::raw::c_void,
            pfunction: *mut std::os::raw::c_void,
            parg: *mut std::os::raw::c_void,
        ),
    >,
    pub _timer_arm_us: ::core::option::Option<
        unsafe extern "C" fn(ptimer: *mut std::os::raw::c_void, us: u32, repeat: bool),
    >,
    pub _periph_module_enable: ::core::option::Option<unsafe extern "C" fn(periph: u32)>,
    pub _periph_module_disable: ::core::option::Option<unsafe extern "C" fn(periph: u32)>,
    pub _esp_timer_get_time: ::core::option::Option<unsafe extern "C" fn() -> i64>,
    pub _nvs_set_i8: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const std::os::raw::c_char, value: i8) -> i32,
    >,
    pub _nvs_get_i8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const std::os::raw::c_char,
            out_value: *mut i8,
        ) -> i32,
    >,
    pub _nvs_set_u8: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const std::os::raw::c_char, value: u8) -> i32,
    >,
    pub _nvs_get_u8: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const std::os::raw::c_char,
            out_value: *mut u8,
        ) -> i32,
    >,
    pub _nvs_set_u16: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const std::os::raw::c_char, value: u16) -> i32,
    >,
    pub _nvs_get_u16: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const std::os::raw::c_char,
            out_value: *mut u16,
        ) -> i32,
    >,
    pub _nvs_open: ::core::option::Option<
        unsafe extern "C" fn(
            name: *const std::os::raw::c_char,
            open_mode: u32,
            out_handle: *mut u32,
        ) -> i32,
    >,
    pub _nvs_close: ::core::option::Option<unsafe extern "C" fn(handle: u32)>,
    pub _nvs_commit: ::core::option::Option<unsafe extern "C" fn(handle: u32) -> i32>,
    pub _nvs_set_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const std::os::raw::c_char,
            value: *const std::os::raw::c_void,
            length: usize,
        ) -> i32,
    >,
    pub _nvs_get_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const std::os::raw::c_char,
            out_value: *mut std::os::raw::c_void,
            length: *mut usize,
        ) -> i32,
    >,
    pub _nvs_erase_key: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const std::os::raw::c_char) -> i32,
    >,
    pub _get_random: ::core::option::Option<unsafe extern "C" fn(buf: *mut u8, len: usize) -> i32>,
    pub _get_time:
        ::core::option::Option<unsafe extern "C" fn(t: *mut std::os::raw::c_void) -> i32>,
    pub _random: ::core::option::Option<unsafe extern "C" fn() -> std::os::raw::c_ulong>,
    pub _log_write: ::core::option::Option<
        unsafe extern "C" fn(
            level: u32,
            tag: *const std::os::raw::c_char,
            format: *const std::os::raw::c_char,
            ...
        ),
    >,
    pub _log_timestamp: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _malloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut std::os::raw::c_void>,
    pub _realloc_internal: ::core::option::Option<
        unsafe extern "C" fn(
            ptr: *mut std::os::raw::c_void,
            size: usize,
        ) -> *mut std::os::raw::c_void,
    >,
    pub _calloc_internal: ::core::option::Option<
        unsafe extern "C" fn(n: usize, size: usize) -> *mut std::os::raw::c_void,
    >,
    pub _zalloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut std::os::raw::c_void>,
    pub _wifi_malloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut std::os::raw::c_void>,
    pub _wifi_realloc: ::core::option::Option<
        unsafe extern "C" fn(
            ptr: *mut std::os::raw::c_void,
            size: usize,
        ) -> *mut std::os::raw::c_void,
    >,
    pub _wifi_calloc: ::core::option::Option<
        unsafe extern "C" fn(n: usize, size: usize) -> *mut std::os::raw::c_void,
    >,
    pub _wifi_zalloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut std::os::raw::c_void>,
    pub _wifi_create_queue: ::core::option::Option<
        unsafe extern "C" fn(queue_len: i32, item_size: i32) -> *mut std::os::raw::c_void,
    >,
    pub _wifi_delete_queue:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut std::os::raw::c_void)>,
    pub _modem_sleep_enter: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _modem_sleep_exit: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _modem_sleep_register: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _modem_sleep_deregister: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _coex_status_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _coex_condition_set:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, dissatisfy: bool)>,
    pub _coex_wifi_request: ::core::option::Option<
        unsafe extern "C" fn(event: u32, latency: u32, duration: u32) -> i32,
    >,
    pub _coex_wifi_release: ::core::option::Option<unsafe extern "C" fn(event: u32) -> i32>,
    pub _magic: i32,
}
extern "C" {
    pub static mut g_wifi_osi_funcs: wifi_osi_funcs_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct wifi_init_config_t {
    pub event_handler: system_event_handler_t,
    pub osi_funcs: *mut wifi_osi_funcs_t,
    pub wpa_crypto_funcs: wpa_crypto_funcs_t,
    pub static_rx_buf_num: std::os::raw::c_int,
    pub dynamic_rx_buf_num: std::os::raw::c_int,
    pub tx_buf_type: std::os::raw::c_int,
    pub static_tx_buf_num: std::os::raw::c_int,
    pub dynamic_tx_buf_num: std::os::raw::c_int,
    pub csi_enable: std::os::raw::c_int,
    pub ampdu_rx_enable: std::os::raw::c_int,
    pub ampdu_tx_enable: std::os::raw::c_int,
    pub nvs_enable: std::os::raw::c_int,
    pub nano_enable: std::os::raw::c_int,
    pub tx_ba_win: std::os::raw::c_int,
    pub rx_ba_win: std::os::raw::c_int,
    pub wifi_task_core_id: std::os::raw::c_int,
    pub beacon_max_len: std::os::raw::c_int,
    pub mgmt_sbuf_num: std::os::raw::c_int,
    pub magic: std::os::raw::c_int,
}
impl Default for wifi_init_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static g_wifi_default_wpa_crypto_funcs: wpa_crypto_funcs_t;
}
extern "C" {
    pub fn esp_wifi_init(config: *const wifi_init_config_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_deinit() -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_mode(mode: wifi_mode_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_mode(mode: *mut wifi_mode_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_start() -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_stop() -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_restore() -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_connect() -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_disconnect() -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_clear_fast_connect() -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_deauth_sta(aid: u16) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_scan_start(config: *const wifi_scan_config_t, block: bool) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_scan_stop() -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_scan_get_ap_num(number: *mut u16) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_scan_get_ap_records(
        number: *mut u16,
        ap_records: *mut wifi_ap_record_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_sta_get_ap_info(ap_info: *mut wifi_ap_record_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_ps(type_: wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_ps(type_: *mut wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_protocol(ifx: wifi_interface_t, protocol_bitmap: u8) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_protocol(ifx: wifi_interface_t, protocol_bitmap: *mut u8) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_bandwidth(ifx: wifi_interface_t, bw: wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_bandwidth(ifx: wifi_interface_t, bw: *mut wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_channel(primary: u8, second: wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_channel(primary: *mut u8, second: *mut wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_country(country: *const wifi_country_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_country(country: *mut wifi_country_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_mac(ifx: wifi_interface_t, mac: *const [u8; 6usize]) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_mac(ifx: wifi_interface_t, mac: *mut [u8; 6usize]) -> esp_err_t;
}
pub type wifi_promiscuous_cb_t = ::core::option::Option<
    unsafe extern "C" fn(buf: *mut std::os::raw::c_void, type_: wifi_promiscuous_pkt_type_t),
>;
extern "C" {
    pub fn esp_wifi_set_promiscuous_rx_cb(cb: wifi_promiscuous_cb_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_promiscuous(en: bool) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_promiscuous(en: *mut bool) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_promiscuous_filter(filter: *const wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_promiscuous_filter(filter: *mut wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_promiscuous_ctrl_filter(
        filter: *const wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_promiscuous_ctrl_filter(
        filter: *mut wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_ap_get_sta_list(sta: *mut wifi_sta_list_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_storage(storage: wifi_storage_t) -> esp_err_t;
}
pub type esp_vendor_ie_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut std::os::raw::c_void,
        type_: wifi_vendor_ie_type_t,
        sa: *const [u8; 6usize],
        vnd_ie: *const vendor_ie_data_t,
        rssi: std::os::raw::c_int,
    ),
>;
extern "C" {
    pub fn esp_wifi_set_vendor_ie(
        enable: bool,
        type_: wifi_vendor_ie_type_t,
        idx: wifi_vendor_ie_id_t,
        vnd_ie: *const std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_vendor_ie_cb(
        cb: esp_vendor_ie_cb_t,
        ctx: *mut std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_max_tx_power(power: i8) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_max_tx_power(power: *mut i8) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_event_mask(mask: u32) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_event_mask(mask: *mut u32) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_80211_tx(
        ifx: wifi_interface_t,
        buffer: *const std::os::raw::c_void,
        len: std::os::raw::c_int,
        en_sys_seq: bool,
    ) -> esp_err_t;
}
pub type wifi_csi_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut std::os::raw::c_void, data: *mut wifi_csi_info_t),
>;
extern "C" {
    pub fn esp_wifi_set_csi_rx_cb(cb: wifi_csi_cb_t, ctx: *mut std::os::raw::c_void) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_csi_config(config: *const wifi_csi_config_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_csi(en: bool) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_ant_gpio(config: *const wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_ant_gpio(config: *mut wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_set_ant(config: *const wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_wifi_get_ant(config: *mut wifi_ant_config_t) -> esp_err_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPIO_INT_TYPE {
    GPIO_PIN_INTR_DISABLE = 0,
    GPIO_PIN_INTR_POSEDGE = 1,
    GPIO_PIN_INTR_NEGEDGE = 2,
    GPIO_PIN_INTR_ANYEDGE = 3,
    GPIO_PIN_INTR_LOLEVEL = 4,
    GPIO_PIN_INTR_HILEVEL = 5,
}
pub type gpio_intr_handler_fn_t = ::core::option::Option<
    unsafe extern "C" fn(intr_mask: u32, high: bool, arg: *mut std::os::raw::c_void),
>;
extern "C" {
    pub fn gpio_init();
}
extern "C" {
    pub fn gpio_output_set(set_mask: u32, clear_mask: u32, enable_mask: u32, disable_mask: u32);
}
extern "C" {
    pub fn gpio_output_set_high(
        set_mask: u32,
        clear_mask: u32,
        enable_mask: u32,
        disable_mask: u32,
    );
}
extern "C" {
    pub fn gpio_input_get() -> u32;
}
extern "C" {
    pub fn gpio_input_get_high() -> u32;
}
extern "C" {
    pub fn gpio_intr_handler_register(fn_: gpio_intr_handler_fn_t, arg: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn gpio_intr_pending() -> u32;
}
extern "C" {
    pub fn gpio_intr_pending_high() -> u32;
}
extern "C" {
    pub fn gpio_intr_ack(ack_mask: u32);
}
extern "C" {
    pub fn gpio_intr_ack_high(ack_mask: u32);
}
extern "C" {
    pub fn gpio_pin_wakeup_enable(i: u32, intr_state: GPIO_INT_TYPE);
}
extern "C" {
    pub fn gpio_pin_wakeup_disable();
}
extern "C" {
    pub fn gpio_matrix_in(gpio: u32, signal_idx: u32, inv: bool);
}
extern "C" {
    pub fn gpio_matrix_out(gpio: u32, signal_idx: u32, out_inv: bool, oen_inv: bool);
}
extern "C" {
    pub fn gpio_pad_select_gpio(gpio_num: u8);
}
extern "C" {
    pub fn gpio_pad_set_drv(gpio_num: u8, drv: u8);
}
extern "C" {
    pub fn gpio_pad_pullup(gpio_num: u8);
}
extern "C" {
    pub fn gpio_pad_pulldown(gpio_num: u8);
}
extern "C" {
    pub fn gpio_pad_unhold(gpio_num: u8);
}
extern "C" {
    pub fn gpio_pad_hold(gpio_num: u8);
}
pub type xt_handler = ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void)>;
pub type xt_exc_handler = ::core::option::Option<unsafe extern "C" fn(arg1: *mut XtExcFrame)>;
extern "C" {
    pub fn xt_set_exception_handler(n: std::os::raw::c_int, f: xt_exc_handler) -> xt_exc_handler;
}
extern "C" {
    pub fn xt_set_interrupt_handler(
        n: std::os::raw::c_int,
        f: xt_handler,
        arg: *mut std::os::raw::c_void,
    ) -> xt_handler;
}
extern "C" {
    pub fn xt_ints_on(mask: std::os::raw::c_uint);
}
extern "C" {
    pub fn xt_ints_off(mask: std::os::raw::c_uint);
}
extern "C" {
    pub fn xt_get_interrupt_handler_arg(n: std::os::raw::c_int) -> *mut std::os::raw::c_void;
}
pub type intr_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intr_handle_data_t {
    _unused: [u8; 0],
}
pub type intr_handle_t = *mut intr_handle_data_t;
extern "C" {
    pub fn esp_intr_mark_shared(
        intno: std::os::raw::c_int,
        cpu: std::os::raw::c_int,
        is_in_iram: bool,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_intr_reserve(intno: std::os::raw::c_int, cpu: std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    pub fn esp_intr_alloc(
        source: std::os::raw::c_int,
        flags: std::os::raw::c_int,
        handler: intr_handler_t,
        arg: *mut std::os::raw::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_intr_alloc_intrstatus(
        source: std::os::raw::c_int,
        flags: std::os::raw::c_int,
        intrstatusreg: u32,
        intrstatusmask: u32,
        handler: intr_handler_t,
        arg: *mut std::os::raw::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn esp_intr_free(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_intr_get_cpu(handle: intr_handle_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn esp_intr_get_intno(handle: intr_handle_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn esp_intr_disable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_intr_enable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn esp_intr_set_in_iram(handle: intr_handle_t, is_in_iram: bool) -> esp_err_t;
}
extern "C" {
    pub fn esp_intr_noniram_disable();
}
extern "C" {
    pub fn esp_intr_noniram_enable();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_dev_s {
    pub bt_select: u32,
    pub out: u32,
    pub out_w1ts: u32,
    pub out_w1tc: u32,
    pub out1: gpio_dev_s__bindgen_ty_1,
    pub out1_w1ts: gpio_dev_s__bindgen_ty_2,
    pub out1_w1tc: gpio_dev_s__bindgen_ty_3,
    pub sdio_select: gpio_dev_s__bindgen_ty_4,
    pub enable: u32,
    pub enable_w1ts: u32,
    pub enable_w1tc: u32,
    pub enable1: gpio_dev_s__bindgen_ty_5,
    pub enable1_w1ts: gpio_dev_s__bindgen_ty_6,
    pub enable1_w1tc: gpio_dev_s__bindgen_ty_7,
    pub strap: gpio_dev_s__bindgen_ty_8,
    pub in_: u32,
    pub in1: gpio_dev_s__bindgen_ty_9,
    pub status: u32,
    pub status_w1ts: u32,
    pub status_w1tc: u32,
    pub status1: gpio_dev_s__bindgen_ty_10,
    pub status1_w1ts: gpio_dev_s__bindgen_ty_11,
    pub status1_w1tc: gpio_dev_s__bindgen_ty_12,
    pub reserved_5c: u32,
    pub acpu_int: u32,
    pub acpu_nmi_int: u32,
    pub pcpu_int: u32,
    pub pcpu_nmi_int: u32,
    pub cpusdio_int: u32,
    pub acpu_int1: gpio_dev_s__bindgen_ty_13,
    pub acpu_nmi_int1: gpio_dev_s__bindgen_ty_14,
    pub pcpu_int1: gpio_dev_s__bindgen_ty_15,
    pub pcpu_nmi_int1: gpio_dev_s__bindgen_ty_16,
    pub cpusdio_int1: gpio_dev_s__bindgen_ty_17,
    pub pin: [gpio_dev_s__bindgen_ty_18; 40usize],
    pub cali_conf: gpio_dev_s__bindgen_ty_19,
    pub cali_data: gpio_dev_s__bindgen_ty_20,
    pub func_in_sel_cfg: [gpio_dev_s__bindgen_ty_21; 256usize],
    pub func_out_sel_cfg: [gpio_dev_s__bindgen_ty_22; 40usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_3 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sel: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sel: u32 = unsafe { ::core::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_4 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_5 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_6 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_7 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl gpio_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn strapping(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_strapping(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        strapping: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let strapping: u32 = unsafe { ::core::mem::transmute(strapping) };
            strapping as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_8 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_9 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_9 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_10 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_10 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_11 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_11 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_12 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_12 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_12 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_13 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_13 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_13 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_14 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_14 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_14 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_15 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_15 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_15 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_16 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_16 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_17 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_17 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_17 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl gpio_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_driver(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad_driver(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn config(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_config(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn int_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_int_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        pad_driver: u32,
        reserved3: u32,
        int_type: u32,
        wakeup_enable: u32,
        config: u32,
        int_ena: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pad_driver: u32 = unsafe { ::core::mem::transmute(pad_driver) };
            pad_driver as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let int_type: u32 = unsafe { ::core::mem::transmute(int_type) };
            int_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wakeup_enable: u32 = unsafe { ::core::mem::transmute(wakeup_enable) };
            wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let config: u32 = unsafe { ::core::mem::transmute(config) };
            config as u64
        });
        __bindgen_bitfield_unit.set(13usize, 5u8, {
            let int_ena: u32 = unsafe { ::core::mem::transmute(int_ena) };
            int_ena as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_18 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_18 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_18 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn rtc_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_max: u32,
        reserved10: u32,
        start: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let rtc_max: u32 = unsafe { ::core::mem::transmute(rtc_max) };
            rtc_max as u64
        });
        __bindgen_bitfield_unit.set(10usize, 21u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_19 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_19 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_19 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn value_sync2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_value_sync2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn rdy_real(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy_real(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdy_sync2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy_sync2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        value_sync2: u32,
        reserved20: u32,
        rdy_real: u32,
        rdy_sync2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let value_sync2: u32 = unsafe { ::core::mem::transmute(value_sync2) };
            value_sync2 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 10u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rdy_real: u32 = unsafe { ::core::mem::transmute(rdy_real) };
            rdy_real as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rdy_sync2: u32 = unsafe { ::core::mem::transmute(rdy_sync2) };
            rdy_sync2 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_20 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_20 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_20 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        sig_in_inv: u32,
        sig_in_sel: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let func_sel: u32 = unsafe { ::core::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sig_in_inv: u32 = unsafe { ::core::mem::transmute(sig_in_inv) };
            sig_in_inv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sig_in_sel: u32 = unsafe { ::core::mem::transmute(sig_in_sel) };
            sig_in_sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_21 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_21 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_21 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct gpio_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn inv_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_inv_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        inv_sel: u32,
        oen_sel: u32,
        oen_inv_sel: u32,
        reserved12: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let func_sel: u32 = unsafe { ::core::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inv_sel: u32 = unsafe { ::core::mem::transmute(inv_sel) };
            inv_sel as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let oen_sel: u32 = unsafe { ::core::mem::transmute(oen_sel) };
            oen_sel as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let oen_inv_sel: u32 = unsafe { ::core::mem::transmute(oen_inv_sel) };
            oen_inv_sel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for gpio_dev_s__bindgen_ty_22 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s__bindgen_ty_22 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpio_dev_s__bindgen_ty_22 {{ union }}")
    }
}
impl Default for gpio_dev_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for gpio_dev_s {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "gpio_dev_s {{ bt_select: {:?}, out: {:?}, out_w1ts: {:?}, out_w1tc: {:?}, out1: {:?}, out1_w1ts: {:?}, out1_w1tc: {:?}, sdio_select: {:?}, enable: {:?}, enable_w1ts: {:?}, enable_w1tc: {:?}, enable1: {:?}, enable1_w1ts: {:?}, enable1_w1tc: {:?}, strap: {:?}, in: {:?}, in1: {:?}, status: {:?}, status_w1ts: {:?}, status_w1tc: {:?}, status1: {:?}, status1_w1ts: {:?}, status1_w1tc: {:?}, reserved_5c: {:?}, acpu_int: {:?}, acpu_nmi_int: {:?}, pcpu_int: {:?}, pcpu_nmi_int: {:?}, cpusdio_int: {:?}, acpu_int1: {:?}, acpu_nmi_int1: {:?}, pcpu_int1: {:?}, pcpu_nmi_int1: {:?}, cpusdio_int1: {:?}, pin: [...], cali_conf: {:?}, cali_data: {:?}, func_in_sel_cfg: [...], func_out_sel_cfg: [...] }}" , self . bt_select , self . out , self . out_w1ts , self . out_w1tc , self . out1 , self . out1_w1ts , self . out1_w1tc , self . sdio_select , self . enable , self . enable_w1ts , self . enable_w1tc , self . enable1 , self . enable1_w1ts , self . enable1_w1tc , self . strap , self . in_ , self . in1 , self . status , self . status_w1ts , self . status_w1tc , self . status1 , self . status1_w1ts , self . status1_w1tc , self . reserved_5c , self . acpu_int , self . acpu_nmi_int , self . pcpu_int , self . pcpu_nmi_int , self . cpusdio_int , self . acpu_int1 , self . acpu_nmi_int1 , self . pcpu_int1 , self . pcpu_nmi_int1 , self . cpusdio_int1 , self . cali_conf , self . cali_data )
    }
}
pub type gpio_dev_t = gpio_dev_s;
extern "C" {
    pub static mut GPIO: gpio_dev_t;
}
extern "C" {
    pub static GPIO_PIN_MUX_REG: [u32; 40usize];
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gpio_num_t {
    GPIO_NUM_NC = -1,
    GPIO_NUM_0 = 0,
    GPIO_NUM_1 = 1,
    GPIO_NUM_2 = 2,
    GPIO_NUM_3 = 3,
    GPIO_NUM_4 = 4,
    GPIO_NUM_5 = 5,
    GPIO_NUM_6 = 6,
    GPIO_NUM_7 = 7,
    GPIO_NUM_8 = 8,
    GPIO_NUM_9 = 9,
    GPIO_NUM_10 = 10,
    GPIO_NUM_11 = 11,
    GPIO_NUM_12 = 12,
    GPIO_NUM_13 = 13,
    GPIO_NUM_14 = 14,
    GPIO_NUM_15 = 15,
    GPIO_NUM_16 = 16,
    GPIO_NUM_17 = 17,
    GPIO_NUM_18 = 18,
    GPIO_NUM_19 = 19,
    GPIO_NUM_21 = 21,
    GPIO_NUM_22 = 22,
    GPIO_NUM_23 = 23,
    GPIO_NUM_25 = 25,
    GPIO_NUM_26 = 26,
    GPIO_NUM_27 = 27,
    GPIO_NUM_32 = 32,
    GPIO_NUM_33 = 33,
    GPIO_NUM_34 = 34,
    GPIO_NUM_35 = 35,
    GPIO_NUM_36 = 36,
    GPIO_NUM_37 = 37,
    GPIO_NUM_38 = 38,
    GPIO_NUM_39 = 39,
    GPIO_NUM_MAX = 40,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gpio_int_type_t {
    GPIO_INTR_DISABLE = 0,
    GPIO_INTR_POSEDGE = 1,
    GPIO_INTR_NEGEDGE = 2,
    GPIO_INTR_ANYEDGE = 3,
    GPIO_INTR_LOW_LEVEL = 4,
    GPIO_INTR_HIGH_LEVEL = 5,
    GPIO_INTR_MAX = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gpio_mode_t {
    GPIO_MODE_DISABLE = 0,
    GPIO_MODE_INPUT = 1,
    GPIO_MODE_OUTPUT = 2,
    GPIO_MODE_OUTPUT_OD = 6,
    GPIO_MODE_INPUT_OUTPUT_OD = 7,
    GPIO_MODE_INPUT_OUTPUT = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gpio_pullup_t {
    GPIO_PULLUP_DISABLE = 0,
    GPIO_PULLUP_ENABLE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gpio_pulldown_t {
    GPIO_PULLDOWN_DISABLE = 0,
    GPIO_PULLDOWN_ENABLE = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct gpio_config_t {
    pub pin_bit_mask: u64,
    pub mode: gpio_mode_t,
    pub pull_up_en: gpio_pullup_t,
    pub pull_down_en: gpio_pulldown_t,
    pub intr_type: gpio_int_type_t,
}
impl Default for gpio_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gpio_pull_mode_t {
    GPIO_PULLUP_ONLY = 0,
    GPIO_PULLDOWN_ONLY = 1,
    GPIO_PULLUP_PULLDOWN = 2,
    GPIO_FLOATING = 3,
}
impl gpio_drive_cap_t {
    pub const GPIO_DRIVE_CAP_DEFAULT: gpio_drive_cap_t = gpio_drive_cap_t::GPIO_DRIVE_CAP_2;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gpio_drive_cap_t {
    GPIO_DRIVE_CAP_0 = 0,
    GPIO_DRIVE_CAP_1 = 1,
    GPIO_DRIVE_CAP_2 = 2,
    GPIO_DRIVE_CAP_3 = 3,
    GPIO_DRIVE_CAP_MAX = 4,
}
pub type gpio_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void)>;
pub type gpio_isr_handle_t = intr_handle_t;
extern "C" {
    pub fn gpio_config(pGPIOConfig: *const gpio_config_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_reset_pin(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_set_intr_type(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_intr_enable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_intr_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_set_level(gpio_num: gpio_num_t, level: u32) -> esp_err_t;
}
extern "C" {
    pub fn gpio_get_level(gpio_num: gpio_num_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_set_direction(gpio_num: gpio_num_t, mode: gpio_mode_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_set_pull_mode(gpio_num: gpio_num_t, pull: gpio_pull_mode_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_wakeup_enable(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_wakeup_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void)>,
        arg: *mut std::os::raw::c_void,
        intr_alloc_flags: std::os::raw::c_int,
        handle: *mut gpio_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn gpio_pullup_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_pullup_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_pulldown_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_pulldown_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_install_isr_service(intr_alloc_flags: std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    pub fn gpio_uninstall_isr_service();
}
extern "C" {
    pub fn gpio_isr_handler_add(
        gpio_num: gpio_num_t,
        isr_handler: gpio_isr_t,
        args: *mut std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub fn gpio_isr_handler_remove(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_set_drive_capability(gpio_num: gpio_num_t, strength: gpio_drive_cap_t)
        -> esp_err_t;
}
extern "C" {
    pub fn gpio_get_drive_capability(
        gpio_num: gpio_num_t,
        strength: *mut gpio_drive_cap_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn gpio_hold_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_hold_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn gpio_deep_sleep_hold_en();
}
extern "C" {
    pub fn gpio_deep_sleep_hold_dis();
}
extern "C" {
    pub fn gpio_iomux_in(gpio_num: u32, signal_idx: u32);
}
extern "C" {
    pub fn gpio_iomux_out(gpio_num: u8, func: std::os::raw::c_int, oen_inv: bool);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum adc_atten_t {
    ADC_ATTEN_DB_0 = 0,
    ADC_ATTEN_DB_2_5 = 1,
    ADC_ATTEN_DB_6 = 2,
    ADC_ATTEN_DB_11 = 3,
    ADC_ATTEN_MAX = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum adc_bits_width_t {
    ADC_WIDTH_BIT_9 = 0,
    ADC_WIDTH_BIT_10 = 1,
    ADC_WIDTH_BIT_11 = 2,
    ADC_WIDTH_BIT_12 = 3,
    ADC_WIDTH_MAX = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum adc1_channel_t {
    ADC1_CHANNEL_0 = 0,
    ADC1_CHANNEL_1 = 1,
    ADC1_CHANNEL_2 = 2,
    ADC1_CHANNEL_3 = 3,
    ADC1_CHANNEL_4 = 4,
    ADC1_CHANNEL_5 = 5,
    ADC1_CHANNEL_6 = 6,
    ADC1_CHANNEL_7 = 7,
    ADC1_CHANNEL_MAX = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum adc2_channel_t {
    ADC2_CHANNEL_0 = 0,
    ADC2_CHANNEL_1 = 1,
    ADC2_CHANNEL_2 = 2,
    ADC2_CHANNEL_3 = 3,
    ADC2_CHANNEL_4 = 4,
    ADC2_CHANNEL_5 = 5,
    ADC2_CHANNEL_6 = 6,
    ADC2_CHANNEL_7 = 7,
    ADC2_CHANNEL_8 = 8,
    ADC2_CHANNEL_9 = 9,
    ADC2_CHANNEL_MAX = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum adc_channel_t {
    ADC_CHANNEL_0 = 0,
    ADC_CHANNEL_1 = 1,
    ADC_CHANNEL_2 = 2,
    ADC_CHANNEL_3 = 3,
    ADC_CHANNEL_4 = 4,
    ADC_CHANNEL_5 = 5,
    ADC_CHANNEL_6 = 6,
    ADC_CHANNEL_7 = 7,
    ADC_CHANNEL_8 = 8,
    ADC_CHANNEL_9 = 9,
    ADC_CHANNEL_MAX = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum adc_unit_t {
    ADC_UNIT_1 = 1,
    ADC_UNIT_2 = 2,
    ADC_UNIT_BOTH = 3,
    ADC_UNIT_ALTER = 7,
    ADC_UNIT_MAX = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum adc_i2s_encode_t {
    ADC_ENCODE_12BIT = 0,
    ADC_ENCODE_11BIT = 1,
    ADC_ENCODE_MAX = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum adc_i2s_source_t {
    ADC_I2S_DATA_SRC_IO_SIG = 0,
    ADC_I2S_DATA_SRC_ADC = 1,
    ADC_I2S_DATA_SRC_MAX = 2,
}
extern "C" {
    pub fn adc1_pad_get_io_num(channel: adc1_channel_t, gpio_num: *mut gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn adc1_config_width(width_bit: adc_bits_width_t) -> esp_err_t;
}
extern "C" {
    pub fn adc_set_data_width(adc_unit: adc_unit_t, width_bit: adc_bits_width_t) -> esp_err_t;
}
extern "C" {
    pub fn adc1_config_channel_atten(channel: adc1_channel_t, atten: adc_atten_t) -> esp_err_t;
}
extern "C" {
    pub fn adc1_get_raw(channel: adc1_channel_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn adc_power_on();
}
extern "C" {
    pub fn adc_power_off();
}
extern "C" {
    pub fn adc_gpio_init(adc_unit: adc_unit_t, channel: adc_channel_t) -> esp_err_t;
}
extern "C" {
    pub fn adc_set_data_inv(adc_unit: adc_unit_t, inv_en: bool) -> esp_err_t;
}
extern "C" {
    pub fn adc_set_clk_div(clk_div: u8) -> esp_err_t;
}
extern "C" {
    pub fn adc_set_i2s_data_source(src: adc_i2s_source_t) -> esp_err_t;
}
extern "C" {
    pub fn adc_i2s_mode_init(adc_unit: adc_unit_t, channel: adc_channel_t) -> esp_err_t;
}
extern "C" {
    pub fn adc1_ulp_enable();
}
extern "C" {
    pub fn hall_sensor_read() -> std::os::raw::c_int;
}
extern "C" {
    pub fn adc2_pad_get_io_num(channel: adc2_channel_t, gpio_num: *mut gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn adc2_config_channel_atten(channel: adc2_channel_t, atten: adc_atten_t) -> esp_err_t;
}
extern "C" {
    pub fn adc2_get_raw(
        channel: adc2_channel_t,
        width_bit: adc_bits_width_t,
        raw_out: *mut std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn adc2_vref_to_gpio(gpio: gpio_num_t) -> esp_err_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dac_channel_t {
    DAC_CHANNEL_1 = 1,
    DAC_CHANNEL_2 = 2,
    DAC_CHANNEL_MAX = 3,
}
extern "C" {
    pub fn dac_pad_get_io_num(channel: dac_channel_t, gpio_num: *mut gpio_num_t) -> esp_err_t;
}
extern "C" {
    pub fn dac_output_voltage(channel: dac_channel_t, dac_value: u8) -> esp_err_t;
}
extern "C" {
    pub fn dac_output_enable(channel: dac_channel_t) -> esp_err_t;
}
extern "C" {
    pub fn dac_output_disable(channel: dac_channel_t) -> esp_err_t;
}
extern "C" {
    pub fn dac_i2s_enable() -> esp_err_t;
}
extern "C" {
    pub fn dac_i2s_disable() -> esp_err_t;
}
pub type RingbufHandle_t = *mut std::os::raw::c_void;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RingbufferType_t {
    RINGBUF_TYPE_NOSPLIT = 0,
    RINGBUF_TYPE_ALLOWSPLIT = 1,
    RINGBUF_TYPE_BYTEBUF = 2,
    RINGBUF_TYPE_MAX = 3,
}
extern "C" {
    pub fn xRingbufferCreate(xBufferSize: usize, xBufferType: RingbufferType_t) -> RingbufHandle_t;
}
extern "C" {
    pub fn xRingbufferCreateNoSplit(xItemSize: usize, xItemNum: usize) -> RingbufHandle_t;
}
extern "C" {
    pub fn xRingbufferSend(
        xRingbuffer: RingbufHandle_t,
        pvItem: *const std::os::raw::c_void,
        xItemSize: usize,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xRingbufferSendFromISR(
        xRingbuffer: RingbufHandle_t,
        pvItem: *const std::os::raw::c_void,
        xItemSize: usize,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xRingbufferSendAcquire(
        xRingbuffer: RingbufHandle_t,
        ppvItem: *mut *mut std::os::raw::c_void,
        xItemSize: usize,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xRingbufferSendComplete(
        xRingbuffer: RingbufHandle_t,
        pvItem: *mut std::os::raw::c_void,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xRingbufferReceive(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
        xTicksToWait: TickType_t,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn xRingbufferReceiveFromISR(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn xRingbufferReceiveSplit(
        xRingbuffer: RingbufHandle_t,
        ppvHeadItem: *mut *mut std::os::raw::c_void,
        ppvTailItem: *mut *mut std::os::raw::c_void,
        pxHeadItemSize: *mut usize,
        pxTailItemSize: *mut usize,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xRingbufferReceiveSplitFromISR(
        xRingbuffer: RingbufHandle_t,
        ppvHeadItem: *mut *mut std::os::raw::c_void,
        ppvTailItem: *mut *mut std::os::raw::c_void,
        pxHeadItemSize: *mut usize,
        pxTailItemSize: *mut usize,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xRingbufferReceiveUpTo(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
        xTicksToWait: TickType_t,
        xMaxSize: usize,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn xRingbufferReceiveUpToFromISR(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
        xMaxSize: usize,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn vRingbufferReturnItem(xRingbuffer: RingbufHandle_t, pvItem: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn vRingbufferReturnItemFromISR(
        xRingbuffer: RingbufHandle_t,
        pvItem: *mut std::os::raw::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    pub fn vRingbufferDelete(xRingbuffer: RingbufHandle_t);
}
extern "C" {
    pub fn xRingbufferGetMaxItemSize(xRingbuffer: RingbufHandle_t) -> usize;
}
extern "C" {
    pub fn xRingbufferGetCurFreeSize(xRingbuffer: RingbufHandle_t) -> usize;
}
extern "C" {
    pub fn xRingbufferAddToQueueSetRead(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xRingbufferCanRead(
        xRingbuffer: RingbufHandle_t,
        xMember: QueueSetMemberHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xRingbufferRemoveFromQueueSetRead(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vRingbufferGetInfo(
        xRingbuffer: RingbufHandle_t,
        uxFree: *mut UBaseType_t,
        uxRead: *mut UBaseType_t,
        uxWrite: *mut UBaseType_t,
        uxAcquire: *mut UBaseType_t,
        uxItemsWaiting: *mut UBaseType_t,
    );
}
extern "C" {
    pub fn xRingbufferPrintInfo(xRingbuffer: RingbufHandle_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum i2c_mode_t {
    I2C_MODE_SLAVE = 0,
    I2C_MODE_MASTER = 1,
    I2C_MODE_MAX = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum i2c_rw_t {
    I2C_MASTER_WRITE = 0,
    I2C_MASTER_READ = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum i2c_trans_mode_t {
    I2C_DATA_MODE_MSB_FIRST = 0,
    I2C_DATA_MODE_LSB_FIRST = 1,
    I2C_DATA_MODE_MAX = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum i2c_opmode_t {
    I2C_CMD_RESTART = 0,
    I2C_CMD_WRITE = 1,
    I2C_CMD_READ = 2,
    I2C_CMD_STOP = 3,
    I2C_CMD_END = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum i2c_port_t {
    I2C_NUM_0 = 0,
    I2C_NUM_1 = 1,
    I2C_NUM_MAX = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum i2c_addr_mode_t {
    I2C_ADDR_BIT_7 = 0,
    I2C_ADDR_BIT_10 = 1,
    I2C_ADDR_BIT_MAX = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum i2c_ack_type_t {
    I2C_MASTER_ACK = 0,
    I2C_MASTER_NACK = 1,
    I2C_MASTER_LAST_NACK = 2,
    I2C_MASTER_ACK_MAX = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct i2c_config_t {
    pub mode: i2c_mode_t,
    pub sda_io_num: gpio_num_t,
    pub sda_pullup_en: gpio_pullup_t,
    pub scl_io_num: gpio_num_t,
    pub scl_pullup_en: gpio_pullup_t,
    pub __bindgen_anon_1: i2c_config_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2c_config_t__bindgen_ty_1 {
    pub master: i2c_config_t__bindgen_ty_1__bindgen_ty_1,
    pub slave: i2c_config_t__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2c_config_t__bindgen_ty_1__bindgen_ty_1 {
    pub clk_speed: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2c_config_t__bindgen_ty_1__bindgen_ty_2 {
    pub addr_10bit_en: u8,
    pub slave_addr: u16,
}
impl Default for i2c_config_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2c_config_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2c_config_t__bindgen_ty_1 {{ union }}")
    }
}
impl Default for i2c_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2c_config_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "i2c_config_t {{ mode: {:?}, sda_io_num: {:?}, sda_pullup_en: {:?}, scl_io_num: {:?}, scl_pullup_en: {:?}, __bindgen_anon_1: {:?} }}" , self . mode , self . sda_io_num , self . sda_pullup_en , self . scl_io_num , self . scl_pullup_en , self . __bindgen_anon_1 )
    }
}
pub type i2c_cmd_handle_t = *mut std::os::raw::c_void;
extern "C" {
    pub fn i2c_driver_install(
        i2c_num: i2c_port_t,
        mode: i2c_mode_t,
        slv_rx_buf_len: usize,
        slv_tx_buf_len: usize,
        intr_alloc_flags: std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_driver_delete(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    pub fn i2c_param_config(i2c_num: i2c_port_t, i2c_conf: *const i2c_config_t) -> esp_err_t;
}
extern "C" {
    pub fn i2c_reset_tx_fifo(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    pub fn i2c_reset_rx_fifo(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    pub fn i2c_isr_register(
        i2c_num: i2c_port_t,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void)>,
        arg: *mut std::os::raw::c_void,
        intr_alloc_flags: std::os::raw::c_int,
        handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_isr_free(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn i2c_set_pin(
        i2c_num: i2c_port_t,
        sda_io_num: std::os::raw::c_int,
        scl_io_num: std::os::raw::c_int,
        sda_pullup_en: gpio_pullup_t,
        scl_pullup_en: gpio_pullup_t,
        mode: i2c_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_cmd_link_create() -> i2c_cmd_handle_t;
}
extern "C" {
    pub fn i2c_cmd_link_delete(cmd_handle: i2c_cmd_handle_t);
}
extern "C" {
    pub fn i2c_master_start(cmd_handle: i2c_cmd_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn i2c_master_write_byte(cmd_handle: i2c_cmd_handle_t, data: u8, ack_en: bool)
        -> esp_err_t;
}
extern "C" {
    pub fn i2c_master_write(
        cmd_handle: i2c_cmd_handle_t,
        data: *mut u8,
        data_len: usize,
        ack_en: bool,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_master_read_byte(
        cmd_handle: i2c_cmd_handle_t,
        data: *mut u8,
        ack: i2c_ack_type_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_master_read(
        cmd_handle: i2c_cmd_handle_t,
        data: *mut u8,
        data_len: usize,
        ack: i2c_ack_type_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_master_stop(cmd_handle: i2c_cmd_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn i2c_master_cmd_begin(
        i2c_num: i2c_port_t,
        cmd_handle: i2c_cmd_handle_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_slave_write_buffer(
        i2c_num: i2c_port_t,
        data: *mut u8,
        size: std::os::raw::c_int,
        ticks_to_wait: TickType_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn i2c_slave_read_buffer(
        i2c_num: i2c_port_t,
        data: *mut u8,
        max_size: usize,
        ticks_to_wait: TickType_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn i2c_set_period(
        i2c_num: i2c_port_t,
        high_period: std::os::raw::c_int,
        low_period: std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_get_period(
        i2c_num: i2c_port_t,
        high_period: *mut std::os::raw::c_int,
        low_period: *mut std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_filter_enable(i2c_num: i2c_port_t, cyc_num: u8) -> esp_err_t;
}
extern "C" {
    pub fn i2c_filter_disable(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    pub fn i2c_set_start_timing(
        i2c_num: i2c_port_t,
        setup_time: std::os::raw::c_int,
        hold_time: std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_get_start_timing(
        i2c_num: i2c_port_t,
        setup_time: *mut std::os::raw::c_int,
        hold_time: *mut std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_set_stop_timing(
        i2c_num: i2c_port_t,
        setup_time: std::os::raw::c_int,
        hold_time: std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_get_stop_timing(
        i2c_num: i2c_port_t,
        setup_time: *mut std::os::raw::c_int,
        hold_time: *mut std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_set_data_timing(
        i2c_num: i2c_port_t,
        sample_time: std::os::raw::c_int,
        hold_time: std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_get_data_timing(
        i2c_num: i2c_port_t,
        sample_time: *mut std::os::raw::c_int,
        hold_time: *mut std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_set_timeout(i2c_num: i2c_port_t, timeout: std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    pub fn i2c_get_timeout(i2c_num: i2c_port_t, timeout: *mut std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    pub fn i2c_set_data_mode(
        i2c_num: i2c_port_t,
        tx_trans_mode: i2c_trans_mode_t,
        rx_trans_mode: i2c_trans_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2c_get_data_mode(
        i2c_num: i2c_port_t,
        tx_trans_mode: *mut i2c_trans_mode_t,
        rx_trans_mode: *mut i2c_trans_mode_t,
    ) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct i2s_dev_s {
    pub reserved_0: u32,
    pub reserved_4: u32,
    pub conf: i2s_dev_s__bindgen_ty_1,
    pub int_raw: i2s_dev_s__bindgen_ty_2,
    pub int_st: i2s_dev_s__bindgen_ty_3,
    pub int_ena: i2s_dev_s__bindgen_ty_4,
    pub int_clr: i2s_dev_s__bindgen_ty_5,
    pub timing: i2s_dev_s__bindgen_ty_6,
    pub fifo_conf: i2s_dev_s__bindgen_ty_7,
    pub rx_eof_num: u32,
    pub conf_single_data: u32,
    pub conf_chan: i2s_dev_s__bindgen_ty_8,
    pub out_link: i2s_dev_s__bindgen_ty_9,
    pub in_link: i2s_dev_s__bindgen_ty_10,
    pub out_eof_des_addr: u32,
    pub in_eof_des_addr: u32,
    pub out_eof_bfr_des_addr: u32,
    pub ahb_test: i2s_dev_s__bindgen_ty_11,
    pub in_link_dscr: u32,
    pub in_link_dscr_bf0: u32,
    pub in_link_dscr_bf1: u32,
    pub out_link_dscr: u32,
    pub out_link_dscr_bf0: u32,
    pub out_link_dscr_bf1: u32,
    pub lc_conf: i2s_dev_s__bindgen_ty_12,
    pub out_fifo_push: i2s_dev_s__bindgen_ty_13,
    pub in_fifo_pop: i2s_dev_s__bindgen_ty_14,
    pub lc_state0: u32,
    pub lc_state1: u32,
    pub lc_hung_conf: i2s_dev_s__bindgen_ty_15,
    pub reserved_78: u32,
    pub reserved_7c: u32,
    pub cvsd_conf0: i2s_dev_s__bindgen_ty_16,
    pub cvsd_conf1: i2s_dev_s__bindgen_ty_17,
    pub cvsd_conf2: i2s_dev_s__bindgen_ty_18,
    pub plc_conf0: i2s_dev_s__bindgen_ty_19,
    pub plc_conf1: i2s_dev_s__bindgen_ty_20,
    pub plc_conf2: i2s_dev_s__bindgen_ty_21,
    pub esco_conf0: i2s_dev_s__bindgen_ty_22,
    pub sco_conf0: i2s_dev_s__bindgen_ty_23,
    pub conf1: i2s_dev_s__bindgen_ty_24,
    pub pd_conf: i2s_dev_s__bindgen_ty_25,
    pub conf2: i2s_dev_s__bindgen_ty_26,
    pub clkm_conf: i2s_dev_s__bindgen_ty_27,
    pub sample_rate_conf: i2s_dev_s__bindgen_ty_28,
    pub pdm_conf: i2s_dev_s__bindgen_ty_29,
    pub pdm_freq_conf: i2s_dev_s__bindgen_ty_30,
    pub state: i2s_dev_s__bindgen_ty_31,
    pub reserved_c0: u32,
    pub reserved_c4: u32,
    pub reserved_c8: u32,
    pub reserved_cc: u32,
    pub reserved_d0: u32,
    pub reserved_d4: u32,
    pub reserved_d8: u32,
    pub reserved_dc: u32,
    pub reserved_e0: u32,
    pub reserved_e4: u32,
    pub reserved_e8: u32,
    pub reserved_ec: u32,
    pub reserved_f0: u32,
    pub reserved_f4: u32,
    pub reserved_f8: u32,
    pub date: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn tx_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_fifo_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_fifo_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_fifo_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_fifo_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_slave_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_slave_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_slave_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_slave_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_right_first(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_right_first(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_right_first(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_right_first(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_msb_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_msb_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_msb_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_msb_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_short_sync(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_short_sync(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_short_sync(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_short_sync(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_mono(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_mono(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_mono(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_mono(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_msb_right(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_msb_right(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_msb_right(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_msb_right(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_loopback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_loopback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_reset: u32,
        rx_reset: u32,
        tx_fifo_reset: u32,
        rx_fifo_reset: u32,
        tx_start: u32,
        rx_start: u32,
        tx_slave_mod: u32,
        rx_slave_mod: u32,
        tx_right_first: u32,
        rx_right_first: u32,
        tx_msb_shift: u32,
        rx_msb_shift: u32,
        tx_short_sync: u32,
        rx_short_sync: u32,
        tx_mono: u32,
        rx_mono: u32,
        tx_msb_right: u32,
        rx_msb_right: u32,
        sig_loopback: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tx_reset: u32 = unsafe { ::core::mem::transmute(tx_reset) };
            tx_reset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rx_reset: u32 = unsafe { ::core::mem::transmute(rx_reset) };
            rx_reset as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tx_fifo_reset: u32 = unsafe { ::core::mem::transmute(tx_fifo_reset) };
            tx_fifo_reset as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rx_fifo_reset: u32 = unsafe { ::core::mem::transmute(rx_fifo_reset) };
            rx_fifo_reset as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tx_slave_mod: u32 = unsafe { ::core::mem::transmute(tx_slave_mod) };
            tx_slave_mod as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rx_slave_mod: u32 = unsafe { ::core::mem::transmute(rx_slave_mod) };
            rx_slave_mod as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tx_right_first: u32 = unsafe { ::core::mem::transmute(tx_right_first) };
            tx_right_first as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let rx_right_first: u32 = unsafe { ::core::mem::transmute(rx_right_first) };
            rx_right_first as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let tx_msb_shift: u32 = unsafe { ::core::mem::transmute(tx_msb_shift) };
            tx_msb_shift as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let rx_msb_shift: u32 = unsafe { ::core::mem::transmute(rx_msb_shift) };
            rx_msb_shift as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tx_short_sync: u32 = unsafe { ::core::mem::transmute(tx_short_sync) };
            tx_short_sync as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_short_sync: u32 = unsafe { ::core::mem::transmute(rx_short_sync) };
            rx_short_sync as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_mono: u32 = unsafe { ::core::mem::transmute(tx_mono) };
            tx_mono as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rx_mono: u32 = unsafe { ::core::mem::transmute(rx_mono) };
            rx_mono as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let tx_msb_right: u32 = unsafe { ::core::mem::transmute(tx_msb_right) };
            tx_msb_right as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_msb_right: u32 = unsafe { ::core::mem::transmute(rx_msb_right) };
            rx_msb_right as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sig_loopback: u32 = unsafe { ::core::mem::transmute(sig_loopback) };
            sig_loopback as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn rx_take_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_take_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_put_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_put_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_take_data: u32,
        tx_put_data: u32,
        rx_wfull: u32,
        rx_rempty: u32,
        tx_wfull: u32,
        tx_rempty: u32,
        rx_hung: u32,
        tx_hung: u32,
        in_done: u32,
        in_suc_eof: u32,
        in_err_eof: u32,
        out_done: u32,
        out_eof: u32,
        in_dscr_err: u32,
        out_dscr_err: u32,
        in_dscr_empty: u32,
        out_total_eof: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rx_take_data: u32 = unsafe { ::core::mem::transmute(rx_take_data) };
            rx_take_data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tx_put_data: u32 = unsafe { ::core::mem::transmute(tx_put_data) };
            tx_put_data as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rx_wfull: u32 = unsafe { ::core::mem::transmute(rx_wfull) };
            rx_wfull as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rx_rempty: u32 = unsafe { ::core::mem::transmute(rx_rempty) };
            rx_rempty as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tx_wfull: u32 = unsafe { ::core::mem::transmute(tx_wfull) };
            tx_wfull as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tx_rempty: u32 = unsafe { ::core::mem::transmute(tx_rempty) };
            tx_rempty as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rx_hung: u32 = unsafe { ::core::mem::transmute(rx_hung) };
            rx_hung as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tx_hung: u32 = unsafe { ::core::mem::transmute(tx_hung) };
            tx_hung as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let in_dscr_err: u32 = unsafe { ::core::mem::transmute(in_dscr_err) };
            in_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let out_dscr_err: u32 = unsafe { ::core::mem::transmute(out_dscr_err) };
            out_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let in_dscr_empty: u32 = unsafe { ::core::mem::transmute(in_dscr_empty) };
            in_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn rx_take_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_take_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_put_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_put_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_take_data: u32,
        tx_put_data: u32,
        rx_wfull: u32,
        rx_rempty: u32,
        tx_wfull: u32,
        tx_rempty: u32,
        rx_hung: u32,
        tx_hung: u32,
        in_done: u32,
        in_suc_eof: u32,
        in_err_eof: u32,
        out_done: u32,
        out_eof: u32,
        in_dscr_err: u32,
        out_dscr_err: u32,
        in_dscr_empty: u32,
        out_total_eof: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rx_take_data: u32 = unsafe { ::core::mem::transmute(rx_take_data) };
            rx_take_data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tx_put_data: u32 = unsafe { ::core::mem::transmute(tx_put_data) };
            tx_put_data as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rx_wfull: u32 = unsafe { ::core::mem::transmute(rx_wfull) };
            rx_wfull as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rx_rempty: u32 = unsafe { ::core::mem::transmute(rx_rempty) };
            rx_rempty as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tx_wfull: u32 = unsafe { ::core::mem::transmute(tx_wfull) };
            tx_wfull as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tx_rempty: u32 = unsafe { ::core::mem::transmute(tx_rempty) };
            tx_rempty as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rx_hung: u32 = unsafe { ::core::mem::transmute(rx_hung) };
            rx_hung as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tx_hung: u32 = unsafe { ::core::mem::transmute(tx_hung) };
            tx_hung as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let in_dscr_err: u32 = unsafe { ::core::mem::transmute(in_dscr_err) };
            in_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let out_dscr_err: u32 = unsafe { ::core::mem::transmute(out_dscr_err) };
            out_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let in_dscr_empty: u32 = unsafe { ::core::mem::transmute(in_dscr_empty) };
            in_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_3 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn rx_take_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_take_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_put_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_put_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_take_data: u32,
        tx_put_data: u32,
        rx_wfull: u32,
        rx_rempty: u32,
        tx_wfull: u32,
        tx_rempty: u32,
        rx_hung: u32,
        tx_hung: u32,
        in_done: u32,
        in_suc_eof: u32,
        in_err_eof: u32,
        out_done: u32,
        out_eof: u32,
        in_dscr_err: u32,
        out_dscr_err: u32,
        in_dscr_empty: u32,
        out_total_eof: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rx_take_data: u32 = unsafe { ::core::mem::transmute(rx_take_data) };
            rx_take_data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tx_put_data: u32 = unsafe { ::core::mem::transmute(tx_put_data) };
            tx_put_data as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rx_wfull: u32 = unsafe { ::core::mem::transmute(rx_wfull) };
            rx_wfull as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rx_rempty: u32 = unsafe { ::core::mem::transmute(rx_rempty) };
            rx_rempty as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tx_wfull: u32 = unsafe { ::core::mem::transmute(tx_wfull) };
            tx_wfull as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tx_rempty: u32 = unsafe { ::core::mem::transmute(tx_rempty) };
            tx_rempty as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rx_hung: u32 = unsafe { ::core::mem::transmute(rx_hung) };
            rx_hung as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tx_hung: u32 = unsafe { ::core::mem::transmute(tx_hung) };
            tx_hung as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let in_dscr_err: u32 = unsafe { ::core::mem::transmute(in_dscr_err) };
            in_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let out_dscr_err: u32 = unsafe { ::core::mem::transmute(out_dscr_err) };
            out_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let in_dscr_empty: u32 = unsafe { ::core::mem::transmute(in_dscr_empty) };
            in_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_4 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn take_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_take_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn put_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_put_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        take_data: u32,
        put_data: u32,
        rx_wfull: u32,
        rx_rempty: u32,
        tx_wfull: u32,
        tx_rempty: u32,
        rx_hung: u32,
        tx_hung: u32,
        in_done: u32,
        in_suc_eof: u32,
        in_err_eof: u32,
        out_done: u32,
        out_eof: u32,
        in_dscr_err: u32,
        out_dscr_err: u32,
        in_dscr_empty: u32,
        out_total_eof: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let take_data: u32 = unsafe { ::core::mem::transmute(take_data) };
            take_data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let put_data: u32 = unsafe { ::core::mem::transmute(put_data) };
            put_data as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rx_wfull: u32 = unsafe { ::core::mem::transmute(rx_wfull) };
            rx_wfull as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rx_rempty: u32 = unsafe { ::core::mem::transmute(rx_rempty) };
            rx_rempty as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tx_wfull: u32 = unsafe { ::core::mem::transmute(tx_wfull) };
            tx_wfull as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tx_rempty: u32 = unsafe { ::core::mem::transmute(tx_rempty) };
            tx_rempty as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rx_hung: u32 = unsafe { ::core::mem::transmute(rx_hung) };
            rx_hung as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tx_hung: u32 = unsafe { ::core::mem::transmute(tx_hung) };
            tx_hung as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let in_dscr_err: u32 = unsafe { ::core::mem::transmute(in_dscr_err) };
            in_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let out_dscr_err: u32 = unsafe { ::core::mem::transmute(out_dscr_err) };
            out_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let in_dscr_empty: u32 = unsafe { ::core::mem::transmute(in_dscr_empty) };
            in_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_5 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl i2s_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn tx_bck_in_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_bck_in_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ws_in_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ws_in_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_bck_in_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_bck_in_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_ws_in_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_ws_in_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sd_in_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sd_in_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_bck_out_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_bck_out_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ws_out_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ws_out_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_sd_out_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_sd_out_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_ws_out_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_ws_out_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_bck_out_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_bck_out_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dsync_sw(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dsync_sw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dsync_sw(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dsync_sw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_enable_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_data_enable_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_bck_in_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_bck_in_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_bck_in_delay: u32,
        tx_ws_in_delay: u32,
        rx_bck_in_delay: u32,
        rx_ws_in_delay: u32,
        rx_sd_in_delay: u32,
        tx_bck_out_delay: u32,
        tx_ws_out_delay: u32,
        tx_sd_out_delay: u32,
        rx_ws_out_delay: u32,
        rx_bck_out_delay: u32,
        tx_dsync_sw: u32,
        rx_dsync_sw: u32,
        data_enable_delay: u32,
        tx_bck_in_inv: u32,
        reserved25: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let tx_bck_in_delay: u32 = unsafe { ::core::mem::transmute(tx_bck_in_delay) };
            tx_bck_in_delay as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let tx_ws_in_delay: u32 = unsafe { ::core::mem::transmute(tx_ws_in_delay) };
            tx_ws_in_delay as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let rx_bck_in_delay: u32 = unsafe { ::core::mem::transmute(rx_bck_in_delay) };
            rx_bck_in_delay as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let rx_ws_in_delay: u32 = unsafe { ::core::mem::transmute(rx_ws_in_delay) };
            rx_ws_in_delay as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let rx_sd_in_delay: u32 = unsafe { ::core::mem::transmute(rx_sd_in_delay) };
            rx_sd_in_delay as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let tx_bck_out_delay: u32 = unsafe { ::core::mem::transmute(tx_bck_out_delay) };
            tx_bck_out_delay as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let tx_ws_out_delay: u32 = unsafe { ::core::mem::transmute(tx_ws_out_delay) };
            tx_ws_out_delay as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let tx_sd_out_delay: u32 = unsafe { ::core::mem::transmute(tx_sd_out_delay) };
            tx_sd_out_delay as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let rx_ws_out_delay: u32 = unsafe { ::core::mem::transmute(rx_ws_out_delay) };
            rx_ws_out_delay as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let rx_bck_out_delay: u32 = unsafe { ::core::mem::transmute(rx_bck_out_delay) };
            rx_bck_out_delay as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let tx_dsync_sw: u32 = unsafe { ::core::mem::transmute(tx_dsync_sw) };
            tx_dsync_sw as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let rx_dsync_sw: u32 = unsafe { ::core::mem::transmute(rx_dsync_sw) };
            rx_dsync_sw as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let data_enable_delay: u32 = unsafe { ::core::mem::transmute(data_enable_delay) };
            data_enable_delay as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_bck_in_inv: u32 = unsafe { ::core::mem::transmute(tx_bck_in_inv) };
            tx_bck_in_inv as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_6 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn rx_data_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_rx_data_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_data_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_tx_data_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn dscr_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dscr_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_fifo_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tx_fifo_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_fifo_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_fifo_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_fifo_mod_force_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_fifo_mod_force_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_fifo_mod_force_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_fifo_mod_force_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_data_num: u32,
        tx_data_num: u32,
        dscr_en: u32,
        tx_fifo_mod: u32,
        rx_fifo_mod: u32,
        tx_fifo_mod_force_en: u32,
        rx_fifo_mod_force_en: u32,
        reserved21: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let rx_data_num: u32 = unsafe { ::core::mem::transmute(rx_data_num) };
            rx_data_num as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let tx_data_num: u32 = unsafe { ::core::mem::transmute(tx_data_num) };
            tx_data_num as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let dscr_en: u32 = unsafe { ::core::mem::transmute(dscr_en) };
            dscr_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let tx_fifo_mod: u32 = unsafe { ::core::mem::transmute(tx_fifo_mod) };
            tx_fifo_mod as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let rx_fifo_mod: u32 = unsafe { ::core::mem::transmute(rx_fifo_mod) };
            rx_fifo_mod as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_fifo_mod_force_en: u32 = unsafe { ::core::mem::transmute(tx_fifo_mod_force_en) };
            tx_fifo_mod_force_en as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_fifo_mod_force_en: u32 = unsafe { ::core::mem::transmute(rx_fifo_mod_force_en) };
            rx_fifo_mod_force_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_7 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn tx_chan_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tx_chan_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_chan_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_chan_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_chan_mod: u32,
        rx_chan_mod: u32,
        reserved5: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let tx_chan_mod: u32 = unsafe { ::core::mem::transmute(tx_chan_mod) };
            tx_chan_mod as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let rx_chan_mod: u32 = unsafe { ::core::mem::transmute(rx_chan_mod) };
            rx_chan_mod as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved5: u32 = unsafe { ::core::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_8 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn park(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_park(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        reserved20: u32,
        stop: u32,
        start: u32,
        restart: u32,
        park: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let park: u32 = unsafe { ::core::mem::transmute(park) };
            park as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_9 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_9 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn park(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_park(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        reserved20: u32,
        stop: u32,
        start: u32,
        restart: u32,
        park: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let park: u32 = unsafe { ::core::mem::transmute(park) };
            park as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_10 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_10 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mode: u32,
        reserved3: u32,
        addr: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let mode: u32 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved6: u32 = unsafe { ::core::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_11 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_11 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn in_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ahbm_fifo_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ahbm_fifo_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ahbm_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ahbm_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_auto_wrback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_auto_wrback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_no_restart_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_no_restart_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outdscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outdscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn indscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_indscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_data_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_data_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn check_owner(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_check_owner(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_trans_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_trans_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_rst: u32,
        out_rst: u32,
        ahbm_fifo_rst: u32,
        ahbm_rst: u32,
        out_loop_test: u32,
        in_loop_test: u32,
        out_auto_wrback: u32,
        out_no_restart_clr: u32,
        out_eof_mode: u32,
        outdscr_burst_en: u32,
        indscr_burst_en: u32,
        out_data_burst_en: u32,
        check_owner: u32,
        mem_trans_en: u32,
        reserved14: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_rst: u32 = unsafe { ::core::mem::transmute(in_rst) };
            in_rst as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let out_rst: u32 = unsafe { ::core::mem::transmute(out_rst) };
            out_rst as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ahbm_fifo_rst: u32 = unsafe { ::core::mem::transmute(ahbm_fifo_rst) };
            ahbm_fifo_rst as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ahbm_rst: u32 = unsafe { ::core::mem::transmute(ahbm_rst) };
            ahbm_rst as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let out_loop_test: u32 = unsafe { ::core::mem::transmute(out_loop_test) };
            out_loop_test as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let in_loop_test: u32 = unsafe { ::core::mem::transmute(in_loop_test) };
            in_loop_test as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let out_auto_wrback: u32 = unsafe { ::core::mem::transmute(out_auto_wrback) };
            out_auto_wrback as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_no_restart_clr: u32 = unsafe { ::core::mem::transmute(out_no_restart_clr) };
            out_no_restart_clr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_eof_mode: u32 = unsafe { ::core::mem::transmute(out_eof_mode) };
            out_eof_mode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outdscr_burst_en: u32 = unsafe { ::core::mem::transmute(outdscr_burst_en) };
            outdscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let indscr_burst_en: u32 = unsafe { ::core::mem::transmute(indscr_burst_en) };
            indscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let out_data_burst_en: u32 = unsafe { ::core::mem::transmute(out_data_burst_en) };
            out_data_burst_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let check_owner: u32 = unsafe { ::core::mem::transmute(check_owner) };
            check_owner as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let mem_trans_en: u32 = unsafe { ::core::mem::transmute(mem_trans_en) };
            mem_trans_en as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let reserved14: u32 = unsafe { ::core::mem::transmute(reserved14) };
            reserved14 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_12 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_12 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_12 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn wdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_wdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn push(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_push(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wdata: u32,
        reserved9: u32,
        push: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let wdata: u32 = unsafe { ::core::mem::transmute(wdata) };
            wdata as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let push: u32 = unsafe { ::core::mem::transmute(push) };
            push as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_13 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_13 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_13 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn rdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_rdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rdata: u32,
        reserved12: u32,
        pop: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let rdata: u32 = unsafe { ::core::mem::transmute(rdata) };
            rdata as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pop: u32 = unsafe { ::core::mem::transmute(pop) };
            pop as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_14 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_14 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_14 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn fifo_timeout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_timeout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn fifo_timeout_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_timeout_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn fifo_timeout_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_timeout_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fifo_timeout: u32,
        fifo_timeout_shift: u32,
        fifo_timeout_ena: u32,
        reserved12: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let fifo_timeout: u32 = unsafe { ::core::mem::transmute(fifo_timeout) };
            fifo_timeout as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let fifo_timeout_shift: u32 = unsafe { ::core::mem::transmute(fifo_timeout_shift) };
            fifo_timeout_shift as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let fifo_timeout_ena: u32 = unsafe { ::core::mem::transmute(fifo_timeout_ena) };
            fifo_timeout_ena as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_15 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_15 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_15 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn y_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_y_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn y_min(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_y_min(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(y_max: u32, y_min: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let y_max: u32 = unsafe { ::core::mem::transmute(y_max) };
            y_max as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let y_min: u32 = unsafe { ::core::mem::transmute(y_min) };
            y_min as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_16 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_16 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn sigma_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sigma_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn sigma_min(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sigma_min(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sigma_max: u32,
        sigma_min: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let sigma_max: u32 = unsafe { ::core::mem::transmute(sigma_max) };
            sigma_max as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let sigma_min: u32 = unsafe { ::core::mem::transmute(sigma_min) };
            sigma_min as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_17 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_17 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_17 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn cvsd_k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_j(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_j(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_beta(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_beta(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_h(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_h(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cvsd_k: u32,
        cvsd_j: u32,
        cvsd_beta: u32,
        cvsd_h: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let cvsd_k: u32 = unsafe { ::core::mem::transmute(cvsd_k) };
            cvsd_k as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let cvsd_j: u32 = unsafe { ::core::mem::transmute(cvsd_j) };
            cvsd_j as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let cvsd_beta: u32 = unsafe { ::core::mem::transmute(cvsd_beta) };
            cvsd_beta as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let cvsd_h: u32 = unsafe { ::core::mem::transmute(cvsd_h) };
            cvsd_h as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_18 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_18 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_18 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl i2s_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn good_pack_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_good_pack_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn n_err_seg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_n_err_seg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn shift_rate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_shift_rate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn max_slide_sample(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_slide_sample(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pack_len_8k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_pack_len_8k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn n_min_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_n_min_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        good_pack_max: u32,
        n_err_seg: u32,
        shift_rate: u32,
        max_slide_sample: u32,
        pack_len_8k: u32,
        n_min_err: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let good_pack_max: u32 = unsafe { ::core::mem::transmute(good_pack_max) };
            good_pack_max as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let n_err_seg: u32 = unsafe { ::core::mem::transmute(n_err_seg) };
            n_err_seg as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let shift_rate: u32 = unsafe { ::core::mem::transmute(shift_rate) };
            shift_rate as u64
        });
        __bindgen_bitfield_unit.set(12usize, 8u8, {
            let max_slide_sample: u32 = unsafe { ::core::mem::transmute(max_slide_sample) };
            max_slide_sample as u64
        });
        __bindgen_bitfield_unit.set(20usize, 5u8, {
            let pack_len_8k: u32 = unsafe { ::core::mem::transmute(pack_len_8k) };
            pack_len_8k as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let n_min_err: u32 = unsafe { ::core::mem::transmute(n_min_err) };
            n_min_err as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_19 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_19 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_19 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl i2s_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn bad_cef_atten_para(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_bad_cef_atten_para(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn bad_cef_atten_para_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bad_cef_atten_para_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bad_ola_win2_para_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bad_ola_win2_para_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bad_ola_win2_para(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_bad_ola_win2_para(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn slide_win_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_slide_win_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bad_cef_atten_para: u32,
        bad_cef_atten_para_shift: u32,
        bad_ola_win2_para_shift: u32,
        bad_ola_win2_para: u32,
        slide_win_len: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let bad_cef_atten_para: u32 = unsafe { ::core::mem::transmute(bad_cef_atten_para) };
            bad_cef_atten_para as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let bad_cef_atten_para_shift: u32 =
                unsafe { ::core::mem::transmute(bad_cef_atten_para_shift) };
            bad_cef_atten_para_shift as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let bad_ola_win2_para_shift: u32 =
                unsafe { ::core::mem::transmute(bad_ola_win2_para_shift) };
            bad_ola_win2_para_shift as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let bad_ola_win2_para: u32 = unsafe { ::core::mem::transmute(bad_ola_win2_para) };
            bad_ola_win2_para as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let slide_win_len: u32 = unsafe { ::core::mem::transmute(slide_win_len) };
            slide_win_len as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_20 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_20 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_20 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn cvsd_seg_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_seg_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn min_period(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_min_period(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cvsd_seg_mod: u32,
        min_period: u32,
        reserved7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let cvsd_seg_mod: u32 = unsafe { ::core::mem::transmute(cvsd_seg_mod) };
            cvsd_seg_mod as u64
        });
        __bindgen_bitfield_unit.set(2usize, 5u8, {
            let min_period: u32 = unsafe { ::core::mem::transmute(min_period) };
            min_period as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let reserved7: u32 = unsafe { ::core::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_21 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_21 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_21 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chan_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chan_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_dec_pack_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_dec_pack_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_pack_len_8k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_pack_len_8k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_inf_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_inf_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_dec_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_dec_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_dec_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_dec_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plc_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plc_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plc2dma_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plc2dma_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        en: u32,
        chan_mod: u32,
        cvsd_dec_pack_err: u32,
        cvsd_pack_len_8k: u32,
        cvsd_inf_en: u32,
        cvsd_dec_start: u32,
        cvsd_dec_reset: u32,
        plc_en: u32,
        plc2dma_en: u32,
        reserved13: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let chan_mod: u32 = unsafe { ::core::mem::transmute(chan_mod) };
            chan_mod as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cvsd_dec_pack_err: u32 = unsafe { ::core::mem::transmute(cvsd_dec_pack_err) };
            cvsd_dec_pack_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let cvsd_pack_len_8k: u32 = unsafe { ::core::mem::transmute(cvsd_pack_len_8k) };
            cvsd_pack_len_8k as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cvsd_inf_en: u32 = unsafe { ::core::mem::transmute(cvsd_inf_en) };
            cvsd_inf_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let cvsd_dec_start: u32 = unsafe { ::core::mem::transmute(cvsd_dec_start) };
            cvsd_dec_start as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let cvsd_dec_reset: u32 = unsafe { ::core::mem::transmute(cvsd_dec_reset) };
            cvsd_dec_reset as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let plc_en: u32 = unsafe { ::core::mem::transmute(plc_en) };
            plc_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let plc2dma_en: u32 = unsafe { ::core::mem::transmute(plc2dma_en) };
            plc2dma_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let reserved13: u32 = unsafe { ::core::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_22 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_22 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_22 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn with_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_with_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_enc_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_enc_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_enc_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_enc_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        with_en: u32,
        no_en: u32,
        cvsd_enc_start: u32,
        cvsd_enc_reset: u32,
        reserved4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let with_en: u32 = unsafe { ::core::mem::transmute(with_en) };
            with_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let no_en: u32 = unsafe { ::core::mem::transmute(no_en) };
            no_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cvsd_enc_start: u32 = unsafe { ::core::mem::transmute(cvsd_enc_start) };
            cvsd_enc_start as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cvsd_enc_reset: u32 = unsafe { ::core::mem::transmute(cvsd_enc_reset) };
            cvsd_enc_reset as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_23 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_23 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_23 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_24 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn tx_pcm_conf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tx_pcm_conf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_pcm_bypass(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_pcm_bypass(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pcm_conf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pcm_conf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pcm_bypass(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pcm_bypass(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_stop_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_stop_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_zeros_rm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_zeros_rm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_pcm_conf: u32,
        tx_pcm_bypass: u32,
        rx_pcm_conf: u32,
        rx_pcm_bypass: u32,
        tx_stop_en: u32,
        tx_zeros_rm_en: u32,
        reserved10: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let tx_pcm_conf: u32 = unsafe { ::core::mem::transmute(tx_pcm_conf) };
            tx_pcm_conf as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tx_pcm_bypass: u32 = unsafe { ::core::mem::transmute(tx_pcm_bypass) };
            tx_pcm_bypass as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let rx_pcm_conf: u32 = unsafe { ::core::mem::transmute(rx_pcm_conf) };
            rx_pcm_conf as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rx_pcm_bypass: u32 = unsafe { ::core::mem::transmute(rx_pcm_bypass) };
            rx_pcm_bypass as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tx_stop_en: u32 = unsafe { ::core::mem::transmute(tx_stop_en) };
            tx_stop_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_zeros_rm_en: u32 = unsafe { ::core::mem::transmute(tx_zeros_rm_en) };
            tx_zeros_rm_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_24 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_24 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_24 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_25 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_25__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_25__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_25__bindgen_ty_1 {
    #[inline]
    pub fn fifo_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fifo_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plc_mem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plc_mem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plc_mem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plc_mem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fifo_force_pd: u32,
        fifo_force_pu: u32,
        plc_mem_force_pd: u32,
        plc_mem_force_pu: u32,
        reserved4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fifo_force_pd: u32 = unsafe { ::core::mem::transmute(fifo_force_pd) };
            fifo_force_pd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fifo_force_pu: u32 = unsafe { ::core::mem::transmute(fifo_force_pu) };
            fifo_force_pu as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let plc_mem_force_pd: u32 = unsafe { ::core::mem::transmute(plc_mem_force_pd) };
            plc_mem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let plc_mem_force_pu: u32 = unsafe { ::core::mem::transmute(plc_mem_force_pu) };
            plc_mem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_25 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_25 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_25 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_26 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_26__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_26__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_26__bindgen_ty_1 {
    #[inline]
    pub fn camera_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_camera_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lcd_tx_wrx2_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lcd_tx_wrx2_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lcd_tx_sdx2_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lcd_tx_sdx2_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_enable_test_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_enable_test_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lcd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lcd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_adc_start_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_adc_start_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_valid_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_valid_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        camera_en: u32,
        lcd_tx_wrx2_en: u32,
        lcd_tx_sdx2_en: u32,
        data_enable_test_en: u32,
        data_enable: u32,
        lcd_en: u32,
        ext_adc_start_en: u32,
        inter_valid_en: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let camera_en: u32 = unsafe { ::core::mem::transmute(camera_en) };
            camera_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lcd_tx_wrx2_en: u32 = unsafe { ::core::mem::transmute(lcd_tx_wrx2_en) };
            lcd_tx_wrx2_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lcd_tx_sdx2_en: u32 = unsafe { ::core::mem::transmute(lcd_tx_sdx2_en) };
            lcd_tx_sdx2_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let data_enable_test_en: u32 = unsafe { ::core::mem::transmute(data_enable_test_en) };
            data_enable_test_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let data_enable: u32 = unsafe { ::core::mem::transmute(data_enable) };
            data_enable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let lcd_en: u32 = unsafe { ::core::mem::transmute(lcd_en) };
            lcd_en as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ext_adc_start_en: u32 = unsafe { ::core::mem::transmute(ext_adc_start_en) };
            ext_adc_start_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let inter_valid_en: u32 = unsafe { ::core::mem::transmute(inter_valid_en) };
            inter_valid_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_26 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_26 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_26 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_27 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_27__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_27__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_27__bindgen_ty_1 {
    #[inline]
    pub fn clkm_div_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_clkm_div_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn clkm_div_b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_clkm_div_b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn clkm_div_a(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_clkm_div_a(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clka_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clka_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved22(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved22(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clkm_div_num: u32,
        clkm_div_b: u32,
        clkm_div_a: u32,
        clk_en: u32,
        clka_en: u32,
        reserved22: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let clkm_div_num: u32 = unsafe { ::core::mem::transmute(clkm_div_num) };
            clkm_div_num as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let clkm_div_b: u32 = unsafe { ::core::mem::transmute(clkm_div_b) };
            clkm_div_b as u64
        });
        __bindgen_bitfield_unit.set(14usize, 6u8, {
            let clkm_div_a: u32 = unsafe { ::core::mem::transmute(clkm_div_a) };
            clkm_div_a as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let clka_en: u32 = unsafe { ::core::mem::transmute(clka_en) };
            clka_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved22: u32 = unsafe { ::core::mem::transmute(reserved22) };
            reserved22 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_27 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_27 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_27 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_28 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_28__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_28__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl i2s_dev_s__bindgen_ty_28__bindgen_ty_1 {
    #[inline]
    pub fn tx_bck_div_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_tx_bck_div_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_bck_div_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_rx_bck_div_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_bits_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_tx_bits_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_bits_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_rx_bits_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_bck_div_num: u32,
        rx_bck_div_num: u32,
        tx_bits_mod: u32,
        rx_bits_mod: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let tx_bck_div_num: u32 = unsafe { ::core::mem::transmute(tx_bck_div_num) };
            tx_bck_div_num as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let rx_bck_div_num: u32 = unsafe { ::core::mem::transmute(rx_bck_div_num) };
            rx_bck_div_num as u64
        });
        __bindgen_bitfield_unit.set(12usize, 6u8, {
            let tx_bits_mod: u32 = unsafe { ::core::mem::transmute(tx_bits_mod) };
            tx_bits_mod as u64
        });
        __bindgen_bitfield_unit.set(18usize, 6u8, {
            let rx_bits_mod: u32 = unsafe { ::core::mem::transmute(rx_bits_mod) };
            rx_bits_mod as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_28 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_28 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_28 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_29 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_29__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl i2s_dev_s__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn tx_pdm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_pdm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pdm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pdm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pcm2pdm_conv_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pcm2pdm_conv_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdm2pcm_conv_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdm2pcm_conv_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_sinc_osr2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tx_sinc_osr2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_prescale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tx_prescale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_hp_in_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_hp_in_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_lp_in_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_lp_in_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_sinc_in_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_sinc_in_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_sigmadelta_in_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_sigmadelta_in_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sinc_dsr_16_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sinc_dsr_16_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txhp_bypass(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txhp_bypass(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_pdm_en: u32,
        rx_pdm_en: u32,
        pcm2pdm_conv_en: u32,
        pdm2pcm_conv_en: u32,
        tx_sinc_osr2: u32,
        tx_prescale: u32,
        tx_hp_in_shift: u32,
        tx_lp_in_shift: u32,
        tx_sinc_in_shift: u32,
        tx_sigmadelta_in_shift: u32,
        rx_sinc_dsr_16_en: u32,
        txhp_bypass: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tx_pdm_en: u32 = unsafe { ::core::mem::transmute(tx_pdm_en) };
            tx_pdm_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rx_pdm_en: u32 = unsafe { ::core::mem::transmute(rx_pdm_en) };
            rx_pdm_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pcm2pdm_conv_en: u32 = unsafe { ::core::mem::transmute(pcm2pdm_conv_en) };
            pcm2pdm_conv_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pdm2pcm_conv_en: u32 = unsafe { ::core::mem::transmute(pdm2pcm_conv_en) };
            pdm2pcm_conv_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tx_sinc_osr2: u32 = unsafe { ::core::mem::transmute(tx_sinc_osr2) };
            tx_sinc_osr2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let tx_prescale: u32 = unsafe { ::core::mem::transmute(tx_prescale) };
            tx_prescale as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let tx_hp_in_shift: u32 = unsafe { ::core::mem::transmute(tx_hp_in_shift) };
            tx_hp_in_shift as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let tx_lp_in_shift: u32 = unsafe { ::core::mem::transmute(tx_lp_in_shift) };
            tx_lp_in_shift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let tx_sinc_in_shift: u32 = unsafe { ::core::mem::transmute(tx_sinc_in_shift) };
            tx_sinc_in_shift as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let tx_sigmadelta_in_shift: u32 =
                unsafe { ::core::mem::transmute(tx_sigmadelta_in_shift) };
            tx_sigmadelta_in_shift as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rx_sinc_dsr_16_en: u32 = unsafe { ::core::mem::transmute(rx_sinc_dsr_16_en) };
            rx_sinc_dsr_16_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let txhp_bypass: u32 = unsafe { ::core::mem::transmute(txhp_bypass) };
            txhp_bypass as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_29 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_29 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_29 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_30 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_30__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_30__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_30__bindgen_ty_1 {
    #[inline]
    pub fn tx_pdm_fs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_tx_pdm_fs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_pdm_fp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_tx_pdm_fp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_pdm_fs: u32,
        tx_pdm_fp: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let tx_pdm_fs: u32 = unsafe { ::core::mem::transmute(tx_pdm_fs) };
            tx_pdm_fs as u64
        });
        __bindgen_bitfield_unit.set(10usize, 10u8, {
            let tx_pdm_fp: u32 = unsafe { ::core::mem::transmute(tx_pdm_fp) };
            tx_pdm_fp as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_30 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_30 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_30 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_31 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_31__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_dev_s__bindgen_ty_31__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_31__bindgen_ty_1 {
    #[inline]
    pub fn tx_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_fifo_reset_back(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_fifo_reset_back(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_fifo_reset_back(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_fifo_reset_back(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_idle: u32,
        tx_fifo_reset_back: u32,
        rx_fifo_reset_back: u32,
        reserved3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tx_idle: u32 = unsafe { ::core::mem::transmute(tx_idle) };
            tx_idle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tx_fifo_reset_back: u32 = unsafe { ::core::mem::transmute(tx_fifo_reset_back) };
            tx_fifo_reset_back as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rx_fifo_reset_back: u32 = unsafe { ::core::mem::transmute(rx_fifo_reset_back) };
            rx_fifo_reset_back as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for i2s_dev_s__bindgen_ty_31 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s__bindgen_ty_31 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "i2s_dev_s__bindgen_ty_31 {{ union }}")
    }
}
impl Default for i2s_dev_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for i2s_dev_s {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "i2s_dev_s {{ reserved_0: {:?}, reserved_4: {:?}, conf: {:?}, int_raw: {:?}, int_st: {:?}, int_ena: {:?}, int_clr: {:?}, timing: {:?}, fifo_conf: {:?}, rx_eof_num: {:?}, conf_single_data: {:?}, conf_chan: {:?}, out_link: {:?}, in_link: {:?}, out_eof_des_addr: {:?}, in_eof_des_addr: {:?}, out_eof_bfr_des_addr: {:?}, ahb_test: {:?}, in_link_dscr: {:?}, in_link_dscr_bf0: {:?}, in_link_dscr_bf1: {:?}, out_link_dscr: {:?}, out_link_dscr_bf0: {:?}, out_link_dscr_bf1: {:?}, lc_conf: {:?}, out_fifo_push: {:?}, in_fifo_pop: {:?}, lc_state0: {:?}, lc_state1: {:?}, lc_hung_conf: {:?}, reserved_78: {:?}, reserved_7c: {:?}, cvsd_conf0: {:?}, cvsd_conf1: {:?}, cvsd_conf2: {:?}, plc_conf0: {:?}, plc_conf1: {:?}, plc_conf2: {:?}, esco_conf0: {:?}, sco_conf0: {:?}, conf1: {:?}, pd_conf: {:?}, conf2: {:?}, clkm_conf: {:?}, sample_rate_conf: {:?}, pdm_conf: {:?}, pdm_freq_conf: {:?}, state: {:?}, reserved_c0: {:?}, reserved_c4: {:?}, reserved_c8: {:?}, reserved_cc: {:?}, reserved_d0: {:?}, reserved_d4: {:?}, reserved_d8: {:?}, reserved_dc: {:?}, reserved_e0: {:?}, reserved_e4: {:?}, reserved_e8: {:?}, reserved_ec: {:?}, reserved_f0: {:?}, reserved_f4: {:?}, reserved_f8: {:?}, date: {:?} }}" , self . reserved_0 , self . reserved_4 , self . conf , self . int_raw , self . int_st , self . int_ena , self . int_clr , self . timing , self . fifo_conf , self . rx_eof_num , self . conf_single_data , self . conf_chan , self . out_link , self . in_link , self . out_eof_des_addr , self . in_eof_des_addr , self . out_eof_bfr_des_addr , self . ahb_test , self . in_link_dscr , self . in_link_dscr_bf0 , self . in_link_dscr_bf1 , self . out_link_dscr , self . out_link_dscr_bf0 , self . out_link_dscr_bf1 , self . lc_conf , self . out_fifo_push , self . in_fifo_pop , self . lc_state0 , self . lc_state1 , self . lc_hung_conf , self . reserved_78 , self . reserved_7c , self . cvsd_conf0 , self . cvsd_conf1 , self . cvsd_conf2 , self . plc_conf0 , self . plc_conf1 , self . plc_conf2 , self . esco_conf0 , self . sco_conf0 , self . conf1 , self . pd_conf , self . conf2 , self . clkm_conf , self . sample_rate_conf , self . pdm_conf , self . pdm_freq_conf , self . state , self . reserved_c0 , self . reserved_c4 , self . reserved_c8 , self . reserved_cc , self . reserved_d0 , self . reserved_d4 , self . reserved_d8 , self . reserved_dc , self . reserved_e0 , self . reserved_e4 , self . reserved_e8 , self . reserved_ec , self . reserved_f0 , self . reserved_f4 , self . reserved_f8 , self . date )
    }
}
pub type i2s_dev_t = i2s_dev_s;
extern "C" {
    pub static mut I2S0: i2s_dev_t;
}
extern "C" {
    pub static mut I2S1: i2s_dev_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtc_io_dev_s {
    pub out: rtc_io_dev_s__bindgen_ty_1,
    pub out_w1ts: rtc_io_dev_s__bindgen_ty_2,
    pub out_w1tc: rtc_io_dev_s__bindgen_ty_3,
    pub enable: rtc_io_dev_s__bindgen_ty_4,
    pub enable_w1ts: rtc_io_dev_s__bindgen_ty_5,
    pub enable_w1tc: rtc_io_dev_s__bindgen_ty_6,
    pub status: rtc_io_dev_s__bindgen_ty_7,
    pub status_w1ts: rtc_io_dev_s__bindgen_ty_8,
    pub status_w1tc: rtc_io_dev_s__bindgen_ty_9,
    pub in_val: rtc_io_dev_s__bindgen_ty_10,
    pub pin: [rtc_io_dev_s__bindgen_ty_11; 18usize],
    pub debug_sel: rtc_io_dev_s__bindgen_ty_12,
    pub dig_pad_hold: u32,
    pub hall_sens: rtc_io_dev_s__bindgen_ty_13,
    pub sensor_pads: rtc_io_dev_s__bindgen_ty_14,
    pub adc_pad: rtc_io_dev_s__bindgen_ty_15,
    pub pad_dac: [rtc_io_dev_s__bindgen_ty_16; 2usize],
    pub xtal_32k_pad: rtc_io_dev_s__bindgen_ty_17,
    pub touch_cfg: rtc_io_dev_s__bindgen_ty_18,
    pub touch_pad: [rtc_io_dev_s__bindgen_ty_19; 10usize],
    pub ext_wakeup0: rtc_io_dev_s__bindgen_ty_20,
    pub xtl_ext_ctr: rtc_io_dev_s__bindgen_ty_21,
    pub sar_i2c_io: rtc_io_dev_s__bindgen_ty_22,
    pub date: rtc_io_dev_s__bindgen_ty_23,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, data: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1ts: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1ts: u32 = unsafe { ::core::mem::transmute(w1ts) };
            w1ts as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1tc: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1tc: u32 = unsafe { ::core::mem::transmute(w1tc) };
            w1tc as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_3 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, enable: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let enable: u32 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_4 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1ts: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1ts: u32 = unsafe { ::core::mem::transmute(w1ts) };
            w1ts as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_5 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1tc: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1tc: u32 = unsafe { ::core::mem::transmute(w1tc) };
            w1tc as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_6 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, status: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let status: u32 = unsafe { ::core::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_7 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1ts: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1ts: u32 = unsafe { ::core::mem::transmute(w1ts) };
            w1ts as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_8 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1tc: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1tc: u32 = unsafe { ::core::mem::transmute(w1tc) };
            w1tc as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_9 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_9 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn in_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_in(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, in_: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let in_: u32 = unsafe { ::core::mem::transmute(in_) };
            in_ as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_10 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_10 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_driver(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad_driver(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        pad_driver: u32,
        reserved3: u32,
        int_type: u32,
        wakeup_enable: u32,
        reserved11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pad_driver: u32 = unsafe { ::core::mem::transmute(pad_driver) };
            pad_driver as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let int_type: u32 = unsafe { ::core::mem::transmute(int_type) };
            int_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wakeup_enable: u32 = unsafe { ::core::mem::transmute(wakeup_enable) };
            wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_11 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_11 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_io_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn sel0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sel1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sel2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sel3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sel4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn no_gating_12m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_gating_12m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sel0: u32,
        sel1: u32,
        sel2: u32,
        sel3: u32,
        sel4: u32,
        no_gating_12m: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let sel0: u32 = unsafe { ::core::mem::transmute(sel0) };
            sel0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let sel1: u32 = unsafe { ::core::mem::transmute(sel1) };
            sel1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let sel2: u32 = unsafe { ::core::mem::transmute(sel2) };
            sel2 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 5u8, {
            let sel3: u32 = unsafe { ::core::mem::transmute(sel3) };
            sel3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 5u8, {
            let sel4: u32 = unsafe { ::core::mem::transmute(sel4) };
            sel4 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let no_gating_12m: u32 = unsafe { ::core::mem::transmute(no_gating_12m) };
            no_gating_12m as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_12 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_12 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_12 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn hall_phase(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hall_phase(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_hall(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_hall(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        hall_phase: u32,
        xpd_hall: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let hall_phase: u32 = unsafe { ::core::mem::transmute(hall_phase) };
            hall_phase as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_hall: u32 = unsafe { ::core::mem::transmute(xpd_hall) };
            xpd_hall as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_13 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_13 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_13 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_io_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        sense4_fun_ie: u32,
        sense4_slp_ie: u32,
        sense4_slp_sel: u32,
        sense4_fun_sel: u32,
        sense3_fun_ie: u32,
        sense3_slp_ie: u32,
        sense3_slp_sel: u32,
        sense3_fun_sel: u32,
        sense2_fun_ie: u32,
        sense2_slp_ie: u32,
        sense2_slp_sel: u32,
        sense2_fun_sel: u32,
        sense1_fun_ie: u32,
        sense1_slp_ie: u32,
        sense1_slp_sel: u32,
        sense1_fun_sel: u32,
        sense4_mux_sel: u32,
        sense3_mux_sel: u32,
        sense2_mux_sel: u32,
        sense1_mux_sel: u32,
        sense4_hold: u32,
        sense3_hold: u32,
        sense2_hold: u32,
        sense1_hold: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sense4_fun_ie: u32 = unsafe { ::core::mem::transmute(sense4_fun_ie) };
            sense4_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sense4_slp_ie: u32 = unsafe { ::core::mem::transmute(sense4_slp_ie) };
            sense4_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sense4_slp_sel: u32 = unsafe { ::core::mem::transmute(sense4_slp_sel) };
            sense4_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let sense4_fun_sel: u32 = unsafe { ::core::mem::transmute(sense4_fun_sel) };
            sense4_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sense3_fun_ie: u32 = unsafe { ::core::mem::transmute(sense3_fun_ie) };
            sense3_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sense3_slp_ie: u32 = unsafe { ::core::mem::transmute(sense3_slp_ie) };
            sense3_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let sense3_slp_sel: u32 = unsafe { ::core::mem::transmute(sense3_slp_sel) };
            sense3_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let sense3_fun_sel: u32 = unsafe { ::core::mem::transmute(sense3_fun_sel) };
            sense3_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let sense2_fun_ie: u32 = unsafe { ::core::mem::transmute(sense2_fun_ie) };
            sense2_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let sense2_slp_ie: u32 = unsafe { ::core::mem::transmute(sense2_slp_ie) };
            sense2_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let sense2_slp_sel: u32 = unsafe { ::core::mem::transmute(sense2_slp_sel) };
            sense2_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let sense2_fun_sel: u32 = unsafe { ::core::mem::transmute(sense2_fun_sel) };
            sense2_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let sense1_fun_ie: u32 = unsafe { ::core::mem::transmute(sense1_fun_ie) };
            sense1_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let sense1_slp_ie: u32 = unsafe { ::core::mem::transmute(sense1_slp_ie) };
            sense1_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let sense1_slp_sel: u32 = unsafe { ::core::mem::transmute(sense1_slp_sel) };
            sense1_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let sense1_fun_sel: u32 = unsafe { ::core::mem::transmute(sense1_fun_sel) };
            sense1_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let sense4_mux_sel: u32 = unsafe { ::core::mem::transmute(sense4_mux_sel) };
            sense4_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let sense3_mux_sel: u32 = unsafe { ::core::mem::transmute(sense3_mux_sel) };
            sense3_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let sense2_mux_sel: u32 = unsafe { ::core::mem::transmute(sense2_mux_sel) };
            sense2_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let sense1_mux_sel: u32 = unsafe { ::core::mem::transmute(sense1_mux_sel) };
            sense1_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sense4_hold: u32 = unsafe { ::core::mem::transmute(sense4_hold) };
            sense4_hold as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let sense3_hold: u32 = unsafe { ::core::mem::transmute(sense3_hold) };
            sense3_hold as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let sense2_hold: u32 = unsafe { ::core::mem::transmute(sense2_hold) };
            sense2_hold as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sense1_hold: u32 = unsafe { ::core::mem::transmute(sense1_hold) };
            sense1_hold as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_14 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_14 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_14 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        adc2_fun_ie: u32,
        adc2_slp_ie: u32,
        adc2_slp_sel: u32,
        adc2_fun_sel: u32,
        adc1_fun_ie: u32,
        adc1_slp_ie: u32,
        adc1_slp_sel: u32,
        adc1_fun_sel: u32,
        adc2_mux_sel: u32,
        adc1_mux_sel: u32,
        adc2_hold: u32,
        adc1_hold: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let adc2_fun_ie: u32 = unsafe { ::core::mem::transmute(adc2_fun_ie) };
            adc2_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let adc2_slp_ie: u32 = unsafe { ::core::mem::transmute(adc2_slp_ie) };
            adc2_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let adc2_slp_sel: u32 = unsafe { ::core::mem::transmute(adc2_slp_sel) };
            adc2_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let adc2_fun_sel: u32 = unsafe { ::core::mem::transmute(adc2_fun_sel) };
            adc2_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let adc1_fun_ie: u32 = unsafe { ::core::mem::transmute(adc1_fun_ie) };
            adc1_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let adc1_slp_ie: u32 = unsafe { ::core::mem::transmute(adc1_slp_ie) };
            adc1_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let adc1_slp_sel: u32 = unsafe { ::core::mem::transmute(adc1_slp_sel) };
            adc1_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(26usize, 2u8, {
            let adc1_fun_sel: u32 = unsafe { ::core::mem::transmute(adc1_fun_sel) };
            adc1_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let adc2_mux_sel: u32 = unsafe { ::core::mem::transmute(adc2_mux_sel) };
            adc2_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let adc1_mux_sel: u32 = unsafe { ::core::mem::transmute(adc1_mux_sel) };
            adc1_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let adc2_hold: u32 = unsafe { ::core::mem::transmute(adc2_hold) };
            adc2_hold as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let adc1_hold: u32 = unsafe { ::core::mem::transmute(adc1_hold) };
            adc1_hold as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_15 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_15 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_15 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_io_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_xpd_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dac_xpd_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_oe(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_oe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_dac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_dac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rde(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rde(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dac_xpd_force: u32,
        fun_ie: u32,
        slp_oe: u32,
        slp_ie: u32,
        slp_sel: u32,
        fun_sel: u32,
        mux_sel: u32,
        xpd_dac: u32,
        dac: u32,
        rue: u32,
        rde: u32,
        hold: u32,
        drv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let dac_xpd_force: u32 = unsafe { ::core::mem::transmute(dac_xpd_force) };
            dac_xpd_force as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let fun_ie: u32 = unsafe { ::core::mem::transmute(fun_ie) };
            fun_ie as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let slp_oe: u32 = unsafe { ::core::mem::transmute(slp_oe) };
            slp_oe as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let slp_ie: u32 = unsafe { ::core::mem::transmute(slp_ie) };
            slp_ie as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let slp_sel: u32 = unsafe { ::core::mem::transmute(slp_sel) };
            slp_sel as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let fun_sel: u32 = unsafe { ::core::mem::transmute(fun_sel) };
            fun_sel as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let mux_sel: u32 = unsafe { ::core::mem::transmute(mux_sel) };
            mux_sel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let xpd_dac: u32 = unsafe { ::core::mem::transmute(xpd_dac) };
            xpd_dac as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let dac: u32 = unsafe { ::core::mem::transmute(dac) };
            dac as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let rue: u32 = unsafe { ::core::mem::transmute(rue) };
            rue as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rde: u32 = unsafe { ::core::mem::transmute(rde) };
            rde as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let hold: u32 = unsafe { ::core::mem::transmute(hold) };
            hold as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let drv: u32 = unsafe { ::core::mem::transmute(drv) };
            drv as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_16 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_16 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_io_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dbias_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dbias_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dres_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dres_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_slp_oe(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_slp_oe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_slp_oe(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_slp_oe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dac_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_rue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_rue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_rde(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_rde(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_drv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_drv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_rue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_rue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_rde(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_rde(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_drv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_drv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dbias_xtal_32k: u32,
        dres_xtal_32k: u32,
        x32p_fun_ie: u32,
        x32p_slp_oe: u32,
        x32p_slp_ie: u32,
        x32p_slp_sel: u32,
        x32p_fun_sel: u32,
        x32n_fun_ie: u32,
        x32n_slp_oe: u32,
        x32n_slp_ie: u32,
        x32n_slp_sel: u32,
        x32n_fun_sel: u32,
        x32p_mux_sel: u32,
        x32n_mux_sel: u32,
        xpd_xtal_32k: u32,
        dac_xtal_32k: u32,
        x32p_rue: u32,
        x32p_rde: u32,
        x32p_hold: u32,
        x32p_drv: u32,
        x32n_rue: u32,
        x32n_rde: u32,
        x32n_hold: u32,
        x32n_drv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let dbias_xtal_32k: u32 = unsafe { ::core::mem::transmute(dbias_xtal_32k) };
            dbias_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let dres_xtal_32k: u32 = unsafe { ::core::mem::transmute(dres_xtal_32k) };
            dres_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let x32p_fun_ie: u32 = unsafe { ::core::mem::transmute(x32p_fun_ie) };
            x32p_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let x32p_slp_oe: u32 = unsafe { ::core::mem::transmute(x32p_slp_oe) };
            x32p_slp_oe as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let x32p_slp_ie: u32 = unsafe { ::core::mem::transmute(x32p_slp_ie) };
            x32p_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let x32p_slp_sel: u32 = unsafe { ::core::mem::transmute(x32p_slp_sel) };
            x32p_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let x32p_fun_sel: u32 = unsafe { ::core::mem::transmute(x32p_fun_sel) };
            x32p_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let x32n_fun_ie: u32 = unsafe { ::core::mem::transmute(x32n_fun_ie) };
            x32n_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let x32n_slp_oe: u32 = unsafe { ::core::mem::transmute(x32n_slp_oe) };
            x32n_slp_oe as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let x32n_slp_ie: u32 = unsafe { ::core::mem::transmute(x32n_slp_ie) };
            x32n_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let x32n_slp_sel: u32 = unsafe { ::core::mem::transmute(x32n_slp_sel) };
            x32n_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let x32n_fun_sel: u32 = unsafe { ::core::mem::transmute(x32n_fun_sel) };
            x32n_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let x32p_mux_sel: u32 = unsafe { ::core::mem::transmute(x32p_mux_sel) };
            x32p_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let x32n_mux_sel: u32 = unsafe { ::core::mem::transmute(x32n_mux_sel) };
            x32n_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let xpd_xtal_32k: u32 = unsafe { ::core::mem::transmute(xpd_xtal_32k) };
            xpd_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let dac_xtal_32k: u32 = unsafe { ::core::mem::transmute(dac_xtal_32k) };
            dac_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let x32p_rue: u32 = unsafe { ::core::mem::transmute(x32p_rue) };
            x32p_rue as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let x32p_rde: u32 = unsafe { ::core::mem::transmute(x32p_rde) };
            x32p_rde as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let x32p_hold: u32 = unsafe { ::core::mem::transmute(x32p_hold) };
            x32p_hold as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let x32p_drv: u32 = unsafe { ::core::mem::transmute(x32p_drv) };
            x32p_drv as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let x32n_rue: u32 = unsafe { ::core::mem::transmute(x32n_rue) };
            x32n_rue as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let x32n_rde: u32 = unsafe { ::core::mem::transmute(x32n_rde) };
            x32n_rde as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let x32n_hold: u32 = unsafe { ::core::mem::transmute(x32n_hold) };
            x32n_hold as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let x32n_drv: u32 = unsafe { ::core::mem::transmute(x32n_drv) };
            x32n_drv as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_17 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_17 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_17 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn dcur(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dcur(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drange(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drange(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drefl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drefh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dcur: u32,
        drange: u32,
        drefl: u32,
        drefh: u32,
        xpd_bias: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 2u8, {
            let dcur: u32 = unsafe { ::core::mem::transmute(dcur) };
            dcur as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let drange: u32 = unsafe { ::core::mem::transmute(drange) };
            drange as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let drefl: u32 = unsafe { ::core::mem::transmute(drefl) };
            drefl as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let drefh: u32 = unsafe { ::core::mem::transmute(drefh) };
            drefh as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_bias: u32 = unsafe { ::core::mem::transmute(xpd_bias) };
            xpd_bias as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_18 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_18 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_18 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_io_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn to_gpio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_to_gpio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_oe(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_oe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_opt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_opt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rde(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rde(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        to_gpio: u32,
        fun_ie: u32,
        slp_oe: u32,
        slp_ie: u32,
        slp_sel: u32,
        fun_sel: u32,
        mux_sel: u32,
        xpd: u32,
        tie_opt: u32,
        start: u32,
        dac: u32,
        reserved26: u32,
        rue: u32,
        rde: u32,
        drv: u32,
        hold: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let to_gpio: u32 = unsafe { ::core::mem::transmute(to_gpio) };
            to_gpio as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fun_ie: u32 = unsafe { ::core::mem::transmute(fun_ie) };
            fun_ie as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let slp_oe: u32 = unsafe { ::core::mem::transmute(slp_oe) };
            slp_oe as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let slp_ie: u32 = unsafe { ::core::mem::transmute(slp_ie) };
            slp_ie as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let slp_sel: u32 = unsafe { ::core::mem::transmute(slp_sel) };
            slp_sel as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let fun_sel: u32 = unsafe { ::core::mem::transmute(fun_sel) };
            fun_sel as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let mux_sel: u32 = unsafe { ::core::mem::transmute(mux_sel) };
            mux_sel as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let xpd: u32 = unsafe { ::core::mem::transmute(xpd) };
            xpd as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tie_opt: u32 = unsafe { ::core::mem::transmute(tie_opt) };
            tie_opt as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let dac: u32 = unsafe { ::core::mem::transmute(dac) };
            dac as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let rue: u32 = unsafe { ::core::mem::transmute(rue) };
            rue as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rde: u32 = unsafe { ::core::mem::transmute(rde) };
            rde as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let drv: u32 = unsafe { ::core::mem::transmute(drv) };
            drv as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let hold: u32 = unsafe { ::core::mem::transmute(hold) };
            hold as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_19 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_19 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_19 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, sel: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let sel: u32 = unsafe { ::core::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_20 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_20 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_20 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, sel: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let sel: u32 = unsafe { ::core::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_21 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_21 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_21 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn debug_bit_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_debug_bit_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn scl_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_scl_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sda_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sda_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        debug_bit_sel: u32,
        scl_sel: u32,
        sda_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let debug_bit_sel: u32 = unsafe { ::core::mem::transmute(debug_bit_sel) };
            debug_bit_sel as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let scl_sel: u32 = unsafe { ::core::mem::transmute(scl_sel) };
            scl_sel as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let sda_sel: u32 = unsafe { ::core::mem::transmute(sda_sel) };
            sda_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_22 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_22 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_22 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_io_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved28: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_io_dev_s__bindgen_ty_23 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s__bindgen_ty_23 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_io_dev_s__bindgen_ty_23 {{ union }}")
    }
}
impl Default for rtc_io_dev_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_io_dev_s {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "rtc_io_dev_s {{ out: {:?}, out_w1ts: {:?}, out_w1tc: {:?}, enable: {:?}, enable_w1ts: {:?}, enable_w1tc: {:?}, status: {:?}, status_w1ts: {:?}, status_w1tc: {:?}, in_val: {:?}, pin: {:?}, debug_sel: {:?}, dig_pad_hold: {:?}, hall_sens: {:?}, sensor_pads: {:?}, adc_pad: {:?}, pad_dac: {:?}, xtal_32k_pad: {:?}, touch_cfg: {:?}, touch_pad: {:?}, ext_wakeup0: {:?}, xtl_ext_ctr: {:?}, sar_i2c_io: {:?}, date: {:?} }}" , self . out , self . out_w1ts , self . out_w1tc , self . enable , self . enable_w1ts , self . enable_w1tc , self . status , self . status_w1ts , self . status_w1tc , self . in_val , self . pin , self . debug_sel , self . dig_pad_hold , self . hall_sens , self . sensor_pads , self . adc_pad , self . pad_dac , self . xtal_32k_pad , self . touch_cfg , self . touch_pad , self . ext_wakeup0 , self . xtl_ext_ctr , self . sar_i2c_io , self . date )
    }
}
pub type rtc_io_dev_t = rtc_io_dev_s;
extern "C" {
    pub static mut RTCIO: rtc_io_dev_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtc_cntl_dev_s {
    pub options0: rtc_cntl_dev_s__bindgen_ty_1,
    pub slp_timer0: u32,
    pub slp_timer1: rtc_cntl_dev_s__bindgen_ty_2,
    pub time_update: rtc_cntl_dev_s__bindgen_ty_3,
    pub time0: u32,
    pub time1: rtc_cntl_dev_s__bindgen_ty_4,
    pub state0: rtc_cntl_dev_s__bindgen_ty_5,
    pub timer1: rtc_cntl_dev_s__bindgen_ty_6,
    pub timer2: rtc_cntl_dev_s__bindgen_ty_7,
    pub timer3: rtc_cntl_dev_s__bindgen_ty_8,
    pub timer4: rtc_cntl_dev_s__bindgen_ty_9,
    pub timer5: rtc_cntl_dev_s__bindgen_ty_10,
    pub ana_conf: rtc_cntl_dev_s__bindgen_ty_11,
    pub reset_state: rtc_cntl_dev_s__bindgen_ty_12,
    pub wakeup_state: rtc_cntl_dev_s__bindgen_ty_13,
    pub int_ena: rtc_cntl_dev_s__bindgen_ty_14,
    pub int_raw: rtc_cntl_dev_s__bindgen_ty_15,
    pub int_st: rtc_cntl_dev_s__bindgen_ty_16,
    pub int_clr: rtc_cntl_dev_s__bindgen_ty_17,
    pub rtc_store0: u32,
    pub rtc_store1: u32,
    pub rtc_store2: u32,
    pub rtc_store3: u32,
    pub ext_xtl_conf: rtc_cntl_dev_s__bindgen_ty_18,
    pub ext_wakeup_conf: rtc_cntl_dev_s__bindgen_ty_19,
    pub slp_reject_conf: rtc_cntl_dev_s__bindgen_ty_20,
    pub cpu_period_conf: rtc_cntl_dev_s__bindgen_ty_21,
    pub sdio_act_conf: rtc_cntl_dev_s__bindgen_ty_22,
    pub clk_conf: rtc_cntl_dev_s__bindgen_ty_23,
    pub sdio_conf: rtc_cntl_dev_s__bindgen_ty_24,
    pub bias_conf: rtc_cntl_dev_s__bindgen_ty_25,
    pub rtc: rtc_cntl_dev_s__bindgen_ty_26,
    pub rtc_pwc: rtc_cntl_dev_s__bindgen_ty_27,
    pub dig_pwc: rtc_cntl_dev_s__bindgen_ty_28,
    pub dig_iso: rtc_cntl_dev_s__bindgen_ty_29,
    pub wdt_config0: rtc_cntl_dev_s__bindgen_ty_30,
    pub wdt_config1: u32,
    pub wdt_config2: u32,
    pub wdt_config3: u32,
    pub wdt_config4: u32,
    pub wdt_feed: rtc_cntl_dev_s__bindgen_ty_31,
    pub wdt_wprotect: u32,
    pub test_mux: rtc_cntl_dev_s__bindgen_ty_32,
    pub sw_cpu_stall: rtc_cntl_dev_s__bindgen_ty_33,
    pub store4: u32,
    pub store5: u32,
    pub store6: u32,
    pub store7: u32,
    pub diag0: u32,
    pub diag1: u32,
    pub hold_force: rtc_cntl_dev_s__bindgen_ty_34,
    pub ext_wakeup1: rtc_cntl_dev_s__bindgen_ty_35,
    pub ext_wakeup1_status: rtc_cntl_dev_s__bindgen_ty_36,
    pub brown_out: rtc_cntl_dev_s__bindgen_ty_37,
    pub reserved_39: u32,
    pub reserved_3d: u32,
    pub reserved_41: u32,
    pub reserved_45: u32,
    pub reserved_49: u32,
    pub reserved_4d: u32,
    pub date: rtc_cntl_dev_s__bindgen_ty_38,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn sw_stall_appcpu_c0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sw_stall_appcpu_c0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_stall_procpu_c0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sw_stall_procpu_c0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_appcpu_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_appcpu_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_procpu_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_procpu_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bb_i2c_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bb_i2c_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bb_i2c_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bb_i2c_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_i2c_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_i2c_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_i2c_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_i2c_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_sleep_folw_8m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_sleep_folw_8m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_force_sleep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_force_sleep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_force_nosleep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_force_nosleep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_i2c_folw_8m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_i2c_folw_8m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_i2c_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_i2c_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_i2c_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_i2c_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_core_folw_8m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_core_folw_8m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_core_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_core_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_core_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_core_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pll_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn analog_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_analog_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pll_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn analog_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_analog_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_norst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_norst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_sys_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_sys_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sw_stall_appcpu_c0: u32,
        sw_stall_procpu_c0: u32,
        sw_appcpu_rst: u32,
        sw_procpu_rst: u32,
        bb_i2c_force_pd: u32,
        bb_i2c_force_pu: u32,
        bbpll_i2c_force_pd: u32,
        bbpll_i2c_force_pu: u32,
        bbpll_force_pd: u32,
        bbpll_force_pu: u32,
        xtl_force_pd: u32,
        xtl_force_pu: u32,
        bias_sleep_folw_8m: u32,
        bias_force_sleep: u32,
        bias_force_nosleep: u32,
        bias_i2c_folw_8m: u32,
        bias_i2c_force_pd: u32,
        bias_i2c_force_pu: u32,
        bias_core_folw_8m: u32,
        bias_core_force_pd: u32,
        bias_core_force_pu: u32,
        xtl_force_iso: u32,
        pll_force_iso: u32,
        analog_force_iso: u32,
        xtl_force_noiso: u32,
        pll_force_noiso: u32,
        analog_force_noiso: u32,
        dg_wrap_force_rst: u32,
        dg_wrap_force_norst: u32,
        sw_sys_rst: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let sw_stall_appcpu_c0: u32 = unsafe { ::core::mem::transmute(sw_stall_appcpu_c0) };
            sw_stall_appcpu_c0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let sw_stall_procpu_c0: u32 = unsafe { ::core::mem::transmute(sw_stall_procpu_c0) };
            sw_stall_procpu_c0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sw_appcpu_rst: u32 = unsafe { ::core::mem::transmute(sw_appcpu_rst) };
            sw_appcpu_rst as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sw_procpu_rst: u32 = unsafe { ::core::mem::transmute(sw_procpu_rst) };
            sw_procpu_rst as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bb_i2c_force_pd: u32 = unsafe { ::core::mem::transmute(bb_i2c_force_pd) };
            bb_i2c_force_pd as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bb_i2c_force_pu: u32 = unsafe { ::core::mem::transmute(bb_i2c_force_pu) };
            bb_i2c_force_pu as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bbpll_i2c_force_pd: u32 = unsafe { ::core::mem::transmute(bbpll_i2c_force_pd) };
            bbpll_i2c_force_pd as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let bbpll_i2c_force_pu: u32 = unsafe { ::core::mem::transmute(bbpll_i2c_force_pu) };
            bbpll_i2c_force_pu as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bbpll_force_pd: u32 = unsafe { ::core::mem::transmute(bbpll_force_pd) };
            bbpll_force_pd as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let bbpll_force_pu: u32 = unsafe { ::core::mem::transmute(bbpll_force_pu) };
            bbpll_force_pu as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let xtl_force_pd: u32 = unsafe { ::core::mem::transmute(xtl_force_pd) };
            xtl_force_pd as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let xtl_force_pu: u32 = unsafe { ::core::mem::transmute(xtl_force_pu) };
            xtl_force_pu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let bias_sleep_folw_8m: u32 = unsafe { ::core::mem::transmute(bias_sleep_folw_8m) };
            bias_sleep_folw_8m as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let bias_force_sleep: u32 = unsafe { ::core::mem::transmute(bias_force_sleep) };
            bias_force_sleep as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let bias_force_nosleep: u32 = unsafe { ::core::mem::transmute(bias_force_nosleep) };
            bias_force_nosleep as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let bias_i2c_folw_8m: u32 = unsafe { ::core::mem::transmute(bias_i2c_folw_8m) };
            bias_i2c_folw_8m as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let bias_i2c_force_pd: u32 = unsafe { ::core::mem::transmute(bias_i2c_force_pd) };
            bias_i2c_force_pd as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let bias_i2c_force_pu: u32 = unsafe { ::core::mem::transmute(bias_i2c_force_pu) };
            bias_i2c_force_pu as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let bias_core_folw_8m: u32 = unsafe { ::core::mem::transmute(bias_core_folw_8m) };
            bias_core_folw_8m as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let bias_core_force_pd: u32 = unsafe { ::core::mem::transmute(bias_core_force_pd) };
            bias_core_force_pd as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let bias_core_force_pu: u32 = unsafe { ::core::mem::transmute(bias_core_force_pu) };
            bias_core_force_pu as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let xtl_force_iso: u32 = unsafe { ::core::mem::transmute(xtl_force_iso) };
            xtl_force_iso as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let pll_force_iso: u32 = unsafe { ::core::mem::transmute(pll_force_iso) };
            pll_force_iso as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let analog_force_iso: u32 = unsafe { ::core::mem::transmute(analog_force_iso) };
            analog_force_iso as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let xtl_force_noiso: u32 = unsafe { ::core::mem::transmute(xtl_force_noiso) };
            xtl_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let pll_force_noiso: u32 = unsafe { ::core::mem::transmute(pll_force_noiso) };
            pll_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let analog_force_noiso: u32 = unsafe { ::core::mem::transmute(analog_force_noiso) };
            analog_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let dg_wrap_force_rst: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_rst) };
            dg_wrap_force_rst as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let dg_wrap_force_norst: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_norst) };
            dg_wrap_force_norst as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sw_sys_rst: u32 = unsafe { ::core::mem::transmute(sw_sys_rst) };
            sw_sys_rst as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn slp_val_hi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_slp_val_hi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn main_timer_alarm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_main_timer_alarm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_val_hi: u32,
        main_timer_alarm_en: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let slp_val_hi: u32 = unsafe { ::core::mem::transmute(slp_val_hi) };
            slp_val_hi as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let main_timer_alarm_en: u32 = unsafe { ::core::mem::transmute(main_timer_alarm_en) };
            main_timer_alarm_en as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        valid: u32,
        update: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let valid: u32 = unsafe { ::core::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let update: u32 = unsafe { ::core::mem::transmute(update) };
            update as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_3 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn time_hi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_time_hi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        time_hi: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let time_hi: u32 = unsafe { ::core::mem::transmute(time_hi) };
            time_hi as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_4 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_wakeup_force_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_wakeup_force_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ulp_cp_wakeup_force_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ulp_cp_wakeup_force_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apb2rtc_bridge_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apb2rtc_bridge_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_slp_timer_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_slp_timer_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ulp_cp_slp_timer_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ulp_cp_slp_timer_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_active_ind(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_active_ind(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sleep_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        touch_wakeup_force_en: u32,
        ulp_cp_wakeup_force_en: u32,
        apb2rtc_bridge_sel: u32,
        touch_slp_timer_en: u32,
        ulp_cp_slp_timer_en: u32,
        reserved25: u32,
        sdio_active_ind: u32,
        slp_wakeup: u32,
        slp_reject: u32,
        sleep_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let touch_wakeup_force_en: u32 =
                unsafe { ::core::mem::transmute(touch_wakeup_force_en) };
            touch_wakeup_force_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ulp_cp_wakeup_force_en: u32 =
                unsafe { ::core::mem::transmute(ulp_cp_wakeup_force_en) };
            ulp_cp_wakeup_force_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let apb2rtc_bridge_sel: u32 = unsafe { ::core::mem::transmute(apb2rtc_bridge_sel) };
            apb2rtc_bridge_sel as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let touch_slp_timer_en: u32 = unsafe { ::core::mem::transmute(touch_slp_timer_en) };
            touch_slp_timer_en as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let ulp_cp_slp_timer_en: u32 = unsafe { ::core::mem::transmute(ulp_cp_slp_timer_en) };
            ulp_cp_slp_timer_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sdio_active_ind: u32 = unsafe { ::core::mem::transmute(sdio_active_ind) };
            sdio_active_ind as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sleep_en: u32 = unsafe { ::core::mem::transmute(sleep_en) };
            sleep_en as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_5 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn cpu_stall_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_stall_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_stall_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_stall_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_buf_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_buf_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_buf_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pll_buf_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cpu_stall_en: u32,
        cpu_stall_wait: u32,
        ck8m_wait: u32,
        xtl_buf_wait: u32,
        pll_buf_wait: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cpu_stall_en: u32 = unsafe { ::core::mem::transmute(cpu_stall_en) };
            cpu_stall_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let cpu_stall_wait: u32 = unsafe { ::core::mem::transmute(cpu_stall_wait) };
            cpu_stall_wait as u64
        });
        __bindgen_bitfield_unit.set(6usize, 8u8, {
            let ck8m_wait: u32 = unsafe { ::core::mem::transmute(ck8m_wait) };
            ck8m_wait as u64
        });
        __bindgen_bitfield_unit.set(14usize, 10u8, {
            let xtl_buf_wait: u32 = unsafe { ::core::mem::transmute(xtl_buf_wait) };
            xtl_buf_wait as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let pll_buf_wait: u32 = unsafe { ::core::mem::transmute(pll_buf_wait) };
            pll_buf_wait as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_6 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn ulpcp_touch_start_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ulpcp_touch_start_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn min_time_ck8m_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_min_time_ck8m_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        ulpcp_touch_start_wait: u32,
        min_time_ck8m_off: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 9u8, {
            let ulpcp_touch_start_wait: u32 =
                unsafe { ::core::mem::transmute(ulpcp_touch_start_wait) };
            ulpcp_touch_start_wait as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let min_time_ck8m_off: u32 = unsafe { ::core::mem::transmute(min_time_ck8m_off) };
            min_time_ck8m_off as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_7 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn wifi_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn rom_ram_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_rom_ram_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn rom_ram_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rom_ram_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wifi_wait_timer: u32,
        wifi_powerup_timer: u32,
        rom_ram_wait_timer: u32,
        rom_ram_powerup_timer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let wifi_wait_timer: u32 = unsafe { ::core::mem::transmute(wifi_wait_timer) };
            wifi_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let wifi_powerup_timer: u32 = unsafe { ::core::mem::transmute(wifi_powerup_timer) };
            wifi_powerup_timer as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let rom_ram_wait_timer: u32 = unsafe { ::core::mem::transmute(rom_ram_wait_timer) };
            rom_ram_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let rom_ram_powerup_timer: u32 =
                unsafe { ::core::mem::transmute(rom_ram_powerup_timer) };
            rom_ram_powerup_timer as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_8 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn rtc_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_wait_timer: u32,
        rtc_powerup_timer: u32,
        dg_wrap_wait_timer: u32,
        dg_wrap_powerup_timer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let rtc_wait_timer: u32 = unsafe { ::core::mem::transmute(rtc_wait_timer) };
            rtc_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let rtc_powerup_timer: u32 = unsafe { ::core::mem::transmute(rtc_powerup_timer) };
            rtc_powerup_timer as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let dg_wrap_wait_timer: u32 = unsafe { ::core::mem::transmute(dg_wrap_wait_timer) };
            dg_wrap_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let dg_wrap_powerup_timer: u32 =
                unsafe { ::core::mem::transmute(dg_wrap_powerup_timer) };
            dg_wrap_powerup_timer as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_9 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_9 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn ulp_cp_subtimer_prediv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ulp_cp_subtimer_prediv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn min_slp_val(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_min_slp_val(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rtcmem_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_rtcmem_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn rtcmem_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rtcmem_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ulp_cp_subtimer_prediv: u32,
        min_slp_val: u32,
        rtcmem_wait_timer: u32,
        rtcmem_powerup_timer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ulp_cp_subtimer_prediv: u32 =
                unsafe { ::core::mem::transmute(ulp_cp_subtimer_prediv) };
            ulp_cp_subtimer_prediv as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let min_slp_val: u32 = unsafe { ::core::mem::transmute(min_slp_val) };
            min_slp_val as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let rtcmem_wait_timer: u32 = unsafe { ::core::mem::transmute(rtcmem_wait_timer) };
            rtcmem_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let rtcmem_powerup_timer: u32 = unsafe { ::core::mem::transmute(rtcmem_powerup_timer) };
            rtcmem_powerup_timer as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_10 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_10 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn plla_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plla_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plla_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plla_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_cal_slp_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_cal_slp_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pvtmon_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pvtmon_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txrf_i2c_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txrf_i2c_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfrx_pbus_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rfrx_pbus_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved29(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved29(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ckgen_i2c_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ckgen_i2c_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_i2c_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pll_i2c_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        plla_force_pd: u32,
        plla_force_pu: u32,
        bbpll_cal_slp_start: u32,
        pvtmon_pu: u32,
        txrf_i2c_pu: u32,
        rfrx_pbus_pu: u32,
        reserved29: u32,
        ckgen_i2c_pu: u32,
        pll_i2c_pu: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let plla_force_pd: u32 = unsafe { ::core::mem::transmute(plla_force_pd) };
            plla_force_pd as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let plla_force_pu: u32 = unsafe { ::core::mem::transmute(plla_force_pu) };
            plla_force_pu as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bbpll_cal_slp_start: u32 = unsafe { ::core::mem::transmute(bbpll_cal_slp_start) };
            bbpll_cal_slp_start as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let pvtmon_pu: u32 = unsafe { ::core::mem::transmute(pvtmon_pu) };
            pvtmon_pu as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let txrf_i2c_pu: u32 = unsafe { ::core::mem::transmute(txrf_i2c_pu) };
            txrf_i2c_pu as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rfrx_pbus_pu: u32 = unsafe { ::core::mem::transmute(rfrx_pbus_pu) };
            rfrx_pbus_pu as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let reserved29: u32 = unsafe { ::core::mem::transmute(reserved29) };
            reserved29 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ckgen_i2c_pu: u32 = unsafe { ::core::mem::transmute(ckgen_i2c_pu) };
            ckgen_i2c_pu as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let pll_i2c_pu: u32 = unsafe { ::core::mem::transmute(pll_i2c_pu) };
            pll_i2c_pu as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_11 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_11 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn reset_cause_procpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reset_cause_procpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_cause_appcpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reset_cause_appcpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn appcpu_stat_vector_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_appcpu_stat_vector_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn procpu_stat_vector_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_procpu_stat_vector_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reset_cause_procpu: u32,
        reset_cause_appcpu: u32,
        appcpu_stat_vector_sel: u32,
        procpu_stat_vector_sel: u32,
        reserved14: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reset_cause_procpu: u32 = unsafe { ::core::mem::transmute(reset_cause_procpu) };
            reset_cause_procpu as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let reset_cause_appcpu: u32 = unsafe { ::core::mem::transmute(reset_cause_appcpu) };
            reset_cause_appcpu as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let appcpu_stat_vector_sel: u32 =
                unsafe { ::core::mem::transmute(appcpu_stat_vector_sel) };
            appcpu_stat_vector_sel as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let procpu_stat_vector_sel: u32 =
                unsafe { ::core::mem::transmute(procpu_stat_vector_sel) };
            procpu_stat_vector_sel as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let reserved14: u32 = unsafe { ::core::mem::transmute(reserved14) };
            reserved14 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_12 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_12 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_12 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn wakeup_cause(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_cause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wakeup_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wakeup_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_wakeup_filter(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_wakeup_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved23(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved23(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wakeup_cause: u32,
        rtc_wakeup_ena: u32,
        gpio_wakeup_filter: u32,
        reserved23: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let wakeup_cause: u32 = unsafe { ::core::mem::transmute(wakeup_cause) };
            wakeup_cause as u64
        });
        __bindgen_bitfield_unit.set(11usize, 11u8, {
            let rtc_wakeup_ena: u32 = unsafe { ::core::mem::transmute(rtc_wakeup_ena) };
            rtc_wakeup_ena as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let gpio_wakeup_filter: u32 = unsafe { ::core::mem::transmute(gpio_wakeup_filter) };
            gpio_wakeup_filter as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let reserved23: u32 = unsafe { ::core::mem::transmute(reserved23) };
            reserved23 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_13 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_13 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_13 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_time_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_time_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_ulp_cp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_ulp_cp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        sdio_idle: u32,
        rtc_wdt: u32,
        rtc_time_valid: u32,
        rtc_ulp_cp: u32,
        rtc_touch: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sdio_idle: u32 = unsafe { ::core::mem::transmute(sdio_idle) };
            sdio_idle as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_time_valid: u32 = unsafe { ::core::mem::transmute(rtc_time_valid) };
            rtc_time_valid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rtc_ulp_cp: u32 = unsafe { ::core::mem::transmute(rtc_ulp_cp) };
            rtc_ulp_cp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rtc_touch: u32 = unsafe { ::core::mem::transmute(rtc_touch) };
            rtc_touch as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_14 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_14 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_14 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_time_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_time_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_ulp_cp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_ulp_cp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        sdio_idle: u32,
        rtc_wdt: u32,
        rtc_time_valid: u32,
        rtc_ulp_cp: u32,
        rtc_touch: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sdio_idle: u32 = unsafe { ::core::mem::transmute(sdio_idle) };
            sdio_idle as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_time_valid: u32 = unsafe { ::core::mem::transmute(rtc_time_valid) };
            rtc_time_valid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rtc_ulp_cp: u32 = unsafe { ::core::mem::transmute(rtc_ulp_cp) };
            rtc_ulp_cp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rtc_touch: u32 = unsafe { ::core::mem::transmute(rtc_touch) };
            rtc_touch as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_15 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_15 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_15 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_time_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_time_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        sdio_idle: u32,
        rtc_wdt: u32,
        rtc_time_valid: u32,
        rtc_sar: u32,
        rtc_touch: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sdio_idle: u32 = unsafe { ::core::mem::transmute(sdio_idle) };
            sdio_idle as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_time_valid: u32 = unsafe { ::core::mem::transmute(rtc_time_valid) };
            rtc_time_valid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rtc_sar: u32 = unsafe { ::core::mem::transmute(rtc_sar) };
            rtc_sar as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rtc_touch: u32 = unsafe { ::core::mem::transmute(rtc_touch) };
            rtc_touch as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_16 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_16 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_time_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_time_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        sdio_idle: u32,
        rtc_wdt: u32,
        rtc_time_valid: u32,
        rtc_sar: u32,
        rtc_touch: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sdio_idle: u32 = unsafe { ::core::mem::transmute(sdio_idle) };
            sdio_idle as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_time_valid: u32 = unsafe { ::core::mem::transmute(rtc_time_valid) };
            rtc_time_valid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rtc_sar: u32 = unsafe { ::core::mem::transmute(rtc_sar) };
            rtc_sar as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rtc_touch: u32 = unsafe { ::core::mem::transmute(rtc_touch) };
            rtc_touch as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_17 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_17 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_17 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn ctr_lv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctr_lv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ctr_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctr_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        ctr_lv: u32,
        ctr_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ctr_lv: u32 = unsafe { ::core::mem::transmute(ctr_lv) };
            ctr_lv as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ctr_en: u32 = unsafe { ::core::mem::transmute(ctr_en) };
            ctr_en as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_18 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_18 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_18 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup0_lv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup0_lv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup1_lv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup1_lv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        wakeup0_lv: u32,
        wakeup1_lv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let wakeup0_lv: u32 = unsafe { ::core::mem::transmute(wakeup0_lv) };
            wakeup0_lv as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let wakeup1_lv: u32 = unsafe { ::core::mem::transmute(wakeup1_lv) };
            wakeup1_lv as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_19 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_19 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_19 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_reject_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_reject_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_reject_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_reject_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn light_slp_reject_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_light_slp_reject_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deep_slp_reject_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deep_slp_reject_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reject_cause(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reject_cause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        gpio_reject_en: u32,
        sdio_reject_en: u32,
        light_slp_reject_en: u32,
        deep_slp_reject_en: u32,
        reject_cause: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let gpio_reject_en: u32 = unsafe { ::core::mem::transmute(gpio_reject_en) };
            gpio_reject_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let sdio_reject_en: u32 = unsafe { ::core::mem::transmute(sdio_reject_en) };
            sdio_reject_en as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let light_slp_reject_en: u32 = unsafe { ::core::mem::transmute(light_slp_reject_en) };
            light_slp_reject_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let deep_slp_reject_en: u32 = unsafe { ::core::mem::transmute(deep_slp_reject_en) };
            deep_slp_reject_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reject_cause: u32 = unsafe { ::core::mem::transmute(reject_cause) };
            reject_cause as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_20 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_20 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_20 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn cpusel_conf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpusel_conf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpuperiod_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cpuperiod_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        cpusel_conf: u32,
        cpuperiod_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 29u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let cpusel_conf: u32 = unsafe { ::core::mem::transmute(cpusel_conf) };
            cpusel_conf as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let cpuperiod_sel: u32 = unsafe { ::core::mem::transmute(cpuperiod_sel) };
            cpuperiod_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_21 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_21 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_21 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_act_dnum(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_act_dnum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        sdio_act_dnum: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 22u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let sdio_act_dnum: u32 = unsafe { ::core::mem::transmute(sdio_act_dnum) };
            sdio_act_dnum as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_22 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_22 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_22 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn enb_ck8m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enb_ck8m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enb_ck8m_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enb_ck8m_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_xtal32k_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_xtal32k_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_clk8m_d256_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_clk8m_d256_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_clk8m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_clk8m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_dfreq_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_dfreq_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_div_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_div_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal_force_nogating(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal_force_nogating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_force_nogating(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_force_nogating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_dfreq(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_dfreq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn soc_clk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_soc_clk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fast_clk_rtc_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fast_clk_rtc_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_clk_rtc_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ana_clk_rtc_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        ck8m_div: u32,
        enb_ck8m: u32,
        enb_ck8m_div: u32,
        dig_xtal32k_en: u32,
        dig_clk8m_d256_en: u32,
        dig_clk8m_en: u32,
        ck8m_dfreq_force: u32,
        ck8m_div_sel: u32,
        xtal_force_nogating: u32,
        ck8m_force_nogating: u32,
        ck8m_dfreq: u32,
        ck8m_force_pd: u32,
        ck8m_force_pu: u32,
        soc_clk_sel: u32,
        fast_clk_rtc_sel: u32,
        ana_clk_rtc_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let ck8m_div: u32 = unsafe { ::core::mem::transmute(ck8m_div) };
            ck8m_div as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let enb_ck8m: u32 = unsafe { ::core::mem::transmute(enb_ck8m) };
            enb_ck8m as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let enb_ck8m_div: u32 = unsafe { ::core::mem::transmute(enb_ck8m_div) };
            enb_ck8m_div as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dig_xtal32k_en: u32 = unsafe { ::core::mem::transmute(dig_xtal32k_en) };
            dig_xtal32k_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dig_clk8m_d256_en: u32 = unsafe { ::core::mem::transmute(dig_clk8m_d256_en) };
            dig_clk8m_d256_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let dig_clk8m_en: u32 = unsafe { ::core::mem::transmute(dig_clk8m_en) };
            dig_clk8m_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ck8m_dfreq_force: u32 = unsafe { ::core::mem::transmute(ck8m_dfreq_force) };
            ck8m_dfreq_force as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let ck8m_div_sel: u32 = unsafe { ::core::mem::transmute(ck8m_div_sel) };
            ck8m_div_sel as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let xtal_force_nogating: u32 = unsafe { ::core::mem::transmute(xtal_force_nogating) };
            xtal_force_nogating as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ck8m_force_nogating: u32 = unsafe { ::core::mem::transmute(ck8m_force_nogating) };
            ck8m_force_nogating as u64
        });
        __bindgen_bitfield_unit.set(17usize, 8u8, {
            let ck8m_dfreq: u32 = unsafe { ::core::mem::transmute(ck8m_dfreq) };
            ck8m_dfreq as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ck8m_force_pd: u32 = unsafe { ::core::mem::transmute(ck8m_force_pd) };
            ck8m_force_pd as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ck8m_force_pu: u32 = unsafe { ::core::mem::transmute(ck8m_force_pu) };
            ck8m_force_pu as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let soc_clk_sel: u32 = unsafe { ::core::mem::transmute(soc_clk_sel) };
            soc_clk_sel as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let fast_clk_rtc_sel: u32 = unsafe { ::core::mem::transmute(fast_clk_rtc_sel) };
            fast_clk_rtc_sel as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let ana_clk_rtc_sel: u32 = unsafe { ::core::mem::transmute(ana_clk_rtc_sel) };
            ana_clk_rtc_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_23 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_23 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_23 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_24 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_tieh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_tieh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reg1p8_ready(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reg1p8_ready(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drefl_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefl_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drefm_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefm_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drefh_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefh_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        sdio_pd_en: u32,
        sdio_force: u32,
        sdio_tieh: u32,
        reg1p8_ready: u32,
        drefl_sdio: u32,
        drefm_sdio: u32,
        drefh_sdio: u32,
        xpd_sdio: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 21u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let sdio_pd_en: u32 = unsafe { ::core::mem::transmute(sdio_pd_en) };
            sdio_pd_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let sdio_force: u32 = unsafe { ::core::mem::transmute(sdio_force) };
            sdio_force as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let sdio_tieh: u32 = unsafe { ::core::mem::transmute(sdio_tieh) };
            sdio_tieh as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let reg1p8_ready: u32 = unsafe { ::core::mem::transmute(reg1p8_ready) };
            reg1p8_ready as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let drefl_sdio: u32 = unsafe { ::core::mem::transmute(drefl_sdio) };
            drefl_sdio as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let drefm_sdio: u32 = unsafe { ::core::mem::transmute(drefm_sdio) };
            drefm_sdio as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let drefh_sdio: u32 = unsafe { ::core::mem::transmute(drefh_sdio) };
            drefh_sdio as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_sdio: u32 = unsafe { ::core::mem::transmute(xpd_sdio) };
            xpd_sdio as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_24 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_24 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_24 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_25 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_25__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_25__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_25__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn dbg_atten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dbg_atten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn enb_sck_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enb_sck_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc_heartbeat_refresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc_heartbeat_refresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dec_heartbeat_period(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dec_heartbeat_period(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc_heartbeat_period(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc_heartbeat_period(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dec_heartbeat_width(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dec_heartbeat_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_bias_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_bias_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dbg_atten: u32,
        enb_sck_xtal: u32,
        inc_heartbeat_refresh: u32,
        dec_heartbeat_period: u32,
        inc_heartbeat_period: u32,
        dec_heartbeat_width: u32,
        rst_bias_i2c: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let dbg_atten: u32 = unsafe { ::core::mem::transmute(dbg_atten) };
            dbg_atten as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let enb_sck_xtal: u32 = unsafe { ::core::mem::transmute(enb_sck_xtal) };
            enb_sck_xtal as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let inc_heartbeat_refresh: u32 =
                unsafe { ::core::mem::transmute(inc_heartbeat_refresh) };
            inc_heartbeat_refresh as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let dec_heartbeat_period: u32 = unsafe { ::core::mem::transmute(dec_heartbeat_period) };
            dec_heartbeat_period as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let inc_heartbeat_period: u32 = unsafe { ::core::mem::transmute(inc_heartbeat_period) };
            inc_heartbeat_period as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let dec_heartbeat_width: u32 = unsafe { ::core::mem::transmute(dec_heartbeat_width) };
            dec_heartbeat_width as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rst_bias_i2c: u32 = unsafe { ::core::mem::transmute(rst_bias_i2c) };
            rst_bias_i2c as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_25 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_25 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_25 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_26 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_26__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_26__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_26__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn sck_dcap_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sck_dcap_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_dbias_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dig_dbias_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_dbias_wak(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dig_dbias_wak(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sck_dcap(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sck_dcap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dbias_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dbias_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dbias_wak(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dbias_wak(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dboost_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dboost_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dboost_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dboost_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        sck_dcap_force: u32,
        dig_dbias_slp: u32,
        dig_dbias_wak: u32,
        sck_dcap: u32,
        rtc_dbias_slp: u32,
        rtc_dbias_wak: u32,
        rtc_dboost_force_pd: u32,
        rtc_dboost_force_pu: u32,
        rtc_force_pd: u32,
        rtc_force_pu: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sck_dcap_force: u32 = unsafe { ::core::mem::transmute(sck_dcap_force) };
            sck_dcap_force as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let dig_dbias_slp: u32 = unsafe { ::core::mem::transmute(dig_dbias_slp) };
            dig_dbias_slp as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let dig_dbias_wak: u32 = unsafe { ::core::mem::transmute(dig_dbias_wak) };
            dig_dbias_wak as u64
        });
        __bindgen_bitfield_unit.set(14usize, 8u8, {
            let sck_dcap: u32 = unsafe { ::core::mem::transmute(sck_dcap) };
            sck_dcap as u64
        });
        __bindgen_bitfield_unit.set(22usize, 3u8, {
            let rtc_dbias_slp: u32 = unsafe { ::core::mem::transmute(rtc_dbias_slp) };
            rtc_dbias_slp as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let rtc_dbias_wak: u32 = unsafe { ::core::mem::transmute(rtc_dbias_wak) };
            rtc_dbias_wak as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rtc_dboost_force_pd: u32 = unsafe { ::core::mem::transmute(rtc_dboost_force_pd) };
            rtc_dboost_force_pd as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let rtc_dboost_force_pu: u32 = unsafe { ::core::mem::transmute(rtc_dboost_force_pu) };
            rtc_dboost_force_pu as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rtc_force_pd: u32 = unsafe { ::core::mem::transmute(rtc_force_pd) };
            rtc_force_pd as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rtc_force_pu: u32 = unsafe { ::core::mem::transmute(rtc_force_pu) };
            rtc_force_pu as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_26 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_26 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_26 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_27 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_27__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_27__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_27__bindgen_ty_1 {
    #[inline]
    pub fn fastmem_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_folw_cpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_folw_cpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_lpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_lpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_lpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_lpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_folw_cpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_folw_cpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_lpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_lpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_lpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_lpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pwc_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pwc_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pwc_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pwc_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fastmem_force_noiso: u32,
        fastmem_force_iso: u32,
        slowmem_force_noiso: u32,
        slowmem_force_iso: u32,
        rtc_force_iso: u32,
        force_noiso: u32,
        fastmem_folw_cpu: u32,
        fastmem_force_lpd: u32,
        fastmem_force_lpu: u32,
        slowmem_folw_cpu: u32,
        slowmem_force_lpd: u32,
        slowmem_force_lpu: u32,
        fastmem_force_pd: u32,
        fastmem_force_pu: u32,
        fastmem_pd_en: u32,
        slowmem_force_pd: u32,
        slowmem_force_pu: u32,
        slowmem_pd_en: u32,
        pwc_force_pd: u32,
        pwc_force_pu: u32,
        pd_en: u32,
        reserved21: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fastmem_force_noiso: u32 = unsafe { ::core::mem::transmute(fastmem_force_noiso) };
            fastmem_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fastmem_force_iso: u32 = unsafe { ::core::mem::transmute(fastmem_force_iso) };
            fastmem_force_iso as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let slowmem_force_noiso: u32 = unsafe { ::core::mem::transmute(slowmem_force_noiso) };
            slowmem_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let slowmem_force_iso: u32 = unsafe { ::core::mem::transmute(slowmem_force_iso) };
            slowmem_force_iso as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_force_iso: u32 = unsafe { ::core::mem::transmute(rtc_force_iso) };
            rtc_force_iso as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let force_noiso: u32 = unsafe { ::core::mem::transmute(force_noiso) };
            force_noiso as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let fastmem_folw_cpu: u32 = unsafe { ::core::mem::transmute(fastmem_folw_cpu) };
            fastmem_folw_cpu as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let fastmem_force_lpd: u32 = unsafe { ::core::mem::transmute(fastmem_force_lpd) };
            fastmem_force_lpd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fastmem_force_lpu: u32 = unsafe { ::core::mem::transmute(fastmem_force_lpu) };
            fastmem_force_lpu as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let slowmem_folw_cpu: u32 = unsafe { ::core::mem::transmute(slowmem_folw_cpu) };
            slowmem_folw_cpu as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let slowmem_force_lpd: u32 = unsafe { ::core::mem::transmute(slowmem_force_lpd) };
            slowmem_force_lpd as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let slowmem_force_lpu: u32 = unsafe { ::core::mem::transmute(slowmem_force_lpu) };
            slowmem_force_lpu as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fastmem_force_pd: u32 = unsafe { ::core::mem::transmute(fastmem_force_pd) };
            fastmem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fastmem_force_pu: u32 = unsafe { ::core::mem::transmute(fastmem_force_pu) };
            fastmem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fastmem_pd_en: u32 = unsafe { ::core::mem::transmute(fastmem_pd_en) };
            fastmem_pd_en as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let slowmem_force_pd: u32 = unsafe { ::core::mem::transmute(slowmem_force_pd) };
            slowmem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let slowmem_force_pu: u32 = unsafe { ::core::mem::transmute(slowmem_force_pu) };
            slowmem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let slowmem_pd_en: u32 = unsafe { ::core::mem::transmute(slowmem_pd_en) };
            slowmem_pd_en as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let pwc_force_pd: u32 = unsafe { ::core::mem::transmute(pwc_force_pd) };
            pwc_force_pd as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let pwc_force_pu: u32 = unsafe { ::core::mem::transmute(pwc_force_pu) };
            pwc_force_pu as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let pd_en: u32 = unsafe { ::core::mem::transmute(pd_en) };
            pd_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_27 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_27 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_27 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_28 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_28__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_28__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_28__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn lslp_mem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lslp_mem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lslp_mem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lslp_mem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rom0_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom0_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rom0_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom0_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram0_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram0_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram0_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram0_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram1_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram1_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram1_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram1_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram2_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram2_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram2_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram2_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram3_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram3_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram3_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram3_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram4_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram4_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram4_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram4_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rom0_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom0_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram0_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram0_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram1_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram1_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram2_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram2_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram3_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram3_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram4_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram4_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        lslp_mem_force_pd: u32,
        lslp_mem_force_pu: u32,
        rom0_force_pd: u32,
        rom0_force_pu: u32,
        inter_ram0_force_pd: u32,
        inter_ram0_force_pu: u32,
        inter_ram1_force_pd: u32,
        inter_ram1_force_pu: u32,
        inter_ram2_force_pd: u32,
        inter_ram2_force_pu: u32,
        inter_ram3_force_pd: u32,
        inter_ram3_force_pu: u32,
        inter_ram4_force_pd: u32,
        inter_ram4_force_pu: u32,
        wifi_force_pd: u32,
        wifi_force_pu: u32,
        dg_wrap_force_pd: u32,
        dg_wrap_force_pu: u32,
        reserved21: u32,
        rom0_pd_en: u32,
        inter_ram0_pd_en: u32,
        inter_ram1_pd_en: u32,
        inter_ram2_pd_en: u32,
        inter_ram3_pd_en: u32,
        inter_ram4_pd_en: u32,
        wifi_pd_en: u32,
        dg_wrap_pd_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lslp_mem_force_pd: u32 = unsafe { ::core::mem::transmute(lslp_mem_force_pd) };
            lslp_mem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let lslp_mem_force_pu: u32 = unsafe { ::core::mem::transmute(lslp_mem_force_pu) };
            lslp_mem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rom0_force_pd: u32 = unsafe { ::core::mem::transmute(rom0_force_pd) };
            rom0_force_pd as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rom0_force_pu: u32 = unsafe { ::core::mem::transmute(rom0_force_pu) };
            rom0_force_pu as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let inter_ram0_force_pd: u32 = unsafe { ::core::mem::transmute(inter_ram0_force_pd) };
            inter_ram0_force_pd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let inter_ram0_force_pu: u32 = unsafe { ::core::mem::transmute(inter_ram0_force_pu) };
            inter_ram0_force_pu as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inter_ram1_force_pd: u32 = unsafe { ::core::mem::transmute(inter_ram1_force_pd) };
            inter_ram1_force_pd as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let inter_ram1_force_pu: u32 = unsafe { ::core::mem::transmute(inter_ram1_force_pu) };
            inter_ram1_force_pu as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let inter_ram2_force_pd: u32 = unsafe { ::core::mem::transmute(inter_ram2_force_pd) };
            inter_ram2_force_pd as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let inter_ram2_force_pu: u32 = unsafe { ::core::mem::transmute(inter_ram2_force_pu) };
            inter_ram2_force_pu as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let inter_ram3_force_pd: u32 = unsafe { ::core::mem::transmute(inter_ram3_force_pd) };
            inter_ram3_force_pd as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let inter_ram3_force_pu: u32 = unsafe { ::core::mem::transmute(inter_ram3_force_pu) };
            inter_ram3_force_pu as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let inter_ram4_force_pd: u32 = unsafe { ::core::mem::transmute(inter_ram4_force_pd) };
            inter_ram4_force_pd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let inter_ram4_force_pu: u32 = unsafe { ::core::mem::transmute(inter_ram4_force_pu) };
            inter_ram4_force_pu as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let wifi_force_pd: u32 = unsafe { ::core::mem::transmute(wifi_force_pd) };
            wifi_force_pd as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let wifi_force_pu: u32 = unsafe { ::core::mem::transmute(wifi_force_pu) };
            wifi_force_pu as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let dg_wrap_force_pd: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_pd) };
            dg_wrap_force_pd as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let dg_wrap_force_pu: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_pu) };
            dg_wrap_force_pu as u64
        });
        __bindgen_bitfield_unit.set(21usize, 3u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rom0_pd_en: u32 = unsafe { ::core::mem::transmute(rom0_pd_en) };
            rom0_pd_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let inter_ram0_pd_en: u32 = unsafe { ::core::mem::transmute(inter_ram0_pd_en) };
            inter_ram0_pd_en as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let inter_ram1_pd_en: u32 = unsafe { ::core::mem::transmute(inter_ram1_pd_en) };
            inter_ram1_pd_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let inter_ram2_pd_en: u32 = unsafe { ::core::mem::transmute(inter_ram2_pd_en) };
            inter_ram2_pd_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let inter_ram3_pd_en: u32 = unsafe { ::core::mem::transmute(inter_ram3_pd_en) };
            inter_ram3_pd_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let inter_ram4_pd_en: u32 = unsafe { ::core::mem::transmute(inter_ram4_pd_en) };
            inter_ram4_pd_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let wifi_pd_en: u32 = unsafe { ::core::mem::transmute(wifi_pd_en) };
            wifi_pd_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let dg_wrap_pd_en: u32 = unsafe { ::core::mem::transmute(dg_wrap_pd_en) };
            dg_wrap_pd_en as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_28 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_28 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_28 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_29 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_29__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_iso_force_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_iso_force_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_iso_force_on(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_iso_force_on(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_autohold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_autohold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clr_dg_pad_autohold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clr_dg_pad_autohold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_autohold_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_autohold_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_unhold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_unhold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rom0_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom0_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rom0_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom0_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram0_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram0_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram0_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram0_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram1_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram1_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram1_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram1_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram2_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram2_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram2_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram2_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram3_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram3_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram3_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram3_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram4_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram4_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram4_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram4_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dig_iso_force_off: u32,
        dig_iso_force_on: u32,
        dg_pad_autohold: u32,
        clr_dg_pad_autohold: u32,
        dg_pad_autohold_en: u32,
        dg_pad_force_noiso: u32,
        dg_pad_force_iso: u32,
        dg_pad_force_unhold: u32,
        dg_pad_force_hold: u32,
        rom0_force_iso: u32,
        rom0_force_noiso: u32,
        inter_ram0_force_iso: u32,
        inter_ram0_force_noiso: u32,
        inter_ram1_force_iso: u32,
        inter_ram1_force_noiso: u32,
        inter_ram2_force_iso: u32,
        inter_ram2_force_noiso: u32,
        inter_ram3_force_iso: u32,
        inter_ram3_force_noiso: u32,
        inter_ram4_force_iso: u32,
        inter_ram4_force_noiso: u32,
        wifi_force_iso: u32,
        wifi_force_noiso: u32,
        dg_wrap_force_iso: u32,
        dg_wrap_force_noiso: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dig_iso_force_off: u32 = unsafe { ::core::mem::transmute(dig_iso_force_off) };
            dig_iso_force_off as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dig_iso_force_on: u32 = unsafe { ::core::mem::transmute(dig_iso_force_on) };
            dig_iso_force_on as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dg_pad_autohold: u32 = unsafe { ::core::mem::transmute(dg_pad_autohold) };
            dg_pad_autohold as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let clr_dg_pad_autohold: u32 = unsafe { ::core::mem::transmute(clr_dg_pad_autohold) };
            clr_dg_pad_autohold as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let dg_pad_autohold_en: u32 = unsafe { ::core::mem::transmute(dg_pad_autohold_en) };
            dg_pad_autohold_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let dg_pad_force_noiso: u32 = unsafe { ::core::mem::transmute(dg_pad_force_noiso) };
            dg_pad_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let dg_pad_force_iso: u32 = unsafe { ::core::mem::transmute(dg_pad_force_iso) };
            dg_pad_force_iso as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let dg_pad_force_unhold: u32 = unsafe { ::core::mem::transmute(dg_pad_force_unhold) };
            dg_pad_force_unhold as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let dg_pad_force_hold: u32 = unsafe { ::core::mem::transmute(dg_pad_force_hold) };
            dg_pad_force_hold as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rom0_force_iso: u32 = unsafe { ::core::mem::transmute(rom0_force_iso) };
            rom0_force_iso as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rom0_force_noiso: u32 = unsafe { ::core::mem::transmute(rom0_force_noiso) };
            rom0_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let inter_ram0_force_iso: u32 = unsafe { ::core::mem::transmute(inter_ram0_force_iso) };
            inter_ram0_force_iso as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let inter_ram0_force_noiso: u32 =
                unsafe { ::core::mem::transmute(inter_ram0_force_noiso) };
            inter_ram0_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let inter_ram1_force_iso: u32 = unsafe { ::core::mem::transmute(inter_ram1_force_iso) };
            inter_ram1_force_iso as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let inter_ram1_force_noiso: u32 =
                unsafe { ::core::mem::transmute(inter_ram1_force_noiso) };
            inter_ram1_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let inter_ram2_force_iso: u32 = unsafe { ::core::mem::transmute(inter_ram2_force_iso) };
            inter_ram2_force_iso as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let inter_ram2_force_noiso: u32 =
                unsafe { ::core::mem::transmute(inter_ram2_force_noiso) };
            inter_ram2_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let inter_ram3_force_iso: u32 = unsafe { ::core::mem::transmute(inter_ram3_force_iso) };
            inter_ram3_force_iso as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let inter_ram3_force_noiso: u32 =
                unsafe { ::core::mem::transmute(inter_ram3_force_noiso) };
            inter_ram3_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let inter_ram4_force_iso: u32 = unsafe { ::core::mem::transmute(inter_ram4_force_iso) };
            inter_ram4_force_iso as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let inter_ram4_force_noiso: u32 =
                unsafe { ::core::mem::transmute(inter_ram4_force_noiso) };
            inter_ram4_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let wifi_force_iso: u32 = unsafe { ::core::mem::transmute(wifi_force_iso) };
            wifi_force_iso as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let wifi_force_noiso: u32 = unsafe { ::core::mem::transmute(wifi_force_noiso) };
            wifi_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let dg_wrap_force_iso: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_iso) };
            dg_wrap_force_iso as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let dg_wrap_force_noiso: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_noiso) };
            dg_wrap_force_noiso as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_29 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_29 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_29 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_30 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_30__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_30__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_30__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn pause_in_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pause_in_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn appcpu_reset_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_appcpu_reset_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn procpu_reset_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_procpu_reset_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flashboot_mod_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flashboot_mod_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sys_reset_length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sys_reset_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_reset_length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_reset_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn level_int_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level_int_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn edge_int_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_edge_int_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stg3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stg2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stg1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stg0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        pause_in_slp: u32,
        appcpu_reset_en: u32,
        procpu_reset_en: u32,
        flashboot_mod_en: u32,
        sys_reset_length: u32,
        cpu_reset_length: u32,
        level_int_en: u32,
        edge_int_en: u32,
        stg3: u32,
        stg2: u32,
        stg1: u32,
        stg0: u32,
        en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pause_in_slp: u32 = unsafe { ::core::mem::transmute(pause_in_slp) };
            pause_in_slp as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let appcpu_reset_en: u32 = unsafe { ::core::mem::transmute(appcpu_reset_en) };
            appcpu_reset_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let procpu_reset_en: u32 = unsafe { ::core::mem::transmute(procpu_reset_en) };
            procpu_reset_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let flashboot_mod_en: u32 = unsafe { ::core::mem::transmute(flashboot_mod_en) };
            flashboot_mod_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let sys_reset_length: u32 = unsafe { ::core::mem::transmute(sys_reset_length) };
            sys_reset_length as u64
        });
        __bindgen_bitfield_unit.set(14usize, 3u8, {
            let cpu_reset_length: u32 = unsafe { ::core::mem::transmute(cpu_reset_length) };
            cpu_reset_length as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let level_int_en: u32 = unsafe { ::core::mem::transmute(level_int_en) };
            level_int_en as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let edge_int_en: u32 = unsafe { ::core::mem::transmute(edge_int_en) };
            edge_int_en as u64
        });
        __bindgen_bitfield_unit.set(19usize, 3u8, {
            let stg3: u32 = unsafe { ::core::mem::transmute(stg3) };
            stg3 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 3u8, {
            let stg2: u32 = unsafe { ::core::mem::transmute(stg2) };
            stg2 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let stg1: u32 = unsafe { ::core::mem::transmute(stg1) };
            stg1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 3u8, {
            let stg0: u32 = unsafe { ::core::mem::transmute(stg0) };
            stg0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_30 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_30 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_30 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_31 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_31__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_31__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_31__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn feed(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_feed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, feed: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let feed: u32 = unsafe { ::core::mem::transmute(feed) };
            feed as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_31 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_31 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_31 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_32 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_32__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_32__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_32__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn ent_rtc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ent_rtc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dtest_rtc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dtest_rtc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        ent_rtc: u32,
        dtest_rtc: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 29u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ent_rtc: u32 = unsafe { ::core::mem::transmute(ent_rtc) };
            ent_rtc as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let dtest_rtc: u32 = unsafe { ::core::mem::transmute(dtest_rtc) };
            dtest_rtc as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_32 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_32 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_33 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_33__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_33__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_33__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn appcpu_c1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_appcpu_c1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn procpu_c1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_procpu_c1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        appcpu_c1: u32,
        procpu_c1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 6u8, {
            let appcpu_c1: u32 = unsafe { ::core::mem::transmute(appcpu_c1) };
            appcpu_c1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let procpu_c1: u32 = unsafe { ::core::mem::transmute(procpu_c1) };
            procpu_c1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_33 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_33 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_33 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_34 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_34__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_34__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_34__bindgen_ty_1 {
    #[inline]
    pub fn adc1_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdac1_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdac1_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdac2_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdac2_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad0_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad0_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad1_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad1_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad2_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad2_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad3_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad3_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad4_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad4_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad5_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad5_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad6_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad6_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad7_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad7_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        adc1_hold_force: u32,
        adc2_hold_force: u32,
        pdac1_hold_force: u32,
        pdac2_hold_force: u32,
        sense1_hold_force: u32,
        sense2_hold_force: u32,
        sense3_hold_force: u32,
        sense4_hold_force: u32,
        touch_pad0_hold_force: u32,
        touch_pad1_hold_force: u32,
        touch_pad2_hold_force: u32,
        touch_pad3_hold_force: u32,
        touch_pad4_hold_force: u32,
        touch_pad5_hold_force: u32,
        touch_pad6_hold_force: u32,
        touch_pad7_hold_force: u32,
        x32p_hold_force: u32,
        x32n_hold_force: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let adc1_hold_force: u32 = unsafe { ::core::mem::transmute(adc1_hold_force) };
            adc1_hold_force as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let adc2_hold_force: u32 = unsafe { ::core::mem::transmute(adc2_hold_force) };
            adc2_hold_force as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pdac1_hold_force: u32 = unsafe { ::core::mem::transmute(pdac1_hold_force) };
            pdac1_hold_force as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pdac2_hold_force: u32 = unsafe { ::core::mem::transmute(pdac2_hold_force) };
            pdac2_hold_force as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sense1_hold_force: u32 = unsafe { ::core::mem::transmute(sense1_hold_force) };
            sense1_hold_force as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sense2_hold_force: u32 = unsafe { ::core::mem::transmute(sense2_hold_force) };
            sense2_hold_force as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sense3_hold_force: u32 = unsafe { ::core::mem::transmute(sense3_hold_force) };
            sense3_hold_force as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sense4_hold_force: u32 = unsafe { ::core::mem::transmute(sense4_hold_force) };
            sense4_hold_force as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let touch_pad0_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad0_hold_force) };
            touch_pad0_hold_force as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let touch_pad1_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad1_hold_force) };
            touch_pad1_hold_force as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let touch_pad2_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad2_hold_force) };
            touch_pad2_hold_force as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let touch_pad3_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad3_hold_force) };
            touch_pad3_hold_force as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let touch_pad4_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad4_hold_force) };
            touch_pad4_hold_force as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let touch_pad5_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad5_hold_force) };
            touch_pad5_hold_force as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let touch_pad6_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad6_hold_force) };
            touch_pad6_hold_force as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let touch_pad7_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad7_hold_force) };
            touch_pad7_hold_force as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let x32p_hold_force: u32 = unsafe { ::core::mem::transmute(x32p_hold_force) };
            x32p_hold_force as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let x32n_hold_force: u32 = unsafe { ::core::mem::transmute(x32n_hold_force) };
            x32n_hold_force as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_34 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_34 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_34 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_35 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_35__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_35__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_35__bindgen_ty_1 {
    #[inline]
    pub fn ext_wakeup1_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_ext_wakeup1_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_wakeup1_status_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_wakeup1_status_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ext_wakeup1_sel: u32,
        ext_wakeup1_status_clr: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let ext_wakeup1_sel: u32 = unsafe { ::core::mem::transmute(ext_wakeup1_sel) };
            ext_wakeup1_sel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ext_wakeup1_status_clr: u32 =
                unsafe { ::core::mem::transmute(ext_wakeup1_status_clr) };
            ext_wakeup1_status_clr as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_35 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_35 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_35 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_36 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_36__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_36__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_36__bindgen_ty_1 {
    #[inline]
    pub fn ext_wakeup1_status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_ext_wakeup1_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ext_wakeup1_status: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let ext_wakeup1_status: u32 = unsafe { ::core::mem::transmute(ext_wakeup1_status) };
            ext_wakeup1_status as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_36 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_36 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_36 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_37 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_37__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_37__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_37__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn close_flash_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_flash_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_rf_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_rf_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rst_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thres(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_thres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        close_flash_ena: u32,
        pd_rf_ena: u32,
        rst_wait: u32,
        rst_ena: u32,
        thres: u32,
        ena: u32,
        det: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let close_flash_ena: u32 = unsafe { ::core::mem::transmute(close_flash_ena) };
            close_flash_ena as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let pd_rf_ena: u32 = unsafe { ::core::mem::transmute(pd_rf_ena) };
            pd_rf_ena as u64
        });
        __bindgen_bitfield_unit.set(16usize, 10u8, {
            let rst_wait: u32 = unsafe { ::core::mem::transmute(rst_wait) };
            rst_wait as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rst_ena: u32 = unsafe { ::core::mem::transmute(rst_ena) };
            rst_ena as u64
        });
        __bindgen_bitfield_unit.set(27usize, 3u8, {
            let thres: u32 = unsafe { ::core::mem::transmute(thres) };
            thres as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ena: u32 = unsafe { ::core::mem::transmute(ena) };
            ena as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let det: u32 = unsafe { ::core::mem::transmute(det) };
            det as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_37 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_37 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_37 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_38 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_38__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_cntl_dev_s__bindgen_ty_38__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_38__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved28: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtc_cntl_dev_s__bindgen_ty_38 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s__bindgen_ty_38 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtc_cntl_dev_s__bindgen_ty_38 {{ union }}")
    }
}
impl Default for rtc_cntl_dev_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtc_cntl_dev_s {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "rtc_cntl_dev_s {{ options0: {:?}, slp_timer0: {:?}, slp_timer1: {:?}, time_update: {:?}, time0: {:?}, time1: {:?}, state0: {:?}, timer1: {:?}, timer2: {:?}, timer3: {:?}, timer4: {:?}, timer5: {:?}, ana_conf: {:?}, reset_state: {:?}, wakeup_state: {:?}, int_ena: {:?}, int_raw: {:?}, int_st: {:?}, int_clr: {:?}, rtc_store0: {:?}, rtc_store1: {:?}, rtc_store2: {:?}, rtc_store3: {:?}, ext_xtl_conf: {:?}, ext_wakeup_conf: {:?}, slp_reject_conf: {:?}, cpu_period_conf: {:?}, sdio_act_conf: {:?}, clk_conf: {:?}, sdio_conf: {:?}, bias_conf: {:?}, rtc: {:?}, rtc_pwc: {:?}, dig_pwc: {:?}, dig_iso: {:?}, wdt_config0: {:?}, wdt_config1: {:?}, wdt_config2: {:?}, wdt_config3: {:?}, wdt_config4: {:?}, wdt_feed: {:?}, wdt_wprotect: {:?}, test_mux: {:?}, sw_cpu_stall: {:?}, store4: {:?}, store5: {:?}, store6: {:?}, store7: {:?}, diag0: {:?}, diag1: {:?}, hold_force: {:?}, ext_wakeup1: {:?}, ext_wakeup1_status: {:?}, brown_out: {:?}, reserved_39: {:?}, reserved_3d: {:?}, reserved_41: {:?}, reserved_45: {:?}, reserved_49: {:?}, reserved_4d: {:?}, date: {:?} }}" , self . options0 , self . slp_timer0 , self . slp_timer1 , self . time_update , self . time0 , self . time1 , self . state0 , self . timer1 , self . timer2 , self . timer3 , self . timer4 , self . timer5 , self . ana_conf , self . reset_state , self . wakeup_state , self . int_ena , self . int_raw , self . int_st , self . int_clr , self . rtc_store0 , self . rtc_store1 , self . rtc_store2 , self . rtc_store3 , self . ext_xtl_conf , self . ext_wakeup_conf , self . slp_reject_conf , self . cpu_period_conf , self . sdio_act_conf , self . clk_conf , self . sdio_conf , self . bias_conf , self . rtc , self . rtc_pwc , self . dig_pwc , self . dig_iso , self . wdt_config0 , self . wdt_config1 , self . wdt_config2 , self . wdt_config3 , self . wdt_config4 , self . wdt_feed , self . wdt_wprotect , self . test_mux , self . sw_cpu_stall , self . store4 , self . store5 , self . store6 , self . store7 , self . diag0 , self . diag1 , self . hold_force , self . ext_wakeup1 , self . ext_wakeup1_status , self . brown_out , self . reserved_39 , self . reserved_3d , self . reserved_41 , self . reserved_45 , self . reserved_49 , self . reserved_4d , self . date )
    }
}
pub type rtc_cntl_dev_t = rtc_cntl_dev_s;
extern "C" {
    pub static mut RTCCNTL: rtc_cntl_dev_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct rtc_gpio_desc_t {
    pub reg: u32,
    pub mux: u32,
    pub func: u32,
    pub ie: u32,
    pub pullup: u32,
    pub pulldown: u32,
    pub slpsel: u32,
    pub slpie: u32,
    pub hold: u32,
    pub hold_force: u32,
    pub drv_v: u32,
    pub drv_s: u32,
    pub rtc_num: std::os::raw::c_int,
}
extern "C" {
    pub static rtc_gpio_desc: [rtc_gpio_desc_t; 40usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum periph_module_t {
    PERIPH_LEDC_MODULE = 0,
    PERIPH_UART0_MODULE = 1,
    PERIPH_UART1_MODULE = 2,
    PERIPH_UART2_MODULE = 3,
    PERIPH_I2C0_MODULE = 4,
    PERIPH_I2C1_MODULE = 5,
    PERIPH_I2S0_MODULE = 6,
    PERIPH_I2S1_MODULE = 7,
    PERIPH_TIMG0_MODULE = 8,
    PERIPH_TIMG1_MODULE = 9,
    PERIPH_PWM0_MODULE = 10,
    PERIPH_PWM1_MODULE = 11,
    PERIPH_PWM2_MODULE = 12,
    PERIPH_PWM3_MODULE = 13,
    PERIPH_UHCI0_MODULE = 14,
    PERIPH_UHCI1_MODULE = 15,
    PERIPH_RMT_MODULE = 16,
    PERIPH_PCNT_MODULE = 17,
    PERIPH_SPI_MODULE = 18,
    PERIPH_HSPI_MODULE = 19,
    PERIPH_VSPI_MODULE = 20,
    PERIPH_SPI_DMA_MODULE = 21,
    PERIPH_SDMMC_MODULE = 22,
    PERIPH_SDIO_SLAVE_MODULE = 23,
    PERIPH_CAN_MODULE = 24,
    PERIPH_EMAC_MODULE = 25,
    PERIPH_RNG_MODULE = 26,
    PERIPH_WIFI_MODULE = 27,
    PERIPH_BT_MODULE = 28,
    PERIPH_WIFI_BT_COMMON_MODULE = 29,
    PERIPH_BT_BASEBAND_MODULE = 30,
    PERIPH_BT_LC_MODULE = 31,
    PERIPH_AES_MODULE = 32,
    PERIPH_SHA_MODULE = 33,
    PERIPH_RSA_MODULE = 34,
}
extern "C" {
    pub fn periph_module_enable(periph: periph_module_t);
}
extern "C" {
    pub fn periph_module_disable(periph: periph_module_t);
}
extern "C" {
    pub fn periph_module_reset(periph: periph_module_t);
}
impl i2s_bits_per_sample_t {
    pub const I2S_BITS_PER_SAMPLE_8BIT: i2s_bits_per_sample_t = i2s_bits_per_sample_t(8);
}
impl i2s_bits_per_sample_t {
    pub const I2S_BITS_PER_SAMPLE_16BIT: i2s_bits_per_sample_t = i2s_bits_per_sample_t(16);
}
impl i2s_bits_per_sample_t {
    pub const I2S_BITS_PER_SAMPLE_24BIT: i2s_bits_per_sample_t = i2s_bits_per_sample_t(24);
}
impl i2s_bits_per_sample_t {
    pub const I2S_BITS_PER_SAMPLE_32BIT: i2s_bits_per_sample_t = i2s_bits_per_sample_t(32);
}
impl ::core::ops::BitOr<i2s_bits_per_sample_t> for i2s_bits_per_sample_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        i2s_bits_per_sample_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for i2s_bits_per_sample_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: i2s_bits_per_sample_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<i2s_bits_per_sample_t> for i2s_bits_per_sample_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        i2s_bits_per_sample_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for i2s_bits_per_sample_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: i2s_bits_per_sample_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct i2s_bits_per_sample_t(pub u32);
impl i2s_channel_t {
    pub const I2S_CHANNEL_MONO: i2s_channel_t = i2s_channel_t(1);
}
impl i2s_channel_t {
    pub const I2S_CHANNEL_STEREO: i2s_channel_t = i2s_channel_t(2);
}
impl ::core::ops::BitOr<i2s_channel_t> for i2s_channel_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        i2s_channel_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for i2s_channel_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: i2s_channel_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<i2s_channel_t> for i2s_channel_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        i2s_channel_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for i2s_channel_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: i2s_channel_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct i2s_channel_t(pub u32);
impl i2s_comm_format_t {
    pub const I2S_COMM_FORMAT_I2S: i2s_comm_format_t = i2s_comm_format_t(1);
}
impl i2s_comm_format_t {
    pub const I2S_COMM_FORMAT_I2S_MSB: i2s_comm_format_t = i2s_comm_format_t(2);
}
impl i2s_comm_format_t {
    pub const I2S_COMM_FORMAT_I2S_LSB: i2s_comm_format_t = i2s_comm_format_t(4);
}
impl i2s_comm_format_t {
    pub const I2S_COMM_FORMAT_PCM: i2s_comm_format_t = i2s_comm_format_t(8);
}
impl i2s_comm_format_t {
    pub const I2S_COMM_FORMAT_PCM_SHORT: i2s_comm_format_t = i2s_comm_format_t(16);
}
impl i2s_comm_format_t {
    pub const I2S_COMM_FORMAT_PCM_LONG: i2s_comm_format_t = i2s_comm_format_t(32);
}
impl ::core::ops::BitOr<i2s_comm_format_t> for i2s_comm_format_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        i2s_comm_format_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for i2s_comm_format_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: i2s_comm_format_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<i2s_comm_format_t> for i2s_comm_format_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        i2s_comm_format_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for i2s_comm_format_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: i2s_comm_format_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct i2s_comm_format_t(pub u32);
impl i2s_channel_fmt_t {
    pub const I2S_CHANNEL_FMT_RIGHT_LEFT: i2s_channel_fmt_t = i2s_channel_fmt_t(0);
}
impl i2s_channel_fmt_t {
    pub const I2S_CHANNEL_FMT_ALL_RIGHT: i2s_channel_fmt_t = i2s_channel_fmt_t(1);
}
impl i2s_channel_fmt_t {
    pub const I2S_CHANNEL_FMT_ALL_LEFT: i2s_channel_fmt_t = i2s_channel_fmt_t(2);
}
impl i2s_channel_fmt_t {
    pub const I2S_CHANNEL_FMT_ONLY_RIGHT: i2s_channel_fmt_t = i2s_channel_fmt_t(3);
}
impl i2s_channel_fmt_t {
    pub const I2S_CHANNEL_FMT_ONLY_LEFT: i2s_channel_fmt_t = i2s_channel_fmt_t(4);
}
impl ::core::ops::BitOr<i2s_channel_fmt_t> for i2s_channel_fmt_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        i2s_channel_fmt_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for i2s_channel_fmt_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: i2s_channel_fmt_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<i2s_channel_fmt_t> for i2s_channel_fmt_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        i2s_channel_fmt_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for i2s_channel_fmt_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: i2s_channel_fmt_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct i2s_channel_fmt_t(pub u32);
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pdm_sample_rate_ratio_t {
    PDM_SAMPLE_RATE_RATIO_64 = 0,
    PDM_SAMPLE_RATE_RATIO_128 = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pdm_pcm_conv_t {
    PDM_PCM_CONV_ENABLE = 0,
    PDM_PCM_CONV_DISABLE = 1,
}
impl i2s_port_t {
    pub const I2S_NUM_0: i2s_port_t = i2s_port_t(0);
}
impl i2s_port_t {
    pub const I2S_NUM_1: i2s_port_t = i2s_port_t(1);
}
impl i2s_port_t {
    pub const I2S_NUM_MAX: i2s_port_t = i2s_port_t(2);
}
impl ::core::ops::BitOr<i2s_port_t> for i2s_port_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        i2s_port_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for i2s_port_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: i2s_port_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<i2s_port_t> for i2s_port_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        i2s_port_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for i2s_port_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: i2s_port_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct i2s_port_t(pub u32);
impl i2s_mode_t {
    pub const I2S_MODE_MASTER: i2s_mode_t = i2s_mode_t(1);
}
impl i2s_mode_t {
    pub const I2S_MODE_SLAVE: i2s_mode_t = i2s_mode_t(2);
}
impl i2s_mode_t {
    pub const I2S_MODE_TX: i2s_mode_t = i2s_mode_t(4);
}
impl i2s_mode_t {
    pub const I2S_MODE_RX: i2s_mode_t = i2s_mode_t(8);
}
impl i2s_mode_t {
    pub const I2S_MODE_DAC_BUILT_IN: i2s_mode_t = i2s_mode_t(16);
}
impl i2s_mode_t {
    pub const I2S_MODE_ADC_BUILT_IN: i2s_mode_t = i2s_mode_t(32);
}
impl i2s_mode_t {
    pub const I2S_MODE_PDM: i2s_mode_t = i2s_mode_t(64);
}
impl ::core::ops::BitOr<i2s_mode_t> for i2s_mode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        i2s_mode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for i2s_mode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: i2s_mode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<i2s_mode_t> for i2s_mode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        i2s_mode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for i2s_mode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: i2s_mode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct i2s_mode_t(pub u32);
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct i2s_config_t {
    pub mode: i2s_mode_t,
    pub sample_rate: std::os::raw::c_int,
    pub bits_per_sample: i2s_bits_per_sample_t,
    pub channel_format: i2s_channel_fmt_t,
    pub communication_format: i2s_comm_format_t,
    pub intr_alloc_flags: std::os::raw::c_int,
    pub dma_buf_count: std::os::raw::c_int,
    pub dma_buf_len: std::os::raw::c_int,
    pub use_apll: bool,
    pub tx_desc_auto_clear: bool,
    pub fixed_mclk: std::os::raw::c_int,
}
impl Default for i2s_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl i2s_event_type_t {
    pub const I2S_EVENT_DMA_ERROR: i2s_event_type_t = i2s_event_type_t(0);
}
impl i2s_event_type_t {
    pub const I2S_EVENT_TX_DONE: i2s_event_type_t = i2s_event_type_t(1);
}
impl i2s_event_type_t {
    pub const I2S_EVENT_RX_DONE: i2s_event_type_t = i2s_event_type_t(2);
}
impl i2s_event_type_t {
    pub const I2S_EVENT_MAX: i2s_event_type_t = i2s_event_type_t(3);
}
impl ::core::ops::BitOr<i2s_event_type_t> for i2s_event_type_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        i2s_event_type_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for i2s_event_type_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: i2s_event_type_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<i2s_event_type_t> for i2s_event_type_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        i2s_event_type_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for i2s_event_type_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: i2s_event_type_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct i2s_event_type_t(pub u32);
impl i2s_dac_mode_t {
    pub const I2S_DAC_CHANNEL_DISABLE: i2s_dac_mode_t = i2s_dac_mode_t(0);
}
impl i2s_dac_mode_t {
    pub const I2S_DAC_CHANNEL_RIGHT_EN: i2s_dac_mode_t = i2s_dac_mode_t(1);
}
impl i2s_dac_mode_t {
    pub const I2S_DAC_CHANNEL_LEFT_EN: i2s_dac_mode_t = i2s_dac_mode_t(2);
}
impl i2s_dac_mode_t {
    pub const I2S_DAC_CHANNEL_BOTH_EN: i2s_dac_mode_t = i2s_dac_mode_t(3);
}
impl i2s_dac_mode_t {
    pub const I2S_DAC_CHANNEL_MAX: i2s_dac_mode_t = i2s_dac_mode_t(4);
}
impl ::core::ops::BitOr<i2s_dac_mode_t> for i2s_dac_mode_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        i2s_dac_mode_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for i2s_dac_mode_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: i2s_dac_mode_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<i2s_dac_mode_t> for i2s_dac_mode_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        i2s_dac_mode_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for i2s_dac_mode_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: i2s_dac_mode_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct i2s_dac_mode_t(pub u32);
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct i2s_event_t {
    pub type_: i2s_event_type_t,
    pub size: usize,
}
impl Default for i2s_event_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct i2s_pin_config_t {
    pub bck_io_num: std::os::raw::c_int,
    pub ws_io_num: std::os::raw::c_int,
    pub data_out_num: std::os::raw::c_int,
    pub data_in_num: std::os::raw::c_int,
}
impl i2s_pdm_dsr_t {
    pub const I2S_PDM_DSR_8S: i2s_pdm_dsr_t = i2s_pdm_dsr_t(0);
}
impl i2s_pdm_dsr_t {
    pub const I2S_PDM_DSR_16S: i2s_pdm_dsr_t = i2s_pdm_dsr_t(1);
}
impl i2s_pdm_dsr_t {
    pub const I2S_PDM_DSR_MAX: i2s_pdm_dsr_t = i2s_pdm_dsr_t(2);
}
impl ::core::ops::BitOr<i2s_pdm_dsr_t> for i2s_pdm_dsr_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        i2s_pdm_dsr_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for i2s_pdm_dsr_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: i2s_pdm_dsr_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<i2s_pdm_dsr_t> for i2s_pdm_dsr_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        i2s_pdm_dsr_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for i2s_pdm_dsr_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: i2s_pdm_dsr_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct i2s_pdm_dsr_t(pub u32);
pub type i2s_isr_handle_t = intr_handle_t;
extern "C" {
    pub fn i2s_set_pin(i2s_num: i2s_port_t, pin: *const i2s_pin_config_t) -> esp_err_t;
}
extern "C" {
    pub fn i2s_set_pdm_rx_down_sample(i2s_num: i2s_port_t, dsr: i2s_pdm_dsr_t) -> esp_err_t;
}
extern "C" {
    pub fn i2s_set_dac_mode(dac_mode: i2s_dac_mode_t) -> esp_err_t;
}
extern "C" {
    pub fn i2s_driver_install(
        i2s_num: i2s_port_t,
        i2s_config: *const i2s_config_t,
        queue_size: std::os::raw::c_int,
        i2s_queue: *mut std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2s_driver_uninstall(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    pub fn i2s_write(
        i2s_num: i2s_port_t,
        src: *const std::os::raw::c_void,
        size: usize,
        bytes_written: *mut usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2s_write_expand(
        i2s_num: i2s_port_t,
        src: *const std::os::raw::c_void,
        size: usize,
        src_bits: usize,
        aim_bits: usize,
        bytes_written: *mut usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2s_read(
        i2s_num: i2s_port_t,
        dest: *mut std::os::raw::c_void,
        size: usize,
        bytes_read: *mut usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2s_set_sample_rates(i2s_num: i2s_port_t, rate: u32) -> esp_err_t;
}
extern "C" {
    pub fn i2s_stop(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    pub fn i2s_start(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    pub fn i2s_zero_dma_buffer(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    pub fn i2s_set_clk(
        i2s_num: i2s_port_t,
        rate: u32,
        bits: i2s_bits_per_sample_t,
        ch: i2s_channel_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn i2s_get_clk(i2s_num: i2s_port_t) -> f32;
}
extern "C" {
    pub fn i2s_set_adc_mode(adc_unit: adc_unit_t, adc_channel: adc1_channel_t) -> esp_err_t;
}
extern "C" {
    pub fn i2s_adc_enable(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    pub fn i2s_adc_disable(i2s_num: i2s_port_t) -> esp_err_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ledc_mode_t {
    LEDC_HIGH_SPEED_MODE = 0,
    LEDC_LOW_SPEED_MODE = 1,
    LEDC_SPEED_MODE_MAX = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ledc_intr_type_t {
    LEDC_INTR_DISABLE = 0,
    LEDC_INTR_FADE_END = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ledc_duty_direction_t {
    LEDC_DUTY_DIR_DECREASE = 0,
    LEDC_DUTY_DIR_INCREASE = 1,
    LEDC_DUTY_DIR_MAX = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ledc_clk_src_t {
    LEDC_REF_TICK = 0,
    LEDC_APB_CLK = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ledc_clk_cfg_t {
    LEDC_AUTO_CLK = 0,
    LEDC_USE_REF_TICK = 1,
    LEDC_USE_APB_CLK = 2,
    LEDC_USE_RTC8M_CLK = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ledc_timer_t {
    LEDC_TIMER_0 = 0,
    LEDC_TIMER_1 = 1,
    LEDC_TIMER_2 = 2,
    LEDC_TIMER_3 = 3,
    LEDC_TIMER_MAX = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ledc_channel_t {
    LEDC_CHANNEL_0 = 0,
    LEDC_CHANNEL_1 = 1,
    LEDC_CHANNEL_2 = 2,
    LEDC_CHANNEL_3 = 3,
    LEDC_CHANNEL_4 = 4,
    LEDC_CHANNEL_5 = 5,
    LEDC_CHANNEL_6 = 6,
    LEDC_CHANNEL_7 = 7,
    LEDC_CHANNEL_MAX = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ledc_timer_bit_t {
    LEDC_TIMER_1_BIT = 1,
    LEDC_TIMER_2_BIT = 2,
    LEDC_TIMER_3_BIT = 3,
    LEDC_TIMER_4_BIT = 4,
    LEDC_TIMER_5_BIT = 5,
    LEDC_TIMER_6_BIT = 6,
    LEDC_TIMER_7_BIT = 7,
    LEDC_TIMER_8_BIT = 8,
    LEDC_TIMER_9_BIT = 9,
    LEDC_TIMER_10_BIT = 10,
    LEDC_TIMER_11_BIT = 11,
    LEDC_TIMER_12_BIT = 12,
    LEDC_TIMER_13_BIT = 13,
    LEDC_TIMER_14_BIT = 14,
    LEDC_TIMER_15_BIT = 15,
    LEDC_TIMER_16_BIT = 16,
    LEDC_TIMER_17_BIT = 17,
    LEDC_TIMER_18_BIT = 18,
    LEDC_TIMER_19_BIT = 19,
    LEDC_TIMER_20_BIT = 20,
    LEDC_TIMER_BIT_MAX = 21,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ledc_fade_mode_t {
    LEDC_FADE_NO_WAIT = 0,
    LEDC_FADE_WAIT_DONE = 1,
    LEDC_FADE_MAX = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ledc_channel_config_t {
    pub gpio_num: std::os::raw::c_int,
    pub speed_mode: ledc_mode_t,
    pub channel: ledc_channel_t,
    pub intr_type: ledc_intr_type_t,
    pub timer_sel: ledc_timer_t,
    pub duty: u32,
    pub hpoint: std::os::raw::c_int,
}
impl Default for ledc_channel_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ledc_timer_config_t {
    pub speed_mode: ledc_mode_t,
    pub duty_resolution: ledc_timer_bit_t,
    pub timer_num: ledc_timer_t,
    pub freq_hz: u32,
    pub clk_cfg: ledc_clk_cfg_t,
}
impl Default for ledc_timer_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ledc_isr_handle_t = intr_handle_t;
extern "C" {
    pub fn ledc_channel_config(ledc_conf: *const ledc_channel_config_t) -> esp_err_t;
}
extern "C" {
    pub fn ledc_timer_config(timer_conf: *const ledc_timer_config_t) -> esp_err_t;
}
extern "C" {
    pub fn ledc_update_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t) -> esp_err_t;
}
extern "C" {
    pub fn ledc_stop(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        idle_level: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_set_freq(
        speed_mode: ledc_mode_t,
        timer_num: ledc_timer_t,
        freq_hz: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_get_freq(speed_mode: ledc_mode_t, timer_num: ledc_timer_t) -> u32;
}
extern "C" {
    pub fn ledc_set_duty_with_hpoint(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        hpoint: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_get_hpoint(speed_mode: ledc_mode_t, channel: ledc_channel_t)
        -> std::os::raw::c_int;
}
extern "C" {
    pub fn ledc_set_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t, duty: u32) -> esp_err_t;
}
extern "C" {
    pub fn ledc_get_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t) -> u32;
}
extern "C" {
    pub fn ledc_set_fade(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        fade_direction: ledc_duty_direction_t,
        step_num: u32,
        duty_cyle_num: u32,
        duty_scale: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void)>,
        arg: *mut std::os::raw::c_void,
        intr_alloc_flags: std::os::raw::c_int,
        handle: *mut ledc_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_timer_set(
        speed_mode: ledc_mode_t,
        timer_sel: ledc_timer_t,
        clock_divider: u32,
        duty_resolution: u32,
        clk_src: ledc_clk_src_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_timer_rst(speed_mode: ledc_mode_t, timer_sel: u32) -> esp_err_t;
}
extern "C" {
    pub fn ledc_timer_pause(speed_mode: ledc_mode_t, timer_sel: u32) -> esp_err_t;
}
extern "C" {
    pub fn ledc_timer_resume(speed_mode: ledc_mode_t, timer_sel: u32) -> esp_err_t;
}
extern "C" {
    pub fn ledc_bind_channel_timer(
        speed_mode: ledc_mode_t,
        channel: u32,
        timer_idx: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_set_fade_with_step(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        scale: u32,
        cycle_num: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_set_fade_with_time(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        max_fade_time_ms: std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_fade_func_install(intr_alloc_flags: std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    pub fn ledc_fade_func_uninstall();
}
extern "C" {
    pub fn ledc_fade_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_set_duty_and_update(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        hpoint: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_set_fade_time_and_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        max_fade_time_ms: u32,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn ledc_set_fade_step_and_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        scale: u32,
        cycle_num: u32,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldesc_s {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub buf: *mut u8,
    pub __bindgen_anon_1: lldesc_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lldesc_s__bindgen_ty_1 {
    pub empty: u32,
    pub qe: lldesc_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct lldesc_s__bindgen_ty_1__bindgen_ty_1 {
    pub stqe_next: *mut lldesc_s,
}
impl Default for lldesc_s__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for lldesc_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for lldesc_s__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "lldesc_s__bindgen_ty_1 {{ union }}")
    }
}
impl Default for lldesc_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for lldesc_s {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "lldesc_s {{ size : {:?}, length : {:?}, offset : {:?}, sosf : {:?}, eof : {:?}, owner : {:?}, buf: {:?}, __bindgen_anon_1: {:?} }}" , self . size ( ) , self . length ( ) , self . offset ( ) , self . sosf ( ) , self . eof ( ) , self . owner ( ) , self . buf , self . __bindgen_anon_1 )
    }
}
impl lldesc_s {
    #[inline]
    pub fn size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn offset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sosf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sosf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn owner(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_owner(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        size: u32,
        length: u32,
        offset: u32,
        sosf: u32,
        eof: u32,
        owner: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let length: u32 = unsafe { ::core::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let sosf: u32 = unsafe { ::core::mem::transmute(sosf) };
            sosf as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let eof: u32 = unsafe { ::core::mem::transmute(eof) };
            eof as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let owner: u32 = unsafe { ::core::mem::transmute(owner) };
            owner as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lldesc_t = lldesc_s;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct tx_ampdu_entry_s {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl tx_ampdu_entry_s {
    #[inline]
    pub fn sub_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sub_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn dili_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_dili_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn null_byte(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_null_byte(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn seq(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_seq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sub_len: u32,
        dili_num: u32,
        null_byte: u32,
        data: u32,
        enc: u32,
        seq: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let sub_len: u32 = unsafe { ::core::mem::transmute(sub_len) };
            sub_len as u64
        });
        __bindgen_bitfield_unit.set(12usize, 7u8, {
            let dili_num: u32 = unsafe { ::core::mem::transmute(dili_num) };
            dili_num as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let null_byte: u32 = unsafe { ::core::mem::transmute(null_byte) };
            null_byte as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let enc: u32 = unsafe { ::core::mem::transmute(enc) };
            enc as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let seq: u32 = unsafe { ::core::mem::transmute(seq) };
            seq as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type tx_ampdu_entry_t = tx_ampdu_entry_s;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct lldesc_chain_s {
    pub head: *mut lldesc_t,
    pub tail: *mut lldesc_t,
}
impl Default for lldesc_chain_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lldesc_chain_t = lldesc_chain_s;
extern "C" {
    pub fn lldesc_build_chain(
        descptr: *mut u8,
        desclen: u32,
        mblkptr: *mut u8,
        buflen: u32,
        blksz: u32,
        owner: u8,
        head: *mut *mut lldesc_t,
        tail: *mut *mut lldesc_t,
    );
}
extern "C" {
    pub fn lldesc_num2link(head: *mut lldesc_t, nblks: u16) -> *mut lldesc_t;
}
extern "C" {
    pub fn lldesc_set_owner(head: *mut lldesc_t, nblks: u16, owner: u8) -> *mut lldesc_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spi_dev_s {
    pub cmd: spi_dev_s__bindgen_ty_1,
    pub addr: u32,
    pub ctrl: spi_dev_s__bindgen_ty_2,
    pub ctrl1: spi_dev_s__bindgen_ty_3,
    pub rd_status: spi_dev_s__bindgen_ty_4,
    pub ctrl2: spi_dev_s__bindgen_ty_5,
    pub clock: spi_dev_s__bindgen_ty_6,
    pub user: spi_dev_s__bindgen_ty_7,
    pub user1: spi_dev_s__bindgen_ty_8,
    pub user2: spi_dev_s__bindgen_ty_9,
    pub mosi_dlen: spi_dev_s__bindgen_ty_10,
    pub miso_dlen: spi_dev_s__bindgen_ty_11,
    pub slv_wr_status: u32,
    pub pin: spi_dev_s__bindgen_ty_12,
    pub slave: spi_dev_s__bindgen_ty_13,
    pub slave1: spi_dev_s__bindgen_ty_14,
    pub slave2: spi_dev_s__bindgen_ty_15,
    pub slave3: spi_dev_s__bindgen_ty_16,
    pub slv_wrbuf_dlen: spi_dev_s__bindgen_ty_17,
    pub slv_rdbuf_dlen: spi_dev_s__bindgen_ty_18,
    pub cache_fctrl: spi_dev_s__bindgen_ty_19,
    pub cache_sctrl: spi_dev_s__bindgen_ty_20,
    pub sram_cmd: spi_dev_s__bindgen_ty_21,
    pub sram_drd_cmd: spi_dev_s__bindgen_ty_22,
    pub sram_dwr_cmd: spi_dev_s__bindgen_ty_23,
    pub slv_rd_bit: spi_dev_s__bindgen_ty_24,
    pub reserved_68: u32,
    pub reserved_6c: u32,
    pub reserved_70: u32,
    pub reserved_74: u32,
    pub reserved_78: u32,
    pub reserved_7c: u32,
    pub data_buf: [u32; 16usize],
    pub tx_crc: u32,
    pub reserved_c4: u32,
    pub reserved_c8: u32,
    pub reserved_cc: u32,
    pub reserved_d0: u32,
    pub reserved_d4: u32,
    pub reserved_d8: u32,
    pub reserved_dc: u32,
    pub reserved_e0: u32,
    pub reserved_e4: u32,
    pub reserved_e8: u32,
    pub reserved_ec: u32,
    pub ext0: spi_dev_s__bindgen_ty_25,
    pub ext1: spi_dev_s__bindgen_ty_26,
    pub ext2: spi_dev_s__bindgen_ty_27,
    pub ext3: spi_dev_s__bindgen_ty_28,
    pub dma_conf: spi_dev_s__bindgen_ty_29,
    pub dma_out_link: spi_dev_s__bindgen_ty_30,
    pub dma_in_link: spi_dev_s__bindgen_ty_31,
    pub dma_status: spi_dev_s__bindgen_ty_32,
    pub dma_int_ena: spi_dev_s__bindgen_ty_33,
    pub dma_int_raw: spi_dev_s__bindgen_ty_34,
    pub dma_int_st: spi_dev_s__bindgen_ty_35,
    pub dma_int_clr: spi_dev_s__bindgen_ty_36,
    pub dma_in_err_eof_des_addr: u32,
    pub dma_in_suc_eof_des_addr: u32,
    pub dma_inlink_dscr: u32,
    pub dma_inlink_dscr_bf0: u32,
    pub dma_inlink_dscr_bf1: u32,
    pub dma_out_eof_bfr_des_addr: u32,
    pub dma_out_eof_des_addr: u32,
    pub dma_outlink_dscr: u32,
    pub dma_outlink_dscr_bf0: u32,
    pub dma_outlink_dscr_bf1: u32,
    pub dma_rx_status: u32,
    pub dma_tx_status: u32,
    pub reserved_150: u32,
    pub reserved_154: u32,
    pub reserved_158: u32,
    pub reserved_15c: u32,
    pub reserved_160: u32,
    pub reserved_164: u32,
    pub reserved_168: u32,
    pub reserved_16c: u32,
    pub reserved_170: u32,
    pub reserved_174: u32,
    pub reserved_178: u32,
    pub reserved_17c: u32,
    pub reserved_180: u32,
    pub reserved_184: u32,
    pub reserved_188: u32,
    pub reserved_18c: u32,
    pub reserved_190: u32,
    pub reserved_194: u32,
    pub reserved_198: u32,
    pub reserved_19c: u32,
    pub reserved_1a0: u32,
    pub reserved_1a4: u32,
    pub reserved_1a8: u32,
    pub reserved_1ac: u32,
    pub reserved_1b0: u32,
    pub reserved_1b4: u32,
    pub reserved_1b8: u32,
    pub reserved_1bc: u32,
    pub reserved_1c0: u32,
    pub reserved_1c4: u32,
    pub reserved_1c8: u32,
    pub reserved_1cc: u32,
    pub reserved_1d0: u32,
    pub reserved_1d4: u32,
    pub reserved_1d8: u32,
    pub reserved_1dc: u32,
    pub reserved_1e0: u32,
    pub reserved_1e4: u32,
    pub reserved_1e8: u32,
    pub reserved_1ec: u32,
    pub reserved_1f0: u32,
    pub reserved_1f4: u32,
    pub reserved_1f8: u32,
    pub reserved_1fc: u32,
    pub reserved_200: u32,
    pub reserved_204: u32,
    pub reserved_208: u32,
    pub reserved_20c: u32,
    pub reserved_210: u32,
    pub reserved_214: u32,
    pub reserved_218: u32,
    pub reserved_21c: u32,
    pub reserved_220: u32,
    pub reserved_224: u32,
    pub reserved_228: u32,
    pub reserved_22c: u32,
    pub reserved_230: u32,
    pub reserved_234: u32,
    pub reserved_238: u32,
    pub reserved_23c: u32,
    pub reserved_240: u32,
    pub reserved_244: u32,
    pub reserved_248: u32,
    pub reserved_24c: u32,
    pub reserved_250: u32,
    pub reserved_254: u32,
    pub reserved_258: u32,
    pub reserved_25c: u32,
    pub reserved_260: u32,
    pub reserved_264: u32,
    pub reserved_268: u32,
    pub reserved_26c: u32,
    pub reserved_270: u32,
    pub reserved_274: u32,
    pub reserved_278: u32,
    pub reserved_27c: u32,
    pub reserved_280: u32,
    pub reserved_284: u32,
    pub reserved_288: u32,
    pub reserved_28c: u32,
    pub reserved_290: u32,
    pub reserved_294: u32,
    pub reserved_298: u32,
    pub reserved_29c: u32,
    pub reserved_2a0: u32,
    pub reserved_2a4: u32,
    pub reserved_2a8: u32,
    pub reserved_2ac: u32,
    pub reserved_2b0: u32,
    pub reserved_2b4: u32,
    pub reserved_2b8: u32,
    pub reserved_2bc: u32,
    pub reserved_2c0: u32,
    pub reserved_2c4: u32,
    pub reserved_2c8: u32,
    pub reserved_2cc: u32,
    pub reserved_2d0: u32,
    pub reserved_2d4: u32,
    pub reserved_2d8: u32,
    pub reserved_2dc: u32,
    pub reserved_2e0: u32,
    pub reserved_2e4: u32,
    pub reserved_2e8: u32,
    pub reserved_2ec: u32,
    pub reserved_2f0: u32,
    pub reserved_2f4: u32,
    pub reserved_2f8: u32,
    pub reserved_2fc: u32,
    pub reserved_300: u32,
    pub reserved_304: u32,
    pub reserved_308: u32,
    pub reserved_30c: u32,
    pub reserved_310: u32,
    pub reserved_314: u32,
    pub reserved_318: u32,
    pub reserved_31c: u32,
    pub reserved_320: u32,
    pub reserved_324: u32,
    pub reserved_328: u32,
    pub reserved_32c: u32,
    pub reserved_330: u32,
    pub reserved_334: u32,
    pub reserved_338: u32,
    pub reserved_33c: u32,
    pub reserved_340: u32,
    pub reserved_344: u32,
    pub reserved_348: u32,
    pub reserved_34c: u32,
    pub reserved_350: u32,
    pub reserved_354: u32,
    pub reserved_358: u32,
    pub reserved_35c: u32,
    pub reserved_360: u32,
    pub reserved_364: u32,
    pub reserved_368: u32,
    pub reserved_36c: u32,
    pub reserved_370: u32,
    pub reserved_374: u32,
    pub reserved_378: u32,
    pub reserved_37c: u32,
    pub reserved_380: u32,
    pub reserved_384: u32,
    pub reserved_388: u32,
    pub reserved_38c: u32,
    pub reserved_390: u32,
    pub reserved_394: u32,
    pub reserved_398: u32,
    pub reserved_39c: u32,
    pub reserved_3a0: u32,
    pub reserved_3a4: u32,
    pub reserved_3a8: u32,
    pub reserved_3ac: u32,
    pub reserved_3b0: u32,
    pub reserved_3b4: u32,
    pub reserved_3b8: u32,
    pub reserved_3bc: u32,
    pub reserved_3c0: u32,
    pub reserved_3c4: u32,
    pub reserved_3c8: u32,
    pub reserved_3cc: u32,
    pub reserved_3d0: u32,
    pub reserved_3d4: u32,
    pub reserved_3d8: u32,
    pub reserved_3dc: u32,
    pub reserved_3e0: u32,
    pub reserved_3e4: u32,
    pub reserved_3e8: u32,
    pub reserved_3ec: u32,
    pub reserved_3f0: u32,
    pub reserved_3f4: u32,
    pub reserved_3f8: u32,
    pub date: spi_dev_s__bindgen_ty_37,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_per(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_per(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_pes(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_pes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_hpm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_hpm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_res(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_dp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_dp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_ce(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_ce(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_be(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_be(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_se(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_se(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_pp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_pp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_wrsr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_wrsr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_rdsr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_rdsr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_rdid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_rdid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_wrdi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_wrdi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_wren(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_wren(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_read(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_read(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        flash_per: u32,
        flash_pes: u32,
        usr: u32,
        flash_hpm: u32,
        flash_res: u32,
        flash_dp: u32,
        flash_ce: u32,
        flash_be: u32,
        flash_se: u32,
        flash_pp: u32,
        flash_wrsr: u32,
        flash_rdsr: u32,
        flash_rdid: u32,
        flash_wrdi: u32,
        flash_wren: u32,
        flash_read: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let flash_per: u32 = unsafe { ::core::mem::transmute(flash_per) };
            flash_per as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let flash_pes: u32 = unsafe { ::core::mem::transmute(flash_pes) };
            flash_pes as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let usr: u32 = unsafe { ::core::mem::transmute(usr) };
            usr as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let flash_hpm: u32 = unsafe { ::core::mem::transmute(flash_hpm) };
            flash_hpm as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let flash_res: u32 = unsafe { ::core::mem::transmute(flash_res) };
            flash_res as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let flash_dp: u32 = unsafe { ::core::mem::transmute(flash_dp) };
            flash_dp as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let flash_ce: u32 = unsafe { ::core::mem::transmute(flash_ce) };
            flash_ce as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let flash_be: u32 = unsafe { ::core::mem::transmute(flash_be) };
            flash_be as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let flash_se: u32 = unsafe { ::core::mem::transmute(flash_se) };
            flash_se as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let flash_pp: u32 = unsafe { ::core::mem::transmute(flash_pp) };
            flash_pp as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let flash_wrsr: u32 = unsafe { ::core::mem::transmute(flash_wrsr) };
            flash_wrsr as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let flash_rdsr: u32 = unsafe { ::core::mem::transmute(flash_rdsr) };
            flash_rdsr as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let flash_rdid: u32 = unsafe { ::core::mem::transmute(flash_rdid) };
            flash_rdid as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let flash_wrdi: u32 = unsafe { ::core::mem::transmute(flash_wrdi) };
            flash_wrdi as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let flash_wren: u32 = unsafe { ::core::mem::transmute(flash_wren) };
            flash_wren as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let flash_read: u32 = unsafe { ::core::mem::transmute(flash_read) };
            flash_read as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn fcs_crc_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fcs_crc_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_crc_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_crc_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_flash_idle_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wait_flash_idle_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastrd_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastrd_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fread_dual(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fread_dual(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resandres(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resandres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fread_quad(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fread_quad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wrsr_2b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wrsr_2b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fread_dio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fread_dio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fread_qio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fread_qio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_bit_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_bit_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_bit_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_bit_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        fcs_crc_en: u32,
        tx_crc_en: u32,
        wait_flash_idle_en: u32,
        fastrd_mode: u32,
        fread_dual: u32,
        resandres: u32,
        reserved16: u32,
        fread_quad: u32,
        wp: u32,
        wrsr_2b: u32,
        fread_dio: u32,
        fread_qio: u32,
        rd_bit_order: u32,
        wr_bit_order: u32,
        reserved27: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let fcs_crc_en: u32 = unsafe { ::core::mem::transmute(fcs_crc_en) };
            fcs_crc_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_crc_en: u32 = unsafe { ::core::mem::transmute(tx_crc_en) };
            tx_crc_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let wait_flash_idle_en: u32 = unsafe { ::core::mem::transmute(wait_flash_idle_en) };
            wait_flash_idle_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fastrd_mode: u32 = unsafe { ::core::mem::transmute(fastrd_mode) };
            fastrd_mode as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fread_dual: u32 = unsafe { ::core::mem::transmute(fread_dual) };
            fread_dual as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let resandres: u32 = unsafe { ::core::mem::transmute(resandres) };
            resandres as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let fread_quad: u32 = unsafe { ::core::mem::transmute(fread_quad) };
            fread_quad as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let wp: u32 = unsafe { ::core::mem::transmute(wp) };
            wp as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let wrsr_2b: u32 = unsafe { ::core::mem::transmute(wrsr_2b) };
            wrsr_2b as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let fread_dio: u32 = unsafe { ::core::mem::transmute(fread_dio) };
            fread_dio as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let fread_qio: u32 = unsafe { ::core::mem::transmute(fread_qio) };
            fread_qio as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let rd_bit_order: u32 = unsafe { ::core::mem::transmute(rd_bit_order) };
            rd_bit_order as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let wr_bit_order: u32 = unsafe { ::core::mem::transmute(wr_bit_order) };
            wr_bit_order as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved27: u32 = unsafe { ::core::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_hold_delay_res(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_cs_hold_delay_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_hold_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_cs_hold_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        cs_hold_delay_res: u32,
        cs_hold_delay: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let cs_hold_delay_res: u32 = unsafe { ::core::mem::transmute(cs_hold_delay_res) };
            cs_hold_delay_res as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let cs_hold_delay: u32 = unsafe { ::core::mem::transmute(cs_hold_delay) };
            cs_hold_delay as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_3 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn wb_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wb_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn status_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_status_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status: u32,
        wb_mode: u32,
        status_ext: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let status: u32 = unsafe { ::core::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let wb_mode: u32 = unsafe { ::core::mem::transmute(wb_mode) };
            wb_mode as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let status_ext: u32 = unsafe { ::core::mem::transmute(status_ext) };
            status_ext as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_4 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn setup_time(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_setup_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn hold_time(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_hold_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_out_low_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ck_out_low_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_out_high_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ck_out_high_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn miso_delay_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_miso_delay_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn miso_delay_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_miso_delay_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mosi_delay_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mosi_delay_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mosi_delay_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mosi_delay_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_delay_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cs_delay_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_delay_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_cs_delay_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        setup_time: u32,
        hold_time: u32,
        ck_out_low_mode: u32,
        ck_out_high_mode: u32,
        miso_delay_mode: u32,
        miso_delay_num: u32,
        mosi_delay_mode: u32,
        mosi_delay_num: u32,
        cs_delay_mode: u32,
        cs_delay_num: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let setup_time: u32 = unsafe { ::core::mem::transmute(setup_time) };
            setup_time as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let hold_time: u32 = unsafe { ::core::mem::transmute(hold_time) };
            hold_time as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let ck_out_low_mode: u32 = unsafe { ::core::mem::transmute(ck_out_low_mode) };
            ck_out_low_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let ck_out_high_mode: u32 = unsafe { ::core::mem::transmute(ck_out_high_mode) };
            ck_out_high_mode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let miso_delay_mode: u32 = unsafe { ::core::mem::transmute(miso_delay_mode) };
            miso_delay_mode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let miso_delay_num: u32 = unsafe { ::core::mem::transmute(miso_delay_num) };
            miso_delay_num as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let mosi_delay_mode: u32 = unsafe { ::core::mem::transmute(mosi_delay_mode) };
            mosi_delay_mode as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let mosi_delay_num: u32 = unsafe { ::core::mem::transmute(mosi_delay_num) };
            mosi_delay_num as u64
        });
        __bindgen_bitfield_unit.set(26usize, 2u8, {
            let cs_delay_mode: u32 = unsafe { ::core::mem::transmute(cs_delay_mode) };
            cs_delay_mode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let cs_delay_num: u32 = unsafe { ::core::mem::transmute(cs_delay_num) };
            cs_delay_num as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_5 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn clkcnt_l(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_clkcnt_l(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn clkcnt_h(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_clkcnt_h(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn clkcnt_n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_clkcnt_n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn clkdiv_pre(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_clkdiv_pre(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_equ_sysclk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_equ_sysclk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clkcnt_l: u32,
        clkcnt_h: u32,
        clkcnt_n: u32,
        clkdiv_pre: u32,
        clk_equ_sysclk: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let clkcnt_l: u32 = unsafe { ::core::mem::transmute(clkcnt_l) };
            clkcnt_l as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let clkcnt_h: u32 = unsafe { ::core::mem::transmute(clkcnt_h) };
            clkcnt_h as u64
        });
        __bindgen_bitfield_unit.set(12usize, 6u8, {
            let clkcnt_n: u32 = unsafe { ::core::mem::transmute(clkcnt_n) };
            clkcnt_n as u64
        });
        __bindgen_bitfield_unit.set(18usize, 13u8, {
            let clkdiv_pre: u32 = unsafe { ::core::mem::transmute(clkdiv_pre) };
            clkdiv_pre as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let clk_equ_sysclk: u32 = unsafe { ::core::mem::transmute(clk_equ_sysclk) };
            clk_equ_sysclk as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_6 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn doutdin(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doutdin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_setup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs_setup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_i_edge(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck_i_edge(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_out_edge(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck_out_edge(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_byte_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_byte_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_byte_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_byte_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fwrite_dual(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fwrite_dual(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fwrite_quad(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fwrite_quad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fwrite_dio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fwrite_dio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fwrite_qio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fwrite_qio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_hold_pol(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_hold_pol(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_dout_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_dout_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_din_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_din_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_dummy_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_dummy_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_addr_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_addr_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_cmd_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_cmd_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_prep_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_prep_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_miso_highpart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_miso_highpart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_mosi_highpart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_mosi_highpart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_dummy_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_dummy_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_mosi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_mosi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_miso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_miso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_dummy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_dummy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_command(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_command(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doutdin: u32,
        reserved1: u32,
        cs_hold: u32,
        cs_setup: u32,
        ck_i_edge: u32,
        ck_out_edge: u32,
        reserved8: u32,
        rd_byte_order: u32,
        wr_byte_order: u32,
        fwrite_dual: u32,
        fwrite_quad: u32,
        fwrite_dio: u32,
        fwrite_qio: u32,
        sio: u32,
        usr_hold_pol: u32,
        usr_dout_hold: u32,
        usr_din_hold: u32,
        usr_dummy_hold: u32,
        usr_addr_hold: u32,
        usr_cmd_hold: u32,
        usr_prep_hold: u32,
        usr_miso_highpart: u32,
        usr_mosi_highpart: u32,
        usr_dummy_idle: u32,
        usr_mosi: u32,
        usr_miso: u32,
        usr_dummy: u32,
        usr_addr: u32,
        usr_command: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doutdin: u32 = unsafe { ::core::mem::transmute(doutdin) };
            doutdin as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cs_hold: u32 = unsafe { ::core::mem::transmute(cs_hold) };
            cs_hold as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cs_setup: u32 = unsafe { ::core::mem::transmute(cs_setup) };
            cs_setup as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ck_i_edge: u32 = unsafe { ::core::mem::transmute(ck_i_edge) };
            ck_i_edge as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ck_out_edge: u32 = unsafe { ::core::mem::transmute(ck_out_edge) };
            ck_out_edge as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rd_byte_order: u32 = unsafe { ::core::mem::transmute(rd_byte_order) };
            rd_byte_order as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wr_byte_order: u32 = unsafe { ::core::mem::transmute(wr_byte_order) };
            wr_byte_order as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fwrite_dual: u32 = unsafe { ::core::mem::transmute(fwrite_dual) };
            fwrite_dual as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fwrite_quad: u32 = unsafe { ::core::mem::transmute(fwrite_quad) };
            fwrite_quad as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fwrite_dio: u32 = unsafe { ::core::mem::transmute(fwrite_dio) };
            fwrite_dio as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let fwrite_qio: u32 = unsafe { ::core::mem::transmute(fwrite_qio) };
            fwrite_qio as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let sio: u32 = unsafe { ::core::mem::transmute(sio) };
            sio as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let usr_hold_pol: u32 = unsafe { ::core::mem::transmute(usr_hold_pol) };
            usr_hold_pol as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let usr_dout_hold: u32 = unsafe { ::core::mem::transmute(usr_dout_hold) };
            usr_dout_hold as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let usr_din_hold: u32 = unsafe { ::core::mem::transmute(usr_din_hold) };
            usr_din_hold as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let usr_dummy_hold: u32 = unsafe { ::core::mem::transmute(usr_dummy_hold) };
            usr_dummy_hold as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let usr_addr_hold: u32 = unsafe { ::core::mem::transmute(usr_addr_hold) };
            usr_addr_hold as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let usr_cmd_hold: u32 = unsafe { ::core::mem::transmute(usr_cmd_hold) };
            usr_cmd_hold as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let usr_prep_hold: u32 = unsafe { ::core::mem::transmute(usr_prep_hold) };
            usr_prep_hold as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let usr_miso_highpart: u32 = unsafe { ::core::mem::transmute(usr_miso_highpart) };
            usr_miso_highpart as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let usr_mosi_highpart: u32 = unsafe { ::core::mem::transmute(usr_mosi_highpart) };
            usr_mosi_highpart as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let usr_dummy_idle: u32 = unsafe { ::core::mem::transmute(usr_dummy_idle) };
            usr_dummy_idle as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let usr_mosi: u32 = unsafe { ::core::mem::transmute(usr_mosi) };
            usr_mosi as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let usr_miso: u32 = unsafe { ::core::mem::transmute(usr_miso) };
            usr_miso as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let usr_dummy: u32 = unsafe { ::core::mem::transmute(usr_dummy) };
            usr_dummy as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let usr_addr: u32 = unsafe { ::core::mem::transmute(usr_addr) };
            usr_addr as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let usr_command: u32 = unsafe { ::core::mem::transmute(usr_command) };
            usr_command as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_7 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn usr_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_usr_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_addr_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_usr_addr_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_dummy_cyclelen: u32,
        reserved8: u32,
        usr_addr_bitlen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let usr_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(usr_dummy_cyclelen) };
            usr_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit.set(8usize, 18u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let usr_addr_bitlen: u32 = unsafe { ::core::mem::transmute(usr_addr_bitlen) };
            usr_addr_bitlen as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_8 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn usr_command_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_usr_command_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_command_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_usr_command_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_command_value: u32,
        reserved16: u32,
        usr_command_bitlen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let usr_command_value: u32 = unsafe { ::core::mem::transmute(usr_command_value) };
            usr_command_value as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let usr_command_bitlen: u32 = unsafe { ::core::mem::transmute(usr_command_bitlen) };
            usr_command_bitlen as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_9 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_9 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn usr_mosi_dbitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_usr_mosi_dbitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_mosi_dbitlen: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let usr_mosi_dbitlen: u32 = unsafe { ::core::mem::transmute(usr_mosi_dbitlen) };
            usr_mosi_dbitlen as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_10 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_10 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn usr_miso_dbitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_usr_miso_dbitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_miso_dbitlen: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let usr_miso_dbitlen: u32 = unsafe { ::core::mem::transmute(usr_miso_dbitlen) };
            usr_miso_dbitlen as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_11 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_11 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn cs0_dis(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs0_dis(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs1_dis(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs1_dis(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs2_dis(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs2_dis(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_dis(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck_dis(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn master_cs_pol(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_master_cs_pol(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn master_ck_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_master_ck_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_idle_edge(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck_idle_edge(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_keep_active(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs_keep_active(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cs0_dis: u32,
        cs1_dis: u32,
        cs2_dis: u32,
        reserved3: u32,
        ck_dis: u32,
        master_cs_pol: u32,
        reserved9: u32,
        master_ck_sel: u32,
        reserved14: u32,
        ck_idle_edge: u32,
        cs_keep_active: u32,
        reserved31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cs0_dis: u32 = unsafe { ::core::mem::transmute(cs0_dis) };
            cs0_dis as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cs1_dis: u32 = unsafe { ::core::mem::transmute(cs1_dis) };
            cs1_dis as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cs2_dis: u32 = unsafe { ::core::mem::transmute(cs2_dis) };
            cs2_dis as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ck_dis: u32 = unsafe { ::core::mem::transmute(ck_dis) };
            ck_dis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let master_cs_pol: u32 = unsafe { ::core::mem::transmute(master_cs_pol) };
            master_cs_pol as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let master_ck_sel: u32 = unsafe { ::core::mem::transmute(master_ck_sel) };
            master_ck_sel as u64
        });
        __bindgen_bitfield_unit.set(14usize, 15u8, {
            let reserved14: u32 = unsafe { ::core::mem::transmute(reserved14) };
            reserved14 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ck_idle_edge: u32 = unsafe { ::core::mem::transmute(ck_idle_edge) };
            ck_idle_edge as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let cs_keep_active: u32 = unsafe { ::core::mem::transmute(cs_keep_active) };
            cs_keep_active as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved31: u32 = unsafe { ::core::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_12 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_12 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_12 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn rd_buf_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_buf_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_buf_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_buf_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_sta_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_sta_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_sta_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_sta_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trans_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trans_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_buf_inten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_buf_inten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_buf_inten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_buf_inten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_sta_inten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_sta_inten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_sta_inten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_sta_inten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trans_inten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trans_inten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_i_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cs_i_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn last_command(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_last_command(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn last_state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_last_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn trans_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_trans_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd_define(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_define(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_rd_sta_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_rd_sta_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_rd_buf_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_rd_buf_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slave_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slave_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sync_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sync_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rd_buf_done: u32,
        wr_buf_done: u32,
        rd_sta_done: u32,
        wr_sta_done: u32,
        trans_done: u32,
        rd_buf_inten: u32,
        wr_buf_inten: u32,
        rd_sta_inten: u32,
        wr_sta_inten: u32,
        trans_inten: u32,
        cs_i_mode: u32,
        reserved12: u32,
        last_command: u32,
        last_state: u32,
        trans_cnt: u32,
        cmd_define: u32,
        wr_rd_sta_en: u32,
        wr_rd_buf_en: u32,
        slave_mode: u32,
        sync_reset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rd_buf_done: u32 = unsafe { ::core::mem::transmute(rd_buf_done) };
            rd_buf_done as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wr_buf_done: u32 = unsafe { ::core::mem::transmute(wr_buf_done) };
            wr_buf_done as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rd_sta_done: u32 = unsafe { ::core::mem::transmute(rd_sta_done) };
            rd_sta_done as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wr_sta_done: u32 = unsafe { ::core::mem::transmute(wr_sta_done) };
            wr_sta_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let trans_done: u32 = unsafe { ::core::mem::transmute(trans_done) };
            trans_done as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rd_buf_inten: u32 = unsafe { ::core::mem::transmute(rd_buf_inten) };
            rd_buf_inten as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let wr_buf_inten: u32 = unsafe { ::core::mem::transmute(wr_buf_inten) };
            wr_buf_inten as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rd_sta_inten: u32 = unsafe { ::core::mem::transmute(rd_sta_inten) };
            rd_sta_inten as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let wr_sta_inten: u32 = unsafe { ::core::mem::transmute(wr_sta_inten) };
            wr_sta_inten as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let trans_inten: u32 = unsafe { ::core::mem::transmute(trans_inten) };
            trans_inten as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let cs_i_mode: u32 = unsafe { ::core::mem::transmute(cs_i_mode) };
            cs_i_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 3u8, {
            let last_command: u32 = unsafe { ::core::mem::transmute(last_command) };
            last_command as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let last_state: u32 = unsafe { ::core::mem::transmute(last_state) };
            last_state as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let trans_cnt: u32 = unsafe { ::core::mem::transmute(trans_cnt) };
            trans_cnt as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let cmd_define: u32 = unsafe { ::core::mem::transmute(cmd_define) };
            cmd_define as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let wr_rd_sta_en: u32 = unsafe { ::core::mem::transmute(wr_rd_sta_en) };
            wr_rd_sta_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let wr_rd_buf_en: u32 = unsafe { ::core::mem::transmute(wr_rd_buf_en) };
            wr_rd_buf_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let slave_mode: u32 = unsafe { ::core::mem::transmute(slave_mode) };
            slave_mode as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sync_reset: u32 = unsafe { ::core::mem::transmute(sync_reset) };
            sync_reset as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_13 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_13 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_13 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn rdbuf_dummy_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdbuf_dummy_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wrbuf_dummy_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wrbuf_dummy_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdsta_dummy_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdsta_dummy_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wrsta_dummy_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wrsta_dummy_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_addr_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_wr_addr_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_addr_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_rd_addr_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn status_readback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_status_readback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn status_fast_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_status_fast_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn status_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_status_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rdbuf_dummy_en: u32,
        wrbuf_dummy_en: u32,
        rdsta_dummy_en: u32,
        wrsta_dummy_en: u32,
        wr_addr_bitlen: u32,
        rd_addr_bitlen: u32,
        reserved16: u32,
        status_readback: u32,
        status_fast_en: u32,
        status_bitlen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rdbuf_dummy_en: u32 = unsafe { ::core::mem::transmute(rdbuf_dummy_en) };
            rdbuf_dummy_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wrbuf_dummy_en: u32 = unsafe { ::core::mem::transmute(wrbuf_dummy_en) };
            wrbuf_dummy_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rdsta_dummy_en: u32 = unsafe { ::core::mem::transmute(rdsta_dummy_en) };
            rdsta_dummy_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wrsta_dummy_en: u32 = unsafe { ::core::mem::transmute(wrsta_dummy_en) };
            wrsta_dummy_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 6u8, {
            let wr_addr_bitlen: u32 = unsafe { ::core::mem::transmute(wr_addr_bitlen) };
            wr_addr_bitlen as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let rd_addr_bitlen: u32 = unsafe { ::core::mem::transmute(rd_addr_bitlen) };
            rd_addr_bitlen as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let status_readback: u32 = unsafe { ::core::mem::transmute(status_readback) };
            status_readback as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let status_fast_en: u32 = unsafe { ::core::mem::transmute(status_fast_en) };
            status_fast_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let status_bitlen: u32 = unsafe { ::core::mem::transmute(status_bitlen) };
            status_bitlen as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_14 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_14 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_14 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn rdsta_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rdsta_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn wrsta_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wrsta_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rdbuf_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rdbuf_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn wrbuf_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wrbuf_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rdsta_dummy_cyclelen: u32,
        wrsta_dummy_cyclelen: u32,
        rdbuf_dummy_cyclelen: u32,
        wrbuf_dummy_cyclelen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rdsta_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(rdsta_dummy_cyclelen) };
            rdsta_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let wrsta_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(wrsta_dummy_cyclelen) };
            wrsta_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let rdbuf_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(rdbuf_dummy_cyclelen) };
            rdbuf_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let wrbuf_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(wrbuf_dummy_cyclelen) };
            wrbuf_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_15 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_15 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_15 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn rdbuf_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rdbuf_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn wrbuf_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wrbuf_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rdsta_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rdsta_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn wrsta_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wrsta_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rdbuf_cmd_value: u32,
        wrbuf_cmd_value: u32,
        rdsta_cmd_value: u32,
        wrsta_cmd_value: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rdbuf_cmd_value: u32 = unsafe { ::core::mem::transmute(rdbuf_cmd_value) };
            rdbuf_cmd_value as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let wrbuf_cmd_value: u32 = unsafe { ::core::mem::transmute(wrbuf_cmd_value) };
            wrbuf_cmd_value as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let rdsta_cmd_value: u32 = unsafe { ::core::mem::transmute(rdsta_cmd_value) };
            rdsta_cmd_value as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let wrsta_cmd_value: u32 = unsafe { ::core::mem::transmute(wrsta_cmd_value) };
            wrsta_cmd_value as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_16 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_16 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn bit_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_bit_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bit_len: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let bit_len: u32 = unsafe { ::core::mem::transmute(bit_len) };
            bit_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_17 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_17 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_17 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn bit_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_bit_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bit_len: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let bit_len: u32 = unsafe { ::core::mem::transmute(bit_len) };
            bit_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_18 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_18 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_18 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn req_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_req_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_cmd_4byte(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_cmd_4byte(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_usr_cmd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_usr_cmd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_pes_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_pes_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        req_en: u32,
        usr_cmd_4byte: u32,
        flash_usr_cmd: u32,
        flash_pes_en: u32,
        reserved4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let req_en: u32 = unsafe { ::core::mem::transmute(req_en) };
            req_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let usr_cmd_4byte: u32 = unsafe { ::core::mem::transmute(usr_cmd_4byte) };
            usr_cmd_4byte as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let flash_usr_cmd: u32 = unsafe { ::core::mem::transmute(flash_usr_cmd) };
            flash_usr_cmd as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flash_pes_en: u32 = unsafe { ::core::mem::transmute(flash_pes_en) };
            flash_pes_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_19 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_19 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_19 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_sram_dio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_sram_dio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_sram_qio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_sram_qio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_wr_sram_dummy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_wr_sram_dummy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_rd_sram_dummy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_rd_sram_dummy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cache_sram_usr_rcmd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cache_sram_usr_rcmd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sram_bytes_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sram_bytes_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sram_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sram_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sram_addr_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_sram_addr_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn cache_sram_usr_wcmd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cache_sram_usr_wcmd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved29(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved29(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        usr_sram_dio: u32,
        usr_sram_qio: u32,
        usr_wr_sram_dummy: u32,
        usr_rd_sram_dummy: u32,
        cache_sram_usr_rcmd: u32,
        sram_bytes_len: u32,
        sram_dummy_cyclelen: u32,
        sram_addr_bitlen: u32,
        cache_sram_usr_wcmd: u32,
        reserved29: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let usr_sram_dio: u32 = unsafe { ::core::mem::transmute(usr_sram_dio) };
            usr_sram_dio as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let usr_sram_qio: u32 = unsafe { ::core::mem::transmute(usr_sram_qio) };
            usr_sram_qio as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let usr_wr_sram_dummy: u32 = unsafe { ::core::mem::transmute(usr_wr_sram_dummy) };
            usr_wr_sram_dummy as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let usr_rd_sram_dummy: u32 = unsafe { ::core::mem::transmute(usr_rd_sram_dummy) };
            usr_rd_sram_dummy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cache_sram_usr_rcmd: u32 = unsafe { ::core::mem::transmute(cache_sram_usr_rcmd) };
            cache_sram_usr_rcmd as u64
        });
        __bindgen_bitfield_unit.set(6usize, 8u8, {
            let sram_bytes_len: u32 = unsafe { ::core::mem::transmute(sram_bytes_len) };
            sram_bytes_len as u64
        });
        __bindgen_bitfield_unit.set(14usize, 8u8, {
            let sram_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(sram_dummy_cyclelen) };
            sram_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit.set(22usize, 6u8, {
            let sram_addr_bitlen: u32 = unsafe { ::core::mem::transmute(sram_addr_bitlen) };
            sram_addr_bitlen as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let cache_sram_usr_wcmd: u32 = unsafe { ::core::mem::transmute(cache_sram_usr_wcmd) };
            cache_sram_usr_wcmd as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let reserved29: u32 = unsafe { ::core::mem::transmute(reserved29) };
            reserved29 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_20 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_20 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_20 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn dio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_qio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_io(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_io(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dio: u32,
        qio: u32,
        reserved2: u32,
        rst_io: u32,
        reserved5: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dio: u32 = unsafe { ::core::mem::transmute(dio) };
            dio as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let qio: u32 = unsafe { ::core::mem::transmute(qio) };
            qio as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rst_io: u32 = unsafe { ::core::mem::transmute(rst_io) };
            rst_io as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved5: u32 = unsafe { ::core::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_21 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_21 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_21 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn usr_rd_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_usr_rd_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_rd_cmd_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_usr_rd_cmd_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_rd_cmd_value: u32,
        reserved16: u32,
        usr_rd_cmd_bitlen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let usr_rd_cmd_value: u32 = unsafe { ::core::mem::transmute(usr_rd_cmd_value) };
            usr_rd_cmd_value as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let usr_rd_cmd_bitlen: u32 = unsafe { ::core::mem::transmute(usr_rd_cmd_bitlen) };
            usr_rd_cmd_bitlen as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_22 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_22 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_22 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn usr_wr_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_usr_wr_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_wr_cmd_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_usr_wr_cmd_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_wr_cmd_value: u32,
        reserved16: u32,
        usr_wr_cmd_bitlen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let usr_wr_cmd_value: u32 = unsafe { ::core::mem::transmute(usr_wr_cmd_value) };
            usr_wr_cmd_value as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let usr_wr_cmd_bitlen: u32 = unsafe { ::core::mem::transmute(usr_wr_cmd_bitlen) };
            usr_wr_cmd_bitlen as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_23 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_23 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_23 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_24 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn slv_rdata_bit(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_slv_rdata_bit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slv_rdata_bit: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let slv_rdata_bit: u32 = unsafe { ::core::mem::transmute(slv_rdata_bit) };
            slv_rdata_bit as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_24 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_24 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_24 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_25 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_25__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_25__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_25__bindgen_ty_1 {
    #[inline]
    pub fn t_pp_time(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_t_pp_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn t_pp_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_t_pp_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn t_pp_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t_pp_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        t_pp_time: u32,
        reserved12: u32,
        t_pp_shift: u32,
        reserved20: u32,
        t_pp_ena: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let t_pp_time: u32 = unsafe { ::core::mem::transmute(t_pp_time) };
            t_pp_time as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let t_pp_shift: u32 = unsafe { ::core::mem::transmute(t_pp_shift) };
            t_pp_shift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 11u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let t_pp_ena: u32 = unsafe { ::core::mem::transmute(t_pp_ena) };
            t_pp_ena as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_25 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_25 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_25 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_26 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_26__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_26__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_26__bindgen_ty_1 {
    #[inline]
    pub fn t_erase_time(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_t_erase_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn t_erase_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_t_erase_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn t_erase_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t_erase_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        t_erase_time: u32,
        reserved12: u32,
        t_erase_shift: u32,
        reserved20: u32,
        t_erase_ena: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let t_erase_time: u32 = unsafe { ::core::mem::transmute(t_erase_time) };
            t_erase_time as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let t_erase_shift: u32 = unsafe { ::core::mem::transmute(t_erase_shift) };
            t_erase_shift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 11u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let t_erase_ena: u32 = unsafe { ::core::mem::transmute(t_erase_ena) };
            t_erase_ena as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_26 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_26 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_26 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_27 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_27__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_27__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_27__bindgen_ty_1 {
    #[inline]
    pub fn st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(st: u32, reserved3: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let st: u32 = unsafe { ::core::mem::transmute(st) };
            st as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_27 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_27 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_27 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_28 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_28__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_28__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_28__bindgen_ty_1 {
    #[inline]
    pub fn int_hold_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_int_hold_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        int_hold_ena: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let int_hold_ena: u32 = unsafe { ::core::mem::transmute(int_hold_ena) };
            int_hold_ena as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_28 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_28 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_28 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_29 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_29__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn in_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ahbm_fifo_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ahbm_fifo_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ahbm_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ahbm_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_auto_wrback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_auto_wrback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outdscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outdscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn indscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_indscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_data_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_data_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dma_rx_stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dma_rx_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dma_tx_stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dma_tx_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dma_continue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dma_continue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        in_rst: u32,
        out_rst: u32,
        ahbm_fifo_rst: u32,
        ahbm_rst: u32,
        in_loop_test: u32,
        out_loop_test: u32,
        out_auto_wrback: u32,
        out_eof_mode: u32,
        outdscr_burst_en: u32,
        indscr_burst_en: u32,
        out_data_burst_en: u32,
        reserved13: u32,
        dma_rx_stop: u32,
        dma_tx_stop: u32,
        dma_continue: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_rst: u32 = unsafe { ::core::mem::transmute(in_rst) };
            in_rst as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let out_rst: u32 = unsafe { ::core::mem::transmute(out_rst) };
            out_rst as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ahbm_fifo_rst: u32 = unsafe { ::core::mem::transmute(ahbm_fifo_rst) };
            ahbm_fifo_rst as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ahbm_rst: u32 = unsafe { ::core::mem::transmute(ahbm_rst) };
            ahbm_rst as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let in_loop_test: u32 = unsafe { ::core::mem::transmute(in_loop_test) };
            in_loop_test as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_loop_test: u32 = unsafe { ::core::mem::transmute(out_loop_test) };
            out_loop_test as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_auto_wrback: u32 = unsafe { ::core::mem::transmute(out_auto_wrback) };
            out_auto_wrback as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let out_eof_mode: u32 = unsafe { ::core::mem::transmute(out_eof_mode) };
            out_eof_mode as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let outdscr_burst_en: u32 = unsafe { ::core::mem::transmute(outdscr_burst_en) };
            outdscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let indscr_burst_en: u32 = unsafe { ::core::mem::transmute(indscr_burst_en) };
            indscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let out_data_burst_en: u32 = unsafe { ::core::mem::transmute(out_data_burst_en) };
            out_data_burst_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved13: u32 = unsafe { ::core::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let dma_rx_stop: u32 = unsafe { ::core::mem::transmute(dma_rx_stop) };
            dma_rx_stop as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let dma_tx_stop: u32 = unsafe { ::core::mem::transmute(dma_tx_stop) };
            dma_tx_stop as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let dma_continue: u32 = unsafe { ::core::mem::transmute(dma_continue) };
            dma_continue as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_29 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_29 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_29 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_30 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_30__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_30__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_30__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        reserved20: u32,
        stop: u32,
        start: u32,
        restart: u32,
        reserved31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved31: u32 = unsafe { ::core::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_30 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_30 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_30 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_31 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_31__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_31__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_31__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_ret(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_ret(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        auto_ret: u32,
        reserved21: u32,
        stop: u32,
        start: u32,
        restart: u32,
        reserved31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let auto_ret: u32 = unsafe { ::core::mem::transmute(auto_ret) };
            auto_ret as u64
        });
        __bindgen_bitfield_unit.set(21usize, 7u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved31: u32 = unsafe { ::core::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_31 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_31 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_31 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_32 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_32__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_32__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_32__bindgen_ty_1 {
    #[inline]
    pub fn rx_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_en: u32,
        tx_en: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rx_en: u32 = unsafe { ::core::mem::transmute(rx_en) };
            rx_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tx_en: u32 = unsafe { ::core::mem::transmute(tx_en) };
            tx_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_32 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_32 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_33 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_33__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_33__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_33__bindgen_ty_1 {
    #[inline]
    pub fn inlink_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inlink_dscr_empty: u32,
        outlink_dscr_error: u32,
        inlink_dscr_error: u32,
        in_done: u32,
        in_err_eof: u32,
        in_suc_eof: u32,
        out_done: u32,
        out_eof: u32,
        out_total_eof: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inlink_dscr_empty: u32 = unsafe { ::core::mem::transmute(inlink_dscr_empty) };
            inlink_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let outlink_dscr_error: u32 = unsafe { ::core::mem::transmute(outlink_dscr_error) };
            outlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let inlink_dscr_error: u32 = unsafe { ::core::mem::transmute(inlink_dscr_error) };
            inlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_33 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_33 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_33 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_34 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_34__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_34__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_34__bindgen_ty_1 {
    #[inline]
    pub fn inlink_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inlink_dscr_empty: u32,
        outlink_dscr_error: u32,
        inlink_dscr_error: u32,
        in_done: u32,
        in_err_eof: u32,
        in_suc_eof: u32,
        out_done: u32,
        out_eof: u32,
        out_total_eof: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inlink_dscr_empty: u32 = unsafe { ::core::mem::transmute(inlink_dscr_empty) };
            inlink_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let outlink_dscr_error: u32 = unsafe { ::core::mem::transmute(outlink_dscr_error) };
            outlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let inlink_dscr_error: u32 = unsafe { ::core::mem::transmute(inlink_dscr_error) };
            inlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_34 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_34 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_34 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_35 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_35__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_35__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_35__bindgen_ty_1 {
    #[inline]
    pub fn inlink_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inlink_dscr_empty: u32,
        outlink_dscr_error: u32,
        inlink_dscr_error: u32,
        in_done: u32,
        in_err_eof: u32,
        in_suc_eof: u32,
        out_done: u32,
        out_eof: u32,
        out_total_eof: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inlink_dscr_empty: u32 = unsafe { ::core::mem::transmute(inlink_dscr_empty) };
            inlink_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let outlink_dscr_error: u32 = unsafe { ::core::mem::transmute(outlink_dscr_error) };
            outlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let inlink_dscr_error: u32 = unsafe { ::core::mem::transmute(inlink_dscr_error) };
            inlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_35 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_35 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_35 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_36 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_36__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_36__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_36__bindgen_ty_1 {
    #[inline]
    pub fn inlink_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inlink_dscr_empty: u32,
        outlink_dscr_error: u32,
        inlink_dscr_error: u32,
        in_done: u32,
        in_err_eof: u32,
        in_suc_eof: u32,
        out_done: u32,
        out_eof: u32,
        out_total_eof: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inlink_dscr_empty: u32 = unsafe { ::core::mem::transmute(inlink_dscr_empty) };
            inlink_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let outlink_dscr_error: u32 = unsafe { ::core::mem::transmute(outlink_dscr_error) };
            outlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let inlink_dscr_error: u32 = unsafe { ::core::mem::transmute(inlink_dscr_error) };
            inlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_36 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_36 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_36 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_37 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_37__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_dev_s__bindgen_ty_37__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_37__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved28: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for spi_dev_s__bindgen_ty_37 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s__bindgen_ty_37 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_dev_s__bindgen_ty_37 {{ union }}")
    }
}
impl Default for spi_dev_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_dev_s {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "spi_dev_s {{ cmd: {:?}, addr: {:?}, ctrl: {:?}, ctrl1: {:?}, rd_status: {:?}, ctrl2: {:?}, clock: {:?}, user: {:?}, user1: {:?}, user2: {:?}, mosi_dlen: {:?}, miso_dlen: {:?}, slv_wr_status: {:?}, pin: {:?}, slave: {:?}, slave1: {:?}, slave2: {:?}, slave3: {:?}, slv_wrbuf_dlen: {:?}, slv_rdbuf_dlen: {:?}, cache_fctrl: {:?}, cache_sctrl: {:?}, sram_cmd: {:?}, sram_drd_cmd: {:?}, sram_dwr_cmd: {:?}, slv_rd_bit: {:?}, reserved_68: {:?}, reserved_6c: {:?}, reserved_70: {:?}, reserved_74: {:?}, reserved_78: {:?}, reserved_7c: {:?}, data_buf: {:?}, tx_crc: {:?}, reserved_c4: {:?}, reserved_c8: {:?}, reserved_cc: {:?}, reserved_d0: {:?}, reserved_d4: {:?}, reserved_d8: {:?}, reserved_dc: {:?}, reserved_e0: {:?}, reserved_e4: {:?}, reserved_e8: {:?}, reserved_ec: {:?}, ext0: {:?}, ext1: {:?}, ext2: {:?}, ext3: {:?}, dma_conf: {:?}, dma_out_link: {:?}, dma_in_link: {:?}, dma_status: {:?}, dma_int_ena: {:?}, dma_int_raw: {:?}, dma_int_st: {:?}, dma_int_clr: {:?}, dma_in_err_eof_des_addr: {:?}, dma_in_suc_eof_des_addr: {:?}, dma_inlink_dscr: {:?}, dma_inlink_dscr_bf0: {:?}, dma_inlink_dscr_bf1: {:?}, dma_out_eof_bfr_des_addr: {:?}, dma_out_eof_des_addr: {:?}, dma_outlink_dscr: {:?}, dma_outlink_dscr_bf0: {:?}, dma_outlink_dscr_bf1: {:?}, dma_rx_status: {:?}, dma_tx_status: {:?}, reserved_150: {:?}, reserved_154: {:?}, reserved_158: {:?}, reserved_15c: {:?}, reserved_160: {:?}, reserved_164: {:?}, reserved_168: {:?}, reserved_16c: {:?}, reserved_170: {:?}, reserved_174: {:?}, reserved_178: {:?}, reserved_17c: {:?}, reserved_180: {:?}, reserved_184: {:?}, reserved_188: {:?}, reserved_18c: {:?}, reserved_190: {:?}, reserved_194: {:?}, reserved_198: {:?}, reserved_19c: {:?}, reserved_1a0: {:?}, reserved_1a4: {:?}, reserved_1a8: {:?}, reserved_1ac: {:?}, reserved_1b0: {:?}, reserved_1b4: {:?}, reserved_1b8: {:?}, reserved_1bc: {:?}, reserved_1c0: {:?}, reserved_1c4: {:?}, reserved_1c8: {:?}, reserved_1cc: {:?}, reserved_1d0: {:?}, reserved_1d4: {:?}, reserved_1d8: {:?}, reserved_1dc: {:?}, reserved_1e0: {:?}, reserved_1e4: {:?}, reserved_1e8: {:?}, reserved_1ec: {:?}, reserved_1f0: {:?}, reserved_1f4: {:?}, reserved_1f8: {:?}, reserved_1fc: {:?}, reserved_200: {:?}, reserved_204: {:?}, reserved_208: {:?}, reserved_20c: {:?}, reserved_210: {:?}, reserved_214: {:?}, reserved_218: {:?}, reserved_21c: {:?}, reserved_220: {:?}, reserved_224: {:?}, reserved_228: {:?}, reserved_22c: {:?}, reserved_230: {:?}, reserved_234: {:?}, reserved_238: {:?}, reserved_23c: {:?}, reserved_240: {:?}, reserved_244: {:?}, reserved_248: {:?}, reserved_24c: {:?}, reserved_250: {:?}, reserved_254: {:?}, reserved_258: {:?}, reserved_25c: {:?}, reserved_260: {:?}, reserved_264: {:?}, reserved_268: {:?}, reserved_26c: {:?}, reserved_270: {:?}, reserved_274: {:?}, reserved_278: {:?}, reserved_27c: {:?}, reserved_280: {:?}, reserved_284: {:?}, reserved_288: {:?}, reserved_28c: {:?}, reserved_290: {:?}, reserved_294: {:?}, reserved_298: {:?}, reserved_29c: {:?}, reserved_2a0: {:?}, reserved_2a4: {:?}, reserved_2a8: {:?}, reserved_2ac: {:?}, reserved_2b0: {:?}, reserved_2b4: {:?}, reserved_2b8: {:?}, reserved_2bc: {:?}, reserved_2c0: {:?}, reserved_2c4: {:?}, reserved_2c8: {:?}, reserved_2cc: {:?}, reserved_2d0: {:?}, reserved_2d4: {:?}, reserved_2d8: {:?}, reserved_2dc: {:?}, reserved_2e0: {:?}, reserved_2e4: {:?}, reserved_2e8: {:?}, reserved_2ec: {:?}, reserved_2f0: {:?}, reserved_2f4: {:?}, reserved_2f8: {:?}, reserved_2fc: {:?}, reserved_300: {:?}, reserved_304: {:?}, reserved_308: {:?}, reserved_30c: {:?}, reserved_310: {:?}, reserved_314: {:?}, reserved_318: {:?}, reserved_31c: {:?}, reserved_320: {:?}, reserved_324: {:?}, reserved_328: {:?}, reserved_32c: {:?}, reserved_330: {:?}, reserved_334: {:?}, reserved_338: {:?}, reserved_33c: {:?}, reserved_340: {:?}, reserved_344: {:?}, reserved_348: {:?}, reserved_34c: {:?}, reserved_350: {:?}, reserved_354: {:?}, reserved_358: {:?}, reserved_35c: {:?}, reserved_360: {:?}, reserved_364: {:?}, reserved_368: {:?}, reserved_36c: {:?}, reserved_370: {:?}, reserved_374: {:?}, reserved_378: {:?}, reserved_37c: {:?}, reserved_380: {:?}, reserved_384: {:?}, reserved_388: {:?}, reserved_38c: {:?}, reserved_390: {:?}, reserved_394: {:?}, reserved_398: {:?}, reserved_39c: {:?}, reserved_3a0: {:?}, reserved_3a4: {:?}, reserved_3a8: {:?}, reserved_3ac: {:?}, reserved_3b0: {:?}, reserved_3b4: {:?}, reserved_3b8: {:?}, reserved_3bc: {:?}, reserved_3c0: {:?}, reserved_3c4: {:?}, reserved_3c8: {:?}, reserved_3cc: {:?}, reserved_3d0: {:?}, reserved_3d4: {:?}, reserved_3d8: {:?}, reserved_3dc: {:?}, reserved_3e0: {:?}, reserved_3e4: {:?}, reserved_3e8: {:?}, reserved_3ec: {:?}, reserved_3f0: {:?}, reserved_3f4: {:?}, reserved_3f8: {:?}, date: {:?} }}" , self . cmd , self . addr , self . ctrl , self . ctrl1 , self . rd_status , self . ctrl2 , self . clock , self . user , self . user1 , self . user2 , self . mosi_dlen , self . miso_dlen , self . slv_wr_status , self . pin , self . slave , self . slave1 , self . slave2 , self . slave3 , self . slv_wrbuf_dlen , self . slv_rdbuf_dlen , self . cache_fctrl , self . cache_sctrl , self . sram_cmd , self . sram_drd_cmd , self . sram_dwr_cmd , self . slv_rd_bit , self . reserved_68 , self . reserved_6c , self . reserved_70 , self . reserved_74 , self . reserved_78 , self . reserved_7c , self . data_buf , self . tx_crc , self . reserved_c4 , self . reserved_c8 , self . reserved_cc , self . reserved_d0 , self . reserved_d4 , self . reserved_d8 , self . reserved_dc , self . reserved_e0 , self . reserved_e4 , self . reserved_e8 , self . reserved_ec , self . ext0 , self . ext1 , self . ext2 , self . ext3 , self . dma_conf , self . dma_out_link , self . dma_in_link , self . dma_status , self . dma_int_ena , self . dma_int_raw , self . dma_int_st , self . dma_int_clr , self . dma_in_err_eof_des_addr , self . dma_in_suc_eof_des_addr , self . dma_inlink_dscr , self . dma_inlink_dscr_bf0 , self . dma_inlink_dscr_bf1 , self . dma_out_eof_bfr_des_addr , self . dma_out_eof_des_addr , self . dma_outlink_dscr , self . dma_outlink_dscr_bf0 , self . dma_outlink_dscr_bf1 , self . dma_rx_status , self . dma_tx_status , self . reserved_150 , self . reserved_154 , self . reserved_158 , self . reserved_15c , self . reserved_160 , self . reserved_164 , self . reserved_168 , self . reserved_16c , self . reserved_170 , self . reserved_174 , self . reserved_178 , self . reserved_17c , self . reserved_180 , self . reserved_184 , self . reserved_188 , self . reserved_18c , self . reserved_190 , self . reserved_194 , self . reserved_198 , self . reserved_19c , self . reserved_1a0 , self . reserved_1a4 , self . reserved_1a8 , self . reserved_1ac , self . reserved_1b0 , self . reserved_1b4 , self . reserved_1b8 , self . reserved_1bc , self . reserved_1c0 , self . reserved_1c4 , self . reserved_1c8 , self . reserved_1cc , self . reserved_1d0 , self . reserved_1d4 , self . reserved_1d8 , self . reserved_1dc , self . reserved_1e0 , self . reserved_1e4 , self . reserved_1e8 , self . reserved_1ec , self . reserved_1f0 , self . reserved_1f4 , self . reserved_1f8 , self . reserved_1fc , self . reserved_200 , self . reserved_204 , self . reserved_208 , self . reserved_20c , self . reserved_210 , self . reserved_214 , self . reserved_218 , self . reserved_21c , self . reserved_220 , self . reserved_224 , self . reserved_228 , self . reserved_22c , self . reserved_230 , self . reserved_234 , self . reserved_238 , self . reserved_23c , self . reserved_240 , self . reserved_244 , self . reserved_248 , self . reserved_24c , self . reserved_250 , self . reserved_254 , self . reserved_258 , self . reserved_25c , self . reserved_260 , self . reserved_264 , self . reserved_268 , self . reserved_26c , self . reserved_270 , self . reserved_274 , self . reserved_278 , self . reserved_27c , self . reserved_280 , self . reserved_284 , self . reserved_288 , self . reserved_28c , self . reserved_290 , self . reserved_294 , self . reserved_298 , self . reserved_29c , self . reserved_2a0 , self . reserved_2a4 , self . reserved_2a8 , self . reserved_2ac , self . reserved_2b0 , self . reserved_2b4 , self . reserved_2b8 , self . reserved_2bc , self . reserved_2c0 , self . reserved_2c4 , self . reserved_2c8 , self . reserved_2cc , self . reserved_2d0 , self . reserved_2d4 , self . reserved_2d8 , self . reserved_2dc , self . reserved_2e0 , self . reserved_2e4 , self . reserved_2e8 , self . reserved_2ec , self . reserved_2f0 , self . reserved_2f4 , self . reserved_2f8 , self . reserved_2fc , self . reserved_300 , self . reserved_304 , self . reserved_308 , self . reserved_30c , self . reserved_310 , self . reserved_314 , self . reserved_318 , self . reserved_31c , self . reserved_320 , self . reserved_324 , self . reserved_328 , self . reserved_32c , self . reserved_330 , self . reserved_334 , self . reserved_338 , self . reserved_33c , self . reserved_340 , self . reserved_344 , self . reserved_348 , self . reserved_34c , self . reserved_350 , self . reserved_354 , self . reserved_358 , self . reserved_35c , self . reserved_360 , self . reserved_364 , self . reserved_368 , self . reserved_36c , self . reserved_370 , self . reserved_374 , self . reserved_378 , self . reserved_37c , self . reserved_380 , self . reserved_384 , self . reserved_388 , self . reserved_38c , self . reserved_390 , self . reserved_394 , self . reserved_398 , self . reserved_39c , self . reserved_3a0 , self . reserved_3a4 , self . reserved_3a8 , self . reserved_3ac , self . reserved_3b0 , self . reserved_3b4 , self . reserved_3b8 , self . reserved_3bc , self . reserved_3c0 , self . reserved_3c4 , self . reserved_3c8 , self . reserved_3cc , self . reserved_3d0 , self . reserved_3d4 , self . reserved_3d8 , self . reserved_3dc , self . reserved_3e0 , self . reserved_3e4 , self . reserved_3e8 , self . reserved_3ec , self . reserved_3f0 , self . reserved_3f4 , self . reserved_3f8 , self . date )
    }
}
pub type spi_dev_t = spi_dev_s;
extern "C" {
    pub static mut SPI0: spi_dev_t;
}
extern "C" {
    pub static mut SPI1: spi_dev_t;
}
extern "C" {
    pub static mut SPI2: spi_dev_t;
}
extern "C" {
    pub static mut SPI3: spi_dev_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spi_signal_conn_t {
    pub spiclk_out: u8,
    pub spiclk_in: u8,
    pub spid_out: u8,
    pub spiq_out: u8,
    pub spiwp_out: u8,
    pub spihd_out: u8,
    pub spid_in: u8,
    pub spiq_in: u8,
    pub spiwp_in: u8,
    pub spihd_in: u8,
    pub spics_out: [u8; 3usize],
    pub spics_in: u8,
    pub spiclk_iomux_pin: u8,
    pub spid_iomux_pin: u8,
    pub spiq_iomux_pin: u8,
    pub spiwp_iomux_pin: u8,
    pub spihd_iomux_pin: u8,
    pub spics0_iomux_pin: u8,
    pub irq: u8,
    pub irq_dma: u8,
    pub module: periph_module_t,
    pub func: std::os::raw::c_int,
    pub hw: *mut spi_dev_t,
}
impl Default for spi_signal_conn_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static spi_periph_signal: [spi_signal_conn_t; 3usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum spi_host_device_t {
    SPI1_HOST = 0,
    SPI2_HOST = 1,
    SPI3_HOST = 2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_bus_config_t {
    pub mosi_io_num: std::os::raw::c_int,
    pub miso_io_num: std::os::raw::c_int,
    pub sclk_io_num: std::os::raw::c_int,
    pub quadwp_io_num: std::os::raw::c_int,
    pub quadhd_io_num: std::os::raw::c_int,
    pub max_transfer_sz: std::os::raw::c_int,
    pub flags: u32,
    pub intr_flags: std::os::raw::c_int,
}
extern "C" {
    pub fn spi_bus_initialize(
        host: spi_host_device_t,
        bus_config: *const spi_bus_config_t,
        dma_chan: std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_bus_free(host: spi_host_device_t) -> esp_err_t;
}
pub type transaction_cb_t =
    ::core::option::Option<unsafe extern "C" fn(trans: *mut spi_transaction_t)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct spi_device_interface_config_t {
    pub command_bits: u8,
    pub address_bits: u8,
    pub dummy_bits: u8,
    pub mode: u8,
    pub duty_cycle_pos: u8,
    pub cs_ena_pretrans: u8,
    pub cs_ena_posttrans: u8,
    pub clock_speed_hz: std::os::raw::c_int,
    pub input_delay_ns: std::os::raw::c_int,
    pub spics_io_num: std::os::raw::c_int,
    pub flags: u32,
    pub queue_size: std::os::raw::c_int,
    pub pre_cb: transaction_cb_t,
    pub post_cb: transaction_cb_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spi_transaction_t {
    pub flags: u32,
    pub cmd: u16,
    pub addr: u64,
    pub length: usize,
    pub rxlength: usize,
    pub user: *mut std::os::raw::c_void,
    pub __bindgen_anon_1: spi_transaction_t__bindgen_ty_1,
    pub __bindgen_anon_2: spi_transaction_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_transaction_t__bindgen_ty_1 {
    pub tx_buffer: *const std::os::raw::c_void,
    pub tx_data: [u8; 4usize],
    _bindgen_union_align: u32,
}
impl Default for spi_transaction_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_transaction_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_transaction_t__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_transaction_t__bindgen_ty_2 {
    pub rx_buffer: *mut std::os::raw::c_void,
    pub rx_data: [u8; 4usize],
    _bindgen_union_align: u32,
}
impl Default for spi_transaction_t__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_transaction_t__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "spi_transaction_t__bindgen_ty_2 {{ union }}")
    }
}
impl Default for spi_transaction_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_transaction_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "spi_transaction_t {{ flags: {:?}, cmd: {:?}, addr: {:?}, length: {:?}, rxlength: {:?}, user: {:?}, __bindgen_anon_1: {:?}, __bindgen_anon_2: {:?} }}" , self . flags , self . cmd , self . addr , self . length , self . rxlength , self . user , self . __bindgen_anon_1 , self . __bindgen_anon_2 )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spi_transaction_ext_t {
    pub base: spi_transaction_t,
    pub command_bits: u8,
    pub address_bits: u8,
    pub dummy_bits: u8,
}
impl Default for spi_transaction_ext_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for spi_transaction_ext_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "spi_transaction_ext_t {{ base: {:?}, command_bits: {:?}, address_bits: {:?}, dummy_bits: {:?} }}" , self . base , self . command_bits , self . address_bits , self . dummy_bits )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_device_t {
    _unused: [u8; 0],
}
pub type spi_device_handle_t = *mut spi_device_t;
extern "C" {
    pub fn spi_bus_add_device(
        host: spi_host_device_t,
        dev_config: *const spi_device_interface_config_t,
        handle: *mut spi_device_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_bus_remove_device(handle: spi_device_handle_t) -> esp_err_t;
}
extern "C" {
    pub fn spi_device_queue_trans(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_device_get_trans_result(
        handle: spi_device_handle_t,
        trans_desc: *mut *mut spi_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_device_transmit(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_device_polling_start(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_device_polling_end(
        handle: spi_device_handle_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_device_polling_transmit(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn spi_device_acquire_bus(device: spi_device_handle_t, wait: TickType_t) -> esp_err_t;
}
extern "C" {
    pub fn spi_device_release_bus(dev: spi_device_handle_t);
}
extern "C" {
    pub fn spi_cal_clock(
        fapb: std::os::raw::c_int,
        hz: std::os::raw::c_int,
        duty_cycle: std::os::raw::c_int,
        reg_o: *mut u32,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn spi_get_actual_clock(
        fapb: std::os::raw::c_int,
        hz: std::os::raw::c_int,
        duty_cycle: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn spi_get_timing(
        gpio_is_used: bool,
        input_delay_ns: std::os::raw::c_int,
        eff_clk: std::os::raw::c_int,
        dummy_o: *mut std::os::raw::c_int,
        cycles_remain_o: *mut std::os::raw::c_int,
    );
}
extern "C" {
    pub fn spi_get_freq_limit(
        gpio_is_used: bool,
        input_delay_ns: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum err_enum_t {
    ERR_OK = 0,
    ERR_MEM = -1,
    ERR_BUF = -2,
    ERR_TIMEOUT = -3,
    ERR_RTE = -4,
    ERR_INPROGRESS = -5,
    ERR_VAL = -6,
    ERR_WOULDBLOCK = -7,
    ERR_USE = -8,
    ERR_ALREADY = -9,
    ERR_ISCONN = -10,
    ERR_CONN = -11,
    ERR_IF = -12,
    ERR_ABRT = -13,
    ERR_RST = -14,
    ERR_CLSD = -15,
    ERR_ARG = -16,
}
pub type err_t = s8_t;
extern "C" {
    pub fn lwip_strerr(err: err_t) -> *const std::os::raw::c_char;
}
extern "C" {
    pub fn err_to_errno(err: err_t) -> std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct pollfd {
    pub fd: std::os::raw::c_int,
    pub events: std::os::raw::c_short,
    pub revents: std::os::raw::c_short,
}
pub type nfds_t = std::os::raw::c_uint;
extern "C" {
    pub fn poll(
        fds: *mut pollfd,
        nfds: nfds_t,
        timeout: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
impl pbuf_layer {
    pub const PBUF_RAW: pbuf_layer = pbuf_layer::PBUF_RAW_TX;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pbuf_layer {
    PBUF_TRANSPORT = 74,
    PBUF_IP = 54,
    PBUF_LINK = 14,
    PBUF_RAW_TX = 0,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pbuf_type {
    PBUF_RAM = 640,
    PBUF_ROM = 1,
    PBUF_REF = 65,
    PBUF_POOL = 386,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct pbuf {
    pub next: *mut pbuf,
    pub payload: *mut std::os::raw::c_void,
    pub tot_len: u16_t,
    pub len: u16_t,
    pub type_internal: u8_t,
    pub flags: u8_t,
    pub ref_: u8_t,
    pub if_idx: u8_t,
    pub l2_owner: *mut netif,
    pub l2_buf: *mut std::os::raw::c_void,
}
impl Default for pbuf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct pbuf_rom {
    pub next: *mut pbuf,
    pub payload: *const std::os::raw::c_void,
}
impl Default for pbuf_rom {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type pbuf_free_custom_fn = ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct pbuf_custom {
    pub pbuf: pbuf,
    pub custom_free_function: pbuf_free_custom_fn,
}
impl Default for pbuf_custom {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn pbuf_alloc(l: pbuf_layer, length: u16_t, type_: pbuf_type) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_alloc_reference(
        payload: *mut std::os::raw::c_void,
        length: u16_t,
        type_: pbuf_type,
    ) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_alloced_custom(
        l: pbuf_layer,
        length: u16_t,
        type_: pbuf_type,
        p: *mut pbuf_custom,
        payload_mem: *mut std::os::raw::c_void,
        payload_mem_len: u16_t,
    ) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_realloc(p: *mut pbuf, size: u16_t);
}
extern "C" {
    pub fn pbuf_header(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_header_force(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_add_header(p: *mut pbuf, header_size_increment: usize) -> u8_t;
}
extern "C" {
    pub fn pbuf_add_header_force(p: *mut pbuf, header_size_increment: usize) -> u8_t;
}
extern "C" {
    pub fn pbuf_remove_header(p: *mut pbuf, header_size: usize) -> u8_t;
}
extern "C" {
    pub fn pbuf_free_header(q: *mut pbuf, size: u16_t) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_ref(p: *mut pbuf);
}
extern "C" {
    pub fn pbuf_free(p: *mut pbuf) -> u8_t;
}
extern "C" {
    pub fn pbuf_clen(p: *const pbuf) -> u16_t;
}
extern "C" {
    pub fn pbuf_cat(head: *mut pbuf, tail: *mut pbuf);
}
extern "C" {
    pub fn pbuf_chain(head: *mut pbuf, tail: *mut pbuf);
}
extern "C" {
    pub fn pbuf_dechain(p: *mut pbuf) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_copy(p_to: *mut pbuf, p_from: *const pbuf) -> err_t;
}
extern "C" {
    pub fn pbuf_copy_partial(
        p: *const pbuf,
        dataptr: *mut std::os::raw::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_get_contiguous(
        p: *const pbuf,
        buffer: *mut std::os::raw::c_void,
        bufsize: usize,
        len: u16_t,
        offset: u16_t,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn pbuf_take(buf: *mut pbuf, dataptr: *const std::os::raw::c_void, len: u16_t) -> err_t;
}
extern "C" {
    pub fn pbuf_take_at(
        buf: *mut pbuf,
        dataptr: *const std::os::raw::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> err_t;
}
extern "C" {
    pub fn pbuf_skip(in_: *mut pbuf, in_offset: u16_t, out_offset: *mut u16_t) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_coalesce(p: *mut pbuf, layer: pbuf_layer) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_clone(l: pbuf_layer, type_: pbuf_type, p: *mut pbuf) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_get_at(p: *const pbuf, offset: u16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_try_get_at(p: *const pbuf, offset: u16_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pbuf_put_at(p: *mut pbuf, offset: u16_t, data: u8_t);
}
extern "C" {
    pub fn pbuf_memcmp(
        p: *const pbuf,
        offset: u16_t,
        s2: *const std::os::raw::c_void,
        n: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_memfind(
        p: *const pbuf,
        mem: *const std::os::raw::c_void,
        mem_len: u16_t,
        start_offset: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_strstr(p: *const pbuf, substr: *const std::os::raw::c_char) -> u16_t;
}
pub type mem_size_t = usize;
extern "C" {
    pub fn mem_init();
}
extern "C" {
    pub fn mem_trim(mem: *mut std::os::raw::c_void, size: mem_size_t) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn mem_malloc(size: mem_size_t) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn mem_calloc(count: mem_size_t, size: mem_size_t) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn mem_free(mem: *mut std::os::raw::c_void);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum memp_t {
    MEMP_RAW_PCB = 0,
    MEMP_UDP_PCB = 1,
    MEMP_TCP_PCB = 2,
    MEMP_TCP_PCB_LISTEN = 3,
    MEMP_TCP_SEG = 4,
    MEMP_FRAG_PBUF = 5,
    MEMP_NETBUF = 6,
    MEMP_NETCONN = 7,
    MEMP_TCPIP_MSG_API = 8,
    MEMP_TCPIP_MSG_INPKT = 9,
    MEMP_ARP_QUEUE = 10,
    MEMP_IGMP_GROUP = 11,
    MEMP_SYS_TIMEOUT = 12,
    MEMP_NETDB = 13,
    MEMP_ND6_QUEUE = 14,
    MEMP_IP6_REASSDATA = 15,
    MEMP_MLD6_GROUP = 16,
    MEMP_PBUF = 17,
    MEMP_PBUF_POOL = 18,
    MEMP_MAX = 19,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct memp_desc {
    pub desc: *const std::os::raw::c_char,
    pub size: u16_t,
}
impl Default for memp_desc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn memp_init_pool(desc: *const memp_desc);
}
extern "C" {
    pub fn memp_malloc_pool(desc: *const memp_desc) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn memp_free_pool(desc: *const memp_desc, mem: *mut std::os::raw::c_void);
}
extern "C" {
    pub static memp_pools: [*const memp_desc; 19usize];
}
extern "C" {
    pub fn memp_init();
}
extern "C" {
    pub fn memp_malloc(type_: memp_t) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn memp_free(type_: memp_t, mem: *mut std::os::raw::c_void);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lwip_internal_netif_client_data_index {
    LWIP_NETIF_CLIENT_DATA_INDEX_DHCP = 0,
    LWIP_NETIF_CLIENT_DATA_INDEX_IGMP = 1,
    LWIP_NETIF_CLIENT_DATA_INDEX_MLD6 = 2,
    LWIP_NETIF_CLIENT_DATA_INDEX_MAX = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum netif_mac_filter_action {
    NETIF_DEL_MAC_FILTER = 0,
    NETIF_ADD_MAC_FILTER = 1,
}
pub type netif_init_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif) -> err_t>;
pub type netif_input_fn =
    ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf, inp: *mut netif) -> err_t>;
pub type netif_output_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *const ip4_addr_t) -> err_t,
>;
pub type netif_output_ip6_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *const ip6_addr_t) -> err_t,
>;
pub type netif_linkoutput_fn =
    ::core::option::Option<unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf) -> err_t>;
pub type netif_status_callback_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif)>;
pub type netif_igmp_mac_filter_fn = ::core::option::Option<
    unsafe extern "C" fn(
        netif: *mut netif,
        group: *const ip4_addr_t,
        action: netif_mac_filter_action,
    ) -> err_t,
>;
pub type netif_mld_mac_filter_fn = ::core::option::Option<
    unsafe extern "C" fn(
        netif: *mut netif,
        group: *const ip6_addr_t,
        action: netif_mac_filter_action,
    ) -> err_t,
>;
pub type netif_addr_idx_t = u8_t;
pub type dhcp_event_fn = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netif {
    pub next: *mut netif,
    pub ip_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
    pub ip6_addr: [ip_addr_t; 3usize],
    pub ip6_addr_state: [u8_t; 3usize],
    pub ip6_addr_valid_life: [u32_t; 3usize],
    pub ip6_addr_pref_life: [u32_t; 3usize],
    pub ipv6_addr_cb:
        ::core::option::Option<unsafe extern "C" fn(netif: *mut netif, ip_idex: u8_t)>,
    pub input: netif_input_fn,
    pub output: netif_output_fn,
    pub linkoutput: netif_linkoutput_fn,
    pub output_ip6: netif_output_ip6_fn,
    pub state: *mut std::os::raw::c_void,
    pub client_data: [*mut std::os::raw::c_void; 3usize],
    pub dhcps_pcb: *mut udp_pcb,
    pub dhcp_event: dhcp_event_fn,
    pub hostname: *const std::os::raw::c_char,
    pub mtu: u16_t,
    pub mtu6: u16_t,
    pub hwaddr: [u8_t; 6usize],
    pub hwaddr_len: u8_t,
    pub flags: u8_t,
    pub name: [std::os::raw::c_char; 2usize],
    pub num: u8_t,
    pub ip6_autoconfig_enabled: u8_t,
    pub rs_count: u8_t,
    pub igmp_mac_filter: netif_igmp_mac_filter_fn,
    pub mld_mac_filter: netif_mld_mac_filter_fn,
    pub loop_first: *mut pbuf,
    pub loop_last: *mut pbuf,
    pub loop_cnt_current: u16_t,
    pub l2_buffer_free_notify: ::core::option::Option<
        unsafe extern "C" fn(lwip_netif: *mut netif, user_buf: *mut std::os::raw::c_void),
    >,
    pub last_ip_addr: ip_addr_t,
}
impl Default for netif {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for netif {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "netif {{ next: {:?}, ip_addr: {:?}, netmask: {:?}, gw: {:?}, ip6_addr: {:?}, ip6_addr_state: {:?}, ip6_addr_valid_life: {:?}, ip6_addr_pref_life: {:?}, ipv6_addr_cb: {:?}, input: {:?}, output: {:?}, linkoutput: {:?}, output_ip6: {:?}, state: {:?}, client_data: {:?}, dhcps_pcb: {:?}, dhcp_event: {:?}, hostname: {:?}, mtu: {:?}, mtu6: {:?}, hwaddr: {:?}, hwaddr_len: {:?}, flags: {:?}, name: {:?}, num: {:?}, ip6_autoconfig_enabled: {:?}, rs_count: {:?}, igmp_mac_filter: {:?}, mld_mac_filter: {:?}, loop_first: {:?}, loop_last: {:?}, loop_cnt_current: {:?}, l2_buffer_free_notify: {:?}, last_ip_addr: {:?} }}" , self . next , self . ip_addr , self . netmask , self . gw , self . ip6_addr , self . ip6_addr_state , self . ip6_addr_valid_life , self . ip6_addr_pref_life , self . ipv6_addr_cb , self . input , self . output , self . linkoutput , self . output_ip6 , self . state , self . client_data , self . dhcps_pcb , self . dhcp_event , self . hostname , self . mtu , self . mtu6 , self . hwaddr , self . hwaddr_len , self . flags , self . name , self . num , self . ip6_autoconfig_enabled , self . rs_count , self . igmp_mac_filter , self . mld_mac_filter , self . loop_first , self . loop_last , self . loop_cnt_current , self . l2_buffer_free_notify , self . last_ip_addr )
    }
}
extern "C" {
    pub static mut netif_list: *mut netif;
}
extern "C" {
    pub static mut netif_default: *mut netif;
}
extern "C" {
    pub fn netif_init();
}
extern "C" {
    pub fn netif_add_noaddr(
        netif: *mut netif,
        state: *mut std::os::raw::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
}
extern "C" {
    pub fn netif_add(
        netif: *mut netif,
        ipaddr: *const ip4_addr_t,
        netmask: *const ip4_addr_t,
        gw: *const ip4_addr_t,
        state: *mut std::os::raw::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
}
extern "C" {
    pub fn netif_set_addr(
        netif: *mut netif,
        ipaddr: *const ip4_addr_t,
        netmask: *const ip4_addr_t,
        gw: *const ip4_addr_t,
    );
}
extern "C" {
    pub fn netif_set_garp_flag(netif: *mut netif);
}
extern "C" {
    pub fn netif_remove(netif: *mut netif);
}
extern "C" {
    pub fn netif_find(name: *const std::os::raw::c_char) -> *mut netif;
}
extern "C" {
    pub fn netif_set_default(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_ipaddr(netif: *mut netif, ipaddr: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_netmask(netif: *mut netif, netmask: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_gw(netif: *mut netif, gw: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_up(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_down(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_link_up(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_link_down(netif: *mut netif);
}
extern "C" {
    pub fn netif_loop_output(netif: *mut netif, p: *mut pbuf) -> err_t;
}
extern "C" {
    pub fn netif_poll(netif: *mut netif);
}
extern "C" {
    pub fn netif_input(p: *mut pbuf, inp: *mut netif) -> err_t;
}
extern "C" {
    pub fn netif_ip6_addr_set(netif: *mut netif, addr_idx: s8_t, addr6: *const ip6_addr_t);
}
extern "C" {
    pub fn netif_ip6_addr_set_parts(
        netif: *mut netif,
        addr_idx: s8_t,
        i0: u32_t,
        i1: u32_t,
        i2: u32_t,
        i3: u32_t,
    );
}
extern "C" {
    pub fn netif_ip6_addr_set_state(netif: *mut netif, addr_idx: s8_t, state: u8_t);
}
extern "C" {
    pub fn netif_get_ip6_addr_match(netif: *mut netif, ip6addr: *const ip6_addr_t) -> s8_t;
}
extern "C" {
    pub fn netif_create_ip6_linklocal_address(netif: *mut netif, from_mac_48bit: u8_t);
}
extern "C" {
    pub fn netif_add_ip6_address(
        netif: *mut netif,
        ip6addr: *const ip6_addr_t,
        chosen_idx: *mut s8_t,
    ) -> err_t;
}
extern "C" {
    pub fn netif_name_to_index(name: *const std::os::raw::c_char) -> u8_t;
}
extern "C" {
    pub fn netif_index_to_name(
        idx: u8_t,
        name: *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn netif_get_by_index(idx: u8_t) -> *mut netif;
}
pub type netif_nsc_reason_t = u16_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union netif_ext_callback_args_t {
    pub link_changed: link_changed_s,
    pub status_changed: status_changed_s,
    pub ipv4_changed: ipv4_changed_s,
    pub ipv6_set: ipv6_set_s,
    pub ipv6_addr_state_changed: ipv6_addr_state_changed_s,
    _bindgen_union_align: [u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct link_changed_s {
    pub state: u8_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct status_changed_s {
    pub state: u8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ipv4_changed_s {
    pub old_address: *const ip_addr_t,
    pub old_netmask: *const ip_addr_t,
    pub old_gw: *const ip_addr_t,
}
impl Default for ipv4_changed_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ipv6_set_s {
    pub addr_index: s8_t,
    pub old_address: *const ip_addr_t,
}
impl Default for ipv6_set_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ipv6_addr_state_changed_s {
    pub addr_index: s8_t,
    pub old_state: u8_t,
    pub address: *const ip_addr_t,
}
impl Default for ipv6_addr_state_changed_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for netif_ext_callback_args_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for netif_ext_callback_args_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "netif_ext_callback_args_t {{ union }}")
    }
}
pub type netif_ext_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        netif: *mut netif,
        reason: netif_nsc_reason_t,
        args: *const netif_ext_callback_args_t,
    ),
>;
extern "C" {
    pub fn memchr(
        arg1: *const std::os::raw::c_void,
        arg2: std::os::raw::c_int,
        arg3: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const std::os::raw::c_void,
        arg2: *const std::os::raw::c_void,
        arg3: std::os::raw::c_uint,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut std::os::raw::c_void,
        arg2: *const std::os::raw::c_void,
        arg3: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut std::os::raw::c_void,
        arg2: *const std::os::raw::c_void,
        arg3: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut std::os::raw::c_void,
        arg2: std::os::raw::c_int,
        arg3: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const std::os::raw::c_char,
        arg2: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn strerror(arg1: std::os::raw::c_int) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const std::os::raw::c_char) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn strncat(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_uint,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const std::os::raw::c_char,
        arg2: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn strstr(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_uint,
    ) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: *mut *mut std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        arg1: *const std::os::raw::c_void,
        arg2: *const std::os::raw::c_void,
        arg3: std::os::raw::c_uint,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const std::os::raw::c_void, arg2: *mut std::os::raw::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut std::os::raw::c_void, arg2: std::os::raw::c_uint);
}
extern "C" {
    pub fn ffs(arg1: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const std::os::raw::c_char,
        arg2: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut std::os::raw::c_void,
        arg2: *const std::os::raw::c_void,
        arg3: std::os::raw::c_int,
        arg4: usize,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        arg1: *const std::os::raw::c_void,
        arg2: std::os::raw::c_int,
        arg3: usize,
    ) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn rindex(
        arg1: *const std::os::raw::c_char,
        arg2: std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(arg1: *const std::os::raw::c_char) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const std::os::raw::c_char,
        arg2: std::os::raw::c_uint,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const std::os::raw::c_char,
        arg3: usize,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        arg1: std::os::raw::c_int,
        arg2: *mut std::os::raw::c_char,
        arg3: usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: std::os::raw::c_int,
        arg3: std::os::raw::c_int,
        arg4: *mut std::os::raw::c_int,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_uint,
    ) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_uint,
    ) -> std::os::raw::c_uint;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
        arg3: std::os::raw::c_uint,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn strnlen(arg1: *const std::os::raw::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut std::os::raw::c_char,
        arg2: *const std::os::raw::c_char,
    ) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut std::os::raw::c_char) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut std::os::raw::c_char) -> *mut std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__signo: std::os::raw::c_int) -> *mut std::os::raw::c_char;
}
pub type sa_family_t = u8_t;
pub type in_port_t = u16_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sockaddr_in {
    pub sin_len: u8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: u8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32_t,
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for sockaddr_in6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! ( f , "sockaddr_in6 {{ sin6_len: {:?}, sin6_family: {:?}, sin6_port: {:?}, sin6_flowinfo: {:?}, sin6_addr: {:?}, sin6_scope_id: {:?} }}" , self . sin6_len , self . sin6_family , self . sin6_port , self . sin6_flowinfo , self . sin6_addr , self . sin6_scope_id )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sockaddr {
    pub sa_len: u8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [std::os::raw::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sockaddr_storage {
    pub s2_len: u8_t,
    pub ss_family: sa_family_t,
    pub s2_data1: [std::os::raw::c_char; 2usize],
    pub s2_data2: [u32_t; 3usize],
    pub s2_data3: [u32_t; 3usize],
}
pub type socklen_t = u32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct iovec {
    pub iov_base: *mut std::os::raw::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct msghdr {
    pub msg_name: *mut std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: std::os::raw::c_int,
    pub msg_control: *mut std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: std::os::raw::c_int,
}
impl Default for msghdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: std::os::raw::c_int,
    pub cmsg_type: std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct ifreq {
    pub ifr_name: [std::os::raw::c_char; 6usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct linger {
    pub l_onoff: std::os::raw::c_int,
    pub l_linger: std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct in_pktinfo {
    pub ipi_ifindex: std::os::raw::c_uint,
    pub ipi_addr: in_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: std::os::raw::c_uint,
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for ipv6_mreq {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "ipv6_mreq {{ ipv6mr_multiaddr: {:?}, ipv6mr_interface: {:?} }}",
            self.ipv6mr_multiaddr, self.ipv6mr_interface
        )
    }
}
extern "C" {
    pub fn lwip_socket_thread_init();
}
extern "C" {
    pub fn lwip_socket_thread_cleanup();
}
extern "C" {
    pub fn lwip_accept(
        s: std::os::raw::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_bind(
        s: std::os::raw::c_int,
        name: *const sockaddr,
        namelen: socklen_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_shutdown(s: std::os::raw::c_int, how: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_getpeername(
        s: std::os::raw::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_getsockname(
        s: std::os::raw::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_getsockopt(
        s: std::os::raw::c_int,
        level: std::os::raw::c_int,
        optname: std::os::raw::c_int,
        optval: *mut std::os::raw::c_void,
        optlen: *mut socklen_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_setsockopt(
        s: std::os::raw::c_int,
        level: std::os::raw::c_int,
        optname: std::os::raw::c_int,
        optval: *const std::os::raw::c_void,
        optlen: socklen_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_close(s: std::os::raw::c_int) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_connect(
        s: std::os::raw::c_int,
        name: *const sockaddr,
        namelen: socklen_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_listen(s: std::os::raw::c_int, backlog: std::os::raw::c_int)
        -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_recv(
        s: std::os::raw::c_int,
        mem: *mut std::os::raw::c_void,
        len: usize,
        flags: std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_read(s: std::os::raw::c_int, mem: *mut std::os::raw::c_void, len: usize) -> isize;
}
extern "C" {
    pub fn lwip_readv(
        s: std::os::raw::c_int,
        iov: *const iovec,
        iovcnt: std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_recvfrom(
        s: std::os::raw::c_int,
        mem: *mut std::os::raw::c_void,
        len: usize,
        flags: std::os::raw::c_int,
        from: *mut sockaddr,
        fromlen: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn lwip_recvmsg(
        s: std::os::raw::c_int,
        message: *mut msghdr,
        flags: std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_send(
        s: std::os::raw::c_int,
        dataptr: *const std::os::raw::c_void,
        size: usize,
        flags: std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_sendmsg(
        s: std::os::raw::c_int,
        message: *const msghdr,
        flags: std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_sendto(
        s: std::os::raw::c_int,
        dataptr: *const std::os::raw::c_void,
        size: usize,
        flags: std::os::raw::c_int,
        to: *const sockaddr,
        tolen: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn lwip_socket(
        domain: std::os::raw::c_int,
        type_: std::os::raw::c_int,
        protocol: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_write(
        s: std::os::raw::c_int,
        dataptr: *const std::os::raw::c_void,
        size: usize,
    ) -> isize;
}
extern "C" {
    pub fn lwip_writev(
        s: std::os::raw::c_int,
        iov: *const iovec,
        iovcnt: std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn lwip_select(
        maxfdp1: std::os::raw::c_int,
        readset: *mut _types_fd_set,
        writeset: *mut _types_fd_set,
        exceptset: *mut _types_fd_set,
        timeout: *mut timeval,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_poll(
        fds: *mut pollfd,
        nfds: nfds_t,
        timeout: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_ioctl(
        s: std::os::raw::c_int,
        cmd: std::os::raw::c_long,
        argp: *mut std::os::raw::c_void,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_fcntl(
        s: std::os::raw::c_int,
        cmd: std::os::raw::c_int,
        val: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_inet_ntop(
        af: std::os::raw::c_int,
        src: *const std::os::raw::c_void,
        dst: *mut std::os::raw::c_char,
        size: socklen_t,
    ) -> *const std::os::raw::c_char;
}
extern "C" {
    pub fn lwip_inet_pton(
        af: std::os::raw::c_int,
        src: *const std::os::raw::c_char,
        dst: *mut std::os::raw::c_void,
    ) -> std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct hostent {
    pub h_name: *mut std::os::raw::c_char,
    pub h_aliases: *mut *mut std::os::raw::c_char,
    pub h_addrtype: std::os::raw::c_int,
    pub h_length: std::os::raw::c_int,
    pub h_addr_list: *mut *mut std::os::raw::c_char,
}
impl Default for hostent {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct addrinfo {
    pub ai_flags: std::os::raw::c_int,
    pub ai_family: std::os::raw::c_int,
    pub ai_socktype: std::os::raw::c_int,
    pub ai_protocol: std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut std::os::raw::c_char,
    pub ai_next: *mut addrinfo,
}
impl Default for addrinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut h_errno: std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_gethostbyname(name: *const std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn lwip_gethostbyname_r(
        name: *const std::os::raw::c_char,
        ret: *mut hostent,
        buf: *mut std::os::raw::c_char,
        buflen: usize,
        result: *mut *mut hostent,
        h_errnop: *mut std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn lwip_freeaddrinfo(ai: *mut addrinfo);
}
extern "C" {
    pub fn lwip_getaddrinfo(
        nodename: *const std::os::raw::c_char,
        servname: *const std::os::raw::c_char,
        hints: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> std::os::raw::c_int;
}
pub type lwip_thread_fn =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut std::os::raw::c_void)>;
extern "C" {
    pub fn sys_mutex_new(mutex: *mut sys_mutex_t) -> err_t;
}
extern "C" {
    pub fn sys_mutex_lock(mutex: *mut sys_mutex_t);
}
extern "C" {
    pub fn sys_mutex_unlock(mutex: *mut sys_mutex_t);
}
extern "C" {
    pub fn sys_mutex_free(mutex: *mut sys_mutex_t);
}
extern "C" {
    pub fn sys_sem_new(sem: *mut sys_sem_t, count: u8_t) -> err_t;
}
extern "C" {
    pub fn sys_sem_signal(sem: *mut sys_sem_t);
}
extern "C" {
    pub fn sys_sem_signal_isr(sem: *mut sys_sem_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn sys_arch_sem_wait(sem: *mut sys_sem_t, timeout: u32_t) -> u32_t;
}
extern "C" {
    pub fn sys_sem_free(sem: *mut sys_sem_t);
}
extern "C" {
    pub fn sys_msleep(ms: u32_t);
}
extern "C" {
    pub fn sys_mbox_new(mbox: *mut sys_mbox_t, size: std::os::raw::c_int) -> err_t;
}
extern "C" {
    pub fn sys_mbox_post(mbox: *mut sys_mbox_t, msg: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn sys_mbox_trypost(mbox: *mut sys_mbox_t, msg: *mut std::os::raw::c_void) -> err_t;
}
extern "C" {
    pub fn sys_mbox_trypost_fromisr(mbox: *mut sys_mbox_t, msg: *mut std::os::raw::c_void)
        -> err_t;
}
extern "C" {
    pub fn sys_arch_mbox_fetch(
        mbox: *mut sys_mbox_t,
        msg: *mut *mut std::os::raw::c_void,
        timeout: u32_t,
    ) -> u32_t;
}
extern "C" {
    pub fn sys_arch_mbox_tryfetch(
        mbox: *mut sys_mbox_t,
        msg: *mut *mut std::os::raw::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn sys_mbox_free(mbox: *mut sys_mbox_t);
}
extern "C" {
    pub fn sys_thread_new(
        name: *const std::os::raw::c_char,
        thread: lwip_thread_fn,
        arg: *mut std::os::raw::c_void,
        stacksize: std::os::raw::c_int,
        prio: std::os::raw::c_int,
    ) -> sys_thread_t;
}
extern "C" {
    pub fn sys_init();
}
extern "C" {
    pub fn sys_jiffies() -> u32_t;
}
extern "C" {
    pub fn sys_now() -> u32_t;
}
extern "C" {
    pub fn sys_arch_protect() -> sys_prot_t;
}
extern "C" {
    pub fn sys_arch_unprotect(pval: sys_prot_t);
}
pub const LWIP_IPADDR_ANY: u32_t = 0;
pub const LWIP_INADDR_ANY: u32_t = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _pthread_cleanup_context {
    pub _routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void)>,
    pub _arg: *mut std::os::raw::c_void,
    pub _canceltype: std::os::raw::c_int,
    pub _previous: *mut _pthread_cleanup_context,
}
impl Default for _pthread_cleanup_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn pthread_atfork(
        prepare: ::core::option::Option<unsafe extern "C" fn()>,
        parent: ::core::option::Option<unsafe extern "C" fn()>,
        child: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __attr: *const pthread_mutexattr_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __attr: *const pthread_condattr_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__mutex: *mut pthread_cond_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        attr: *mut pthread_attr_t,
        __stackaddr: *mut std::os::raw::c_void,
        __stacksize: usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        attr: *const pthread_attr_t,
        __stackaddr: *mut *mut std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut std::os::raw::c_void,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut std::os::raw::c_void,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create(
        __pthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut std::os::raw::c_void) -> *mut std::os::raw::c_void,
        >,
        __arg: *mut std::os::raw::c_void,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_join(
        __pthread: pthread_t,
        __value_ptr: *mut *mut std::os::raw::c_void,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__pthread: pthread_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__value_ptr: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__t1: pthread_t, __t2: pthread_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void)>,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __value: *const std::os::raw::c_void,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__pthread: pthread_t) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: std::os::raw::c_int,
        __oldstate: *mut std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: std::os::raw::c_int,
        __oldtype: *mut std::os::raw::c_int,
    ) -> std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn _pthread_cleanup_push(
        _context: *mut _pthread_cleanup_context,
        _routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void)>,
        _arg: *mut std::os::raw::c_void,
    );
}
extern "C" {
    pub fn _pthread_cleanup_pop(
        _context: *mut _pthread_cleanup_context,
        _execute: std::os::raw::c_int,
    );
}
pub type TimerHandle_t = *mut std::os::raw::c_void;
pub type TimerCallbackFunction_t =
    ::core::option::Option<unsafe extern "C" fn(xTimer: TimerHandle_t)>;
pub type PendedFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut std::os::raw::c_void, arg2: u32)>;
extern "C" {
    pub fn xTimerCreate(
        pcTimerName: *const std::os::raw::c_char,
        xTimerPeriodInTicks: TickType_t,
        uxAutoReload: UBaseType_t,
        pvTimerID: *mut std::os::raw::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
    ) -> TimerHandle_t;
}
extern "C" {
    pub fn pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut std::os::raw::c_void;
}
extern "C" {
    pub fn vTimerSetTimerID(xTimer: TimerHandle_t, pvNewID: *mut std::os::raw::c_void);
}
extern "C" {
    pub fn xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
    pub fn xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
    pub fn xTimerPendFunctionCallFromISR(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut std::os::raw::c_void,
        ulParameter2: u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTimerPendFunctionCall(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut std::os::raw::c_void,
        ulParameter2: u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn pcTimerGetTimerName(xTimer: TimerHandle_t) -> *const std::os::raw::c_char;
}
extern "C" {
    pub fn xTimerCreateTimerTask() -> BaseType_t;
}
extern "C" {
    pub fn xTimerGenericCommand(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
pub type EventGroupHandle_t = *mut std::os::raw::c_void;
pub type EventBits_t = TickType_t;
extern "C" {
    pub fn xEventGroupCreate() -> EventGroupHandle_t;
}
extern "C" {
    pub fn xEventGroupWaitBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToWaitFor: EventBits_t,
        xClearOnExit: BaseType_t,
        xWaitForAllBits: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
extern "C" {
    pub fn xEventGroupClearBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> EventBits_t;
}
extern "C" {
    pub fn xEventGroupSetBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
    ) -> EventBits_t;
}
extern "C" {
    pub fn xEventGroupSync(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        uxBitsToWaitFor: EventBits_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
extern "C" {
    pub fn xEventGroupGetBitsFromISR(xEventGroup: EventGroupHandle_t) -> EventBits_t;
}
extern "C" {
    pub fn vEventGroupDelete(xEventGroup: EventGroupHandle_t);
}
extern "C" {
    pub fn vEventGroupSetBitsCallback(pvEventGroup: *mut std::os::raw::c_void, ulBitsToSet: u32);
}
extern "C" {
    pub fn vEventGroupClearBitsCallback(
        pvEventGroup: *mut std::os::raw::c_void,
        ulBitsToClear: u32,
    );
}
pub type __builtin_va_list = __va_list_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __va_list_tag {
    pub __va_stk: *mut std::os::raw::c_int,
    pub __va_reg: *mut std::os::raw::c_int,
    pub __va_ndx: std::os::raw::c_int,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct udp_pcb {
    pub _address: u8,
}
